
radio.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000004ae  00800100  00002b9c  00002c30  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b9c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000017  008005ae  008005ae  000030de  2**0
                  ALLOC
  3 .stab         00003450  00000000  00000000  000030e0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001562  00000000  00000000  00006530  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 54 01 	jmp	0x2a8	; 0x2a8 <__vector_1>
       8:	0c 94 6b 01 	jmp	0x2d6	; 0x2d6 <__vector_2>
       c:	0c 94 82 01 	jmp	0x304	; 0x304 <__vector_3>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 94 01 	jmp	0x328	; 0x328 <__vector_7>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 3d 01 	jmp	0x27a	; 0x27a <__vector_15>
      40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d0 e1       	ldi	r29, 0x10	; 16
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	15 e0       	ldi	r17, 0x05	; 5
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	ec e9       	ldi	r30, 0x9C	; 156
      90:	fb e2       	ldi	r31, 0x2B	; 43
      92:	02 c0       	rjmp	.+4      	; 0x98 <.do_copy_data_start>

00000094 <.do_copy_data_loop>:
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0

00000098 <.do_copy_data_start>:
      98:	ae 3a       	cpi	r26, 0xAE	; 174
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <.do_copy_data_loop>

0000009e <__do_clear_bss>:
      9e:	15 e0       	ldi	r17, 0x05	; 5
      a0:	ae ea       	ldi	r26, 0xAE	; 174
      a2:	b5 e0       	ldi	r27, 0x05	; 5
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	a5 3c       	cpi	r26, 0xC5	; 197
      aa:	b1 07       	cpc	r27, r17
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 ab 01 	call	0x356	; 0x356 <main>
      b2:	0c 94 cc 15 	jmp	0x2b98	; 0x2b98 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <swap>:
* Requirements	:
*
***************************************************************** */

WORD swap(WORD w)
{
      ba:	df 93       	push	r29
      bc:	cf 93       	push	r28
      be:	00 d0       	rcall	.+0      	; 0xc0 <swap+0x6>
      c0:	cd b7       	in	r28, 0x3d	; 61
      c2:	de b7       	in	r29, 0x3e	; 62
      c4:	9a 83       	std	Y+2, r25	; 0x02
      c6:	89 83       	std	Y+1, r24	; 0x01
	return (w>>8 | (w&0xFF)<<8);
      c8:	99 81       	ldd	r25, Y+1	; 0x01
      ca:	8a 81       	ldd	r24, Y+2	; 0x02
}
      cc:	0f 90       	pop	r0
      ce:	0f 90       	pop	r0
      d0:	cf 91       	pop	r28
      d2:	df 91       	pop	r29
      d4:	08 95       	ret

000000d6 <wait_ms>:
* Requirements	:
*
***************************************************************** */

BYTE wait_ms(unsigned int n)
{
      d6:	df 93       	push	r29
      d8:	cf 93       	push	r28
      da:	cd b7       	in	r28, 0x3d	; 61
      dc:	de b7       	in	r29, 0x3e	; 62
      de:	27 97       	sbiw	r28, 0x07	; 7
      e0:	0f b6       	in	r0, 0x3f	; 63
      e2:	f8 94       	cli
      e4:	de bf       	out	0x3e, r29	; 62
      e6:	0f be       	out	0x3f, r0	; 63
      e8:	cd bf       	out	0x3d, r28	; 61
      ea:	9c 83       	std	Y+4, r25	; 0x04
      ec:	8b 83       	std	Y+3, r24	; 0x03
	unsigned int x = 0;
      ee:	1a 82       	std	Y+2, r1	; 0x02
      f0:	19 82       	std	Y+1, r1	; 0x01

	WDR();
      f2:	a8 95       	wdr
      f4:	13 c0       	rjmp	.+38     	; 0x11c <wait_ms+0x46>
	
	

	while(n--)
	{
		x=290;       //empirically determined fudge factor 8 Mhz
      f6:	82 e2       	ldi	r24, 0x22	; 34
      f8:	91 e0       	ldi	r25, 0x01	; 1
      fa:	9a 83       	std	Y+2, r25	; 0x02
      fc:	89 83       	std	Y+1, r24	; 0x01
		while(x--);
      fe:	1f 82       	std	Y+7, r1	; 0x07
     100:	89 81       	ldd	r24, Y+1	; 0x01
     102:	9a 81       	ldd	r25, Y+2	; 0x02
     104:	00 97       	sbiw	r24, 0x00	; 0
     106:	11 f0       	breq	.+4      	; 0x10c <wait_ms+0x36>
     108:	81 e0       	ldi	r24, 0x01	; 1
     10a:	8f 83       	std	Y+7, r24	; 0x07
     10c:	89 81       	ldd	r24, Y+1	; 0x01
     10e:	9a 81       	ldd	r25, Y+2	; 0x02
     110:	01 97       	sbiw	r24, 0x01	; 1
     112:	9a 83       	std	Y+2, r25	; 0x02
     114:	89 83       	std	Y+1, r24	; 0x01
     116:	8f 81       	ldd	r24, Y+7	; 0x07
     118:	88 23       	and	r24, r24
     11a:	89 f7       	brne	.-30     	; 0xfe <wait_ms+0x28>
	
	//while (n == 0);
	
	

	while(n--)
     11c:	1e 82       	std	Y+6, r1	; 0x06
     11e:	8b 81       	ldd	r24, Y+3	; 0x03
     120:	9c 81       	ldd	r25, Y+4	; 0x04
     122:	00 97       	sbiw	r24, 0x00	; 0
     124:	11 f0       	breq	.+4      	; 0x12a <wait_ms+0x54>
     126:	81 e0       	ldi	r24, 0x01	; 1
     128:	8e 83       	std	Y+6, r24	; 0x06
     12a:	8b 81       	ldd	r24, Y+3	; 0x03
     12c:	9c 81       	ldd	r25, Y+4	; 0x04
     12e:	01 97       	sbiw	r24, 0x01	; 1
     130:	9c 83       	std	Y+4, r25	; 0x04
     132:	8b 83       	std	Y+3, r24	; 0x03
     134:	8e 81       	ldd	r24, Y+6	; 0x06
     136:	88 23       	and	r24, r24
     138:	f1 f6       	brne	.-68     	; 0xf6 <wait_ms+0x20>
	{
		x=290;       //empirically determined fudge factor 8 Mhz
		while(x--);
	}
  
	return (x == 0 ? 0 : 1);
     13a:	1d 82       	std	Y+5, r1	; 0x05
     13c:	89 81       	ldd	r24, Y+1	; 0x01
     13e:	9a 81       	ldd	r25, Y+2	; 0x02
     140:	00 97       	sbiw	r24, 0x00	; 0
     142:	11 f0       	breq	.+4      	; 0x148 <wait_ms+0x72>
     144:	81 e0       	ldi	r24, 0x01	; 1
     146:	8d 83       	std	Y+5, r24	; 0x05
     148:	8d 81       	ldd	r24, Y+5	; 0x05
}
     14a:	27 96       	adiw	r28, 0x07	; 7
     14c:	0f b6       	in	r0, 0x3f	; 63
     14e:	f8 94       	cli
     150:	de bf       	out	0x3e, r29	; 62
     152:	0f be       	out	0x3f, r0	; 63
     154:	cd bf       	out	0x3d, r28	; 61
     156:	cf 91       	pop	r28
     158:	df 91       	pop	r29
     15a:	08 95       	ret

0000015c <wait_us>:
*
* Requirements	:
*
***************************************************************** */
BYTE wait_us(unsigned int n)
{
     15c:	df 93       	push	r29
     15e:	cf 93       	push	r28
     160:	00 d0       	rcall	.+0      	; 0x162 <wait_us+0x6>
     162:	cd b7       	in	r28, 0x3d	; 61
     164:	de b7       	in	r29, 0x3e	; 62
     166:	9a 83       	std	Y+2, r25	; 0x02
     168:	89 83       	std	Y+1, r24	; 0x01
	delay_us(n);  
     16a:	89 81       	ldd	r24, Y+1	; 0x01
     16c:	9a 81       	ldd	r25, Y+2	; 0x02
     16e:	0e 94 2a 12 	call	0x2454	; 0x2454 <delay_us>
	return (TRUE);
     172:	8f ef       	ldi	r24, 0xFF	; 255
}
     174:	0f 90       	pop	r0
     176:	0f 90       	pop	r0
     178:	cf 91       	pop	r28
     17a:	df 91       	pop	r29
     17c:	08 95       	ret

0000017e <ioinit>:
* Requirements	:
*
***************************************************************** */

unsigned char ioinit(void)
{
     17e:	df 93       	push	r29
     180:	cf 93       	push	r28
     182:	cd b7       	in	r28, 0x3d	; 61
     184:	de b7       	in	r29, 0x3e	; 62
  	/********************************************************/
	/* PORTA : 	All ports configured as ADC inputs 			*/
	/********************************************************/
	DDRA = 0x7F; //0111 1111
     186:	e1 e2       	ldi	r30, 0x21	; 33
     188:	f0 e0       	ldi	r31, 0x00	; 0
     18a:	8f e7       	ldi	r24, 0x7F	; 127
     18c:	80 83       	st	Z, r24
	//       pin ADC7 is for converting Vref (input)
	
	/********************************************************/
	/* Disable pullup resistors on PORTA 					*/
	/********************************************************/
	PORTA = 0x00;	
     18e:	e2 e2       	ldi	r30, 0x22	; 34
     190:	f0 e0       	ldi	r31, 0x00	; 0
     192:	10 82       	st	Z, r1
	/*			4=one_wire_data, input	 					*/
	/*			5=AVR_SPI, input 							*/
	/*			6=AVR_SPI, input 							*/
	/*			7=AVR_SPI, input 							*/
	/********************************************************/
	DDRB = 0x07;			
     194:	e4 e2       	ldi	r30, 0x24	; 36
     196:	f0 e0       	ldi	r31, 0x00	; 0
     198:	87 e0       	ldi	r24, 0x07	; 7
     19a:	80 83       	st	Z, r24
	
	/********************************************************/
	/* Disable pullup resistors on PORTB 					*/
	/********************************************************/
	PORTB = 0x02;	 // led = off, mute = off, mode = ampl
     19c:	e5 e2       	ldi	r30, 0x25	; 37
     19e:	f0 e0       	ldi	r31, 0x00	; 0
     1a0:	82 e0       	ldi	r24, 0x02	; 2
     1a2:	80 83       	st	Z, r24
	/*			4=Not in use								*/
	/*			5=fault_1, input							*/
	/*			6=fault_0, input							*/
	/*			7=Not in use								*/
	/********************************************************/
	DDRC = 0x00;				
     1a4:	e7 e2       	ldi	r30, 0x27	; 39
     1a6:	f0 e0       	ldi	r31, 0x00	; 0
     1a8:	10 82       	st	Z, r1
	/********************************************************/
	/* Disable pullup resistors on PORTC 					*/
	/* DISP_RESET default inactive							*/
	/* HB_LED default inactive								*/
	/********************************************************/
	PORTC = 0x00;	
     1aa:	e8 e2       	ldi	r30, 0x28	; 40
     1ac:	f0 e0       	ldi	r31, 0x00	; 0
     1ae:	10 82       	st	Z, r1
	/*			4=PB3 input									*/
	/*			5=unused input								*/
	/*			6=unused input								*/
	/*			7=unused input								*/
	/********************************************************/
	DDRD = 0x02;
     1b0:	ea e2       	ldi	r30, 0x2A	; 42
     1b2:	f0 e0       	ldi	r31, 0x00	; 0
     1b4:	82 e0       	ldi	r24, 0x02	; 2
     1b6:	80 83       	st	Z, r24
	/* Configure pullup resistors on PORTD 					*/
	/* UART_RXD inactive									*/
	/* UART_TXD inactive 									*/
	/* Remaining [7:2] inactive								*/
	/********************************************************/
	PORTD = 0x00;	
     1b8:	eb e2       	ldi	r30, 0x2B	; 43
     1ba:	f0 e0       	ldi	r31, 0x00	; 0
     1bc:	10 82       	st	Z, r1
	/*MCUCR = MCUCR & 0xF0;*/  /*IRQ at low level on bit D2 */
	/*MCUCSR = MCUCSR & ~ISC2;*/ /* No extern IRQ2 			*/
	/*GICR = GICR | INT0;*/ /* Enable extern IRQ0, bit D2	*/
	
	// disable interrupt on INT2
	EIMSK = 0;
     1be:	ed e3       	ldi	r30, 0x3D	; 61
     1c0:	f0 e0       	ldi	r31, 0x00	; 0
     1c2:	10 82       	st	Z, r1
	
	// select falling edge interrupt on INT0
	EICRA = (10<<ISC00); // (11<<ÍSC00); // for rising edge
     1c4:	e9 e6       	ldi	r30, 0x69	; 105
     1c6:	f0 e0       	ldi	r31, 0x00	; 0
     1c8:	8a e0       	ldi	r24, 0x0A	; 10
     1ca:	80 83       	st	Z, r24

	// select falling edge interrupt on INT1
	EICRA |= (10<<ISC10); // (11<<ÍSC10); // for rising edge
     1cc:	a9 e6       	ldi	r26, 0x69	; 105
     1ce:	b0 e0       	ldi	r27, 0x00	; 0
     1d0:	e9 e6       	ldi	r30, 0x69	; 105
     1d2:	f0 e0       	ldi	r31, 0x00	; 0
     1d4:	80 81       	ld	r24, Z
     1d6:	88 62       	ori	r24, 0x28	; 40
     1d8:	8c 93       	st	X, r24
	// select falling edge interrupt on INT2
	//EICRA = (10<<ISC20); // (11<<ÍSC20); // for rising edge

	
	// clear interrupt flags
	EIFR = (1<<INTF2) | (1<<INTF1) | (1<<INTF0);
     1da:	ec e3       	ldi	r30, 0x3C	; 60
     1dc:	f0 e0       	ldi	r31, 0x00	; 0
     1de:	87 e0       	ldi	r24, 0x07	; 7
     1e0:	80 83       	st	Z, r24
	
	// enable interrupt on INT0 and INT1
	EIMSK = (1<<INT0) | (1<<INT1);
     1e2:	ed e3       	ldi	r30, 0x3D	; 61
     1e4:	f0 e0       	ldi	r31, 0x00	; 0
     1e6:	83 e0       	ldi	r24, 0x03	; 3
     1e8:	80 83       	st	Z, r24
	
	
	/********************************************************/
	/* Configure external pin change interrupts (PCINT)		*/
	
	PCMSK3 = (1<<PCINT28);
     1ea:	e3 e7       	ldi	r30, 0x73	; 115
     1ec:	f0 e0       	ldi	r31, 0x00	; 0
     1ee:	80 e1       	ldi	r24, 0x10	; 16
     1f0:	80 83       	st	Z, r24
	PCMSK2 = 0;
     1f2:	ed e6       	ldi	r30, 0x6D	; 109
     1f4:	f0 e0       	ldi	r31, 0x00	; 0
     1f6:	10 82       	st	Z, r1
	PCMSK1 = 0;
     1f8:	ec e6       	ldi	r30, 0x6C	; 108
     1fa:	f0 e0       	ldi	r31, 0x00	; 0
     1fc:	10 82       	st	Z, r1
	PCMSK0 = 0;
     1fe:	eb e6       	ldi	r30, 0x6B	; 107
     200:	f0 e0       	ldi	r31, 0x00	; 0
     202:	10 82       	st	Z, r1
	
	PCICR = (1<<PCIE3);
     204:	e8 e6       	ldi	r30, 0x68	; 104
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	88 e0       	ldi	r24, 0x08	; 8
     20a:	80 83       	st	Z, r24
	/* tmr1 running on MCU clock/8 							*/
	/* set PWM value to 0 									*/
	/* enable OC1, PB1, PB4, PB5 as output 					*/
	/* Timer enable init 0x04 								*/
	/********************************************************/
	TCCR1A = 0x00;														  
     20c:	e0 e8       	ldi	r30, 0x80	; 128
     20e:	f0 e0       	ldi	r31, 0x00	; 0
     210:	10 82       	st	Z, r1
	TCCR1B = 1<<CS11;										
     212:	e1 e8       	ldi	r30, 0x81	; 129
     214:	f0 e0       	ldi	r31, 0x00	; 0
     216:	82 e0       	ldi	r24, 0x02	; 2
     218:	80 83       	st	Z, r24
	OCR1A = 0;    												 
     21a:	e8 e8       	ldi	r30, 0x88	; 136
     21c:	f0 e0       	ldi	r31, 0x00	; 0
     21e:	11 82       	std	Z+1, r1	; 0x01
     220:	10 82       	st	Z, r1
	DDRB = 1<<DDRB | 1<<PB1 | 1<<PB4 | 1<<PB5;   			
     222:	a4 e2       	ldi	r26, 0x24	; 36
     224:	b0 e0       	ldi	r27, 0x00	; 0
     226:	e4 e2       	ldi	r30, 0x24	; 36
     228:	f0 e0       	ldi	r31, 0x00	; 0
     22a:	80 81       	ld	r24, Z
     22c:	28 2f       	mov	r18, r24
     22e:	30 e0       	ldi	r19, 0x00	; 0
     230:	81 e0       	ldi	r24, 0x01	; 1
     232:	90 e0       	ldi	r25, 0x00	; 0
     234:	02 c0       	rjmp	.+4      	; 0x23a <ioinit+0xbc>
     236:	88 0f       	add	r24, r24
     238:	99 1f       	adc	r25, r25
     23a:	2a 95       	dec	r18
     23c:	e2 f7       	brpl	.-8      	; 0x236 <ioinit+0xb8>
     23e:	82 63       	ori	r24, 0x32	; 50
     240:	8c 93       	st	X, r24
	TIMSK1 = 1<<TOIE1;	
     242:	ef e6       	ldi	r30, 0x6F	; 111
     244:	f0 e0       	ldi	r31, 0x00	; 0
     246:	81 e0       	ldi	r24, 0x01	; 1
     248:	80 83       	st	Z, r24

	//Init timer 0 for delay_us timing
	//8,000,000 / 8 = 1,000,000
    TCCR0B = (1<<CS01); //Set Prescaler to 8. CS01=1
     24a:	e5 e4       	ldi	r30, 0x45	; 69
     24c:	f0 e0       	ldi	r31, 0x00	; 0
     24e:	82 e0       	ldi	r24, 0x02	; 2
     250:	80 83       	st	Z, r24
										 

	/********************************************************/
	/* Init UART  											*/	
	/********************************************************/
	stdout = &mystdout; //Required for printf init
     252:	80 e0       	ldi	r24, 0x00	; 0
     254:	91 e0       	ldi	r25, 0x01	; 1
     256:	90 93 c2 05 	sts	0x05C2, r25
     25a:	80 93 c1 05 	sts	0x05C1, r24
	
	uart_init(BAUD_RATE);
     25e:	83 e3       	ldi	r24, 0x33	; 51
     260:	90 e0       	ldi	r25, 0x00	; 0
     262:	0e 94 76 06 	call	0xcec	; 0xcec <uart_init>

	/********************************************************/
	/* Init I2C  											*/	
	/********************************************************/
	init_i2c();
     266:	0e 94 3c 06 	call	0xc78	; 0xc78 <init_i2c>
	/* Init external peripherals							*/
	/********************************************************/
	//tuner_init();
	
    // initialize display, cursor off
    lcd_init(LCD_DISP_ON);
     26a:	8c e0       	ldi	r24, 0x0C	; 12
     26c:	0e 94 9a 08 	call	0x1134	; 0x1134 <lcd_init>
	// init_ow();
	
	/********************************************************/
	/* enable interrupts :  clear the global interupt mask	*/
	/********************************************************/	
    sei ();    			 
     270:	78 94       	sei
	
	return(TRUE);
     272:	8f ef       	ldi	r24, 0xFF	; 255
}
     274:	cf 91       	pop	r28
     276:	df 91       	pop	r29
     278:	08 95       	ret

0000027a <__vector_15>:
* Description	: Reads the contrast and brightness controls and write to OLED
*				  and DA - converter trough i2C bus.
*
***************************************************************** */
SIGNAL(SIG_OVERFLOW1)
{
     27a:	1f 92       	push	r1
     27c:	0f 92       	push	r0
     27e:	0f b6       	in	r0, 0x3f	; 63
     280:	0f 92       	push	r0
     282:	11 24       	eor	r1, r1
     284:	8f 93       	push	r24
     286:	df 93       	push	r29
     288:	cf 93       	push	r28
     28a:	cd b7       	in	r28, 0x3d	; 61
     28c:	de b7       	in	r29, 0x3e	; 62
	cli();						/* disable interrupts, no interupt during I2C bus transfer */
     28e:	f8 94       	cli

	timer_tick_detect = 1;
     290:	81 e0       	ldi	r24, 0x01	; 1
     292:	80 93 b1 05 	sts	0x05B1, r24

	sei();						/* enable interrupts */
     296:	78 94       	sei
}
     298:	cf 91       	pop	r28
     29a:	df 91       	pop	r29
     29c:	8f 91       	pop	r24
     29e:	0f 90       	pop	r0
     2a0:	0f be       	out	0x3f, r0	; 63
     2a2:	0f 90       	pop	r0
     2a4:	1f 90       	pop	r1
     2a6:	18 95       	reti

000002a8 <__vector_1>:
* Requirements	:
* Description	: IRQ when the FPGA detects changes in the videosystem.
*
***************************************************************** */
SIGNAL(SIG_INTERRUPT0)
{
     2a8:	1f 92       	push	r1
     2aa:	0f 92       	push	r0
     2ac:	0f b6       	in	r0, 0x3f	; 63
     2ae:	0f 92       	push	r0
     2b0:	11 24       	eor	r1, r1
     2b2:	8f 93       	push	r24
     2b4:	df 93       	push	r29
     2b6:	cf 93       	push	r28
     2b8:	cd b7       	in	r28, 0x3d	; 61
     2ba:	de b7       	in	r29, 0x3e	; 62
	cli();									/* disable interrupts, no interrupt during I2C bus transfer */
     2bc:	f8 94       	cli
	
	button_detect = 1;
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	80 93 af 05 	sts	0x05AF, r24
	
	sei();									/* enable interrupts */
     2c4:	78 94       	sei
}
     2c6:	cf 91       	pop	r28
     2c8:	df 91       	pop	r29
     2ca:	8f 91       	pop	r24
     2cc:	0f 90       	pop	r0
     2ce:	0f be       	out	0x3f, r0	; 63
     2d0:	0f 90       	pop	r0
     2d2:	1f 90       	pop	r1
     2d4:	18 95       	reti

000002d6 <__vector_2>:

SIGNAL(SIG_INTERRUPT1)
{
     2d6:	1f 92       	push	r1
     2d8:	0f 92       	push	r0
     2da:	0f b6       	in	r0, 0x3f	; 63
     2dc:	0f 92       	push	r0
     2de:	11 24       	eor	r1, r1
     2e0:	8f 93       	push	r24
     2e2:	df 93       	push	r29
     2e4:	cf 93       	push	r28
     2e6:	cd b7       	in	r28, 0x3d	; 61
     2e8:	de b7       	in	r29, 0x3e	; 62
	cli();									/* disable interrupts, no interrupt during I2C bus transfer */
     2ea:	f8 94       	cli

	button_detect = 2;
     2ec:	82 e0       	ldi	r24, 0x02	; 2
     2ee:	80 93 af 05 	sts	0x05AF, r24

	sei();									/* enable interrupts */
     2f2:	78 94       	sei
}
     2f4:	cf 91       	pop	r28
     2f6:	df 91       	pop	r29
     2f8:	8f 91       	pop	r24
     2fa:	0f 90       	pop	r0
     2fc:	0f be       	out	0x3f, r0	; 63
     2fe:	0f 90       	pop	r0
     300:	1f 90       	pop	r1
     302:	18 95       	reti

00000304 <__vector_3>:


ISR (SIG_INTERRUPT2)
{
     304:	1f 92       	push	r1
     306:	0f 92       	push	r0
     308:	0f b6       	in	r0, 0x3f	; 63
     30a:	0f 92       	push	r0
     30c:	11 24       	eor	r1, r1
     30e:	df 93       	push	r29
     310:	cf 93       	push	r28
     312:	cd b7       	in	r28, 0x3d	; 61
     314:	de b7       	in	r29, 0x3e	; 62
	cli();									/* disable interrupts, no interrupt during I2C bus transfer */
     316:	f8 94       	cli


	sei();									/* enable interrupts */
     318:	78 94       	sei
}
     31a:	cf 91       	pop	r28
     31c:	df 91       	pop	r29
     31e:	0f 90       	pop	r0
     320:	0f be       	out	0x3f, r0	; 63
     322:	0f 90       	pop	r0
     324:	1f 90       	pop	r1
     326:	18 95       	reti

00000328 <__vector_7>:


ISR (SIG_PIN_CHANGE3)
{
     328:	1f 92       	push	r1
     32a:	0f 92       	push	r0
     32c:	0f b6       	in	r0, 0x3f	; 63
     32e:	0f 92       	push	r0
     330:	11 24       	eor	r1, r1
     332:	8f 93       	push	r24
     334:	df 93       	push	r29
     336:	cf 93       	push	r28
     338:	cd b7       	in	r28, 0x3d	; 61
     33a:	de b7       	in	r29, 0x3e	; 62
	cli();									/* disable interrupts, no interrupt during I2C bus transfer */
     33c:	f8 94       	cli

	button_detect_3 = 1;
     33e:	81 e0       	ldi	r24, 0x01	; 1
     340:	80 93 b0 05 	sts	0x05B0, r24

	sei();									/* enable interrupts */
     344:	78 94       	sei
}
     346:	cf 91       	pop	r28
     348:	df 91       	pop	r29
     34a:	8f 91       	pop	r24
     34c:	0f 90       	pop	r0
     34e:	0f be       	out	0x3f, r0	; 63
     350:	0f 90       	pop	r0
     352:	1f 90       	pop	r1
     354:	18 95       	reti

00000356 <main>:
* Returns		: int 0
*
***************************************************************** */

int main(void)
{
     356:	df 93       	push	r29
     358:	cf 93       	push	r28
     35a:	cd b7       	in	r28, 0x3d	; 61
     35c:	de b7       	in	r29, 0x3e	; 62
     35e:	c3 54       	subi	r28, 0x43	; 67
     360:	d0 40       	sbci	r29, 0x00	; 0
     362:	0f b6       	in	r0, 0x3f	; 63
     364:	f8 94       	cli
     366:	de bf       	out	0x3e, r29	; 62
     368:	0f be       	out	0x3f, r0	; 63
     36a:	cd bf       	out	0x3d, r28	; 61
	unsigned char i = 0;
     36c:	1f 82       	std	Y+7, r1	; 0x07
	
	BYTE menu = TUNE;
     36e:	82 e0       	ldi	r24, 0x02	; 2
     370:	8e 83       	std	Y+6, r24	; 0x06
	//BYTE EEMEM eeMenu;
	BYTE volume = 14; // min = 0, max = 16 (= width of LCD)
     372:	8e e0       	ldi	r24, 0x0E	; 14
     374:	8d 83       	std	Y+5, r24	; 0x05
	
	uint16_t readchan = 0, tmp = 0;
     376:	1c 82       	std	Y+4, r1	; 0x04
     378:	1b 82       	std	Y+3, r1	; 0x03
     37a:	1a 82       	std	Y+2, r1	; 0x02
     37c:	19 82       	std	Y+1, r1	; 0x01
	unsigned char msg[40];
	unsigned char str[16];
	
	//BYTE contrast = 0;

	wait_ms(10);		// wait for devices to startup
     37e:	8a e0       	ldi	r24, 0x0A	; 10
     380:	90 e0       	ldi	r25, 0x00	; 0
     382:	0e 94 6b 00 	call	0xd6	; 0xd6 <wait_ms>
	
	ioinit();			// init peripherals and GPIO pin directions and pullups
     386:	0e 94 bf 00 	call	0x17e	; 0x17e <ioinit>


	// print something on display at startup
	//lcd_clrscr();
	
	lcd_puts(" FM Radio Tuner \n");
     38a:	8e e0       	ldi	r24, 0x0E	; 14
     38c:	91 e0       	ldi	r25, 0x01	; 1
     38e:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>
	lcd_puts(" Joakim Lindén  ");
     392:	80 e2       	ldi	r24, 0x20	; 32
     394:	91 e0       	ldi	r25, 0x01	; 1
     396:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>
	*/
	
	
	// restore setting from EEPROM
    //menu = eeprom_read_byte(&eeMenu); 
	if (menu > 2)
     39a:	8e 81       	ldd	r24, Y+6	; 0x06
     39c:	83 30       	cpi	r24, 0x03	; 3
     39e:	10 f0       	brcs	.+4      	; 0x3a4 <main+0x4e>
		menu = 2;
     3a0:	82 e0       	ldi	r24, 0x02	; 2
     3a2:	8e 83       	std	Y+6, r24	; 0x06
		
	
	
	execute('7', volume); // calibrate
     3a4:	87 e3       	ldi	r24, 0x37	; 55
     3a6:	6d 81       	ldd	r22, Y+5	; 0x05
     3a8:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <execute>
	
	printmenu();
     3ac:	0e 94 ab 0c 	call	0x1956	; 0x1956 <printmenu>

    // loop forever, the interrupts are doing the rest
	while(1)
	{
		if(timer_tick_detect == 1)
     3b0:	80 91 b1 05 	lds	r24, 0x05B1
     3b4:	81 30       	cpi	r24, 0x01	; 1
     3b6:	e1 f7       	brne	.-8      	; 0x3b0 <main+0x5a>
		{					
			WDR();										// Reset Watchdog Timer
     3b8:	a8 95       	wdr
					
			//while( !(UCSR0A & (1<<RXC0)) );
			
			if (UCSR0A & (1<<RXC0))			// if command received from PC
     3ba:	e0 ec       	ldi	r30, 0xC0	; 192
     3bc:	f0 e0       	ldi	r31, 0x00	; 0
     3be:	80 81       	ld	r24, Z
     3c0:	88 23       	and	r24, r24
     3c2:	44 f4       	brge	.+16     	; 0x3d4 <main+0x7e>
			{
				execute(UDR0, volume);
     3c4:	e6 ec       	ldi	r30, 0xC6	; 198
     3c6:	f0 e0       	ldi	r31, 0x00	; 0
     3c8:	80 81       	ld	r24, Z
     3ca:	6d 81       	ldd	r22, Y+5	; 0x05
     3cc:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <execute>
				printmenu();
     3d0:	0e 94 ab 0c 	call	0x1956	; 0x1956 <printmenu>
			}

			if (button_detect_3 != 0)
     3d4:	80 91 b0 05 	lds	r24, 0x05B0
     3d8:	88 23       	and	r24, r24
     3da:	09 f4       	brne	.+2      	; 0x3de <main+0x88>
     3dc:	e0 c0       	rjmp	.+448    	; 0x59e <main+0x248>
			{
				// this button cycles through the menus (Tune --> Volume --> Save --> Tune)
				
				if (menu > 0)
     3de:	8e 81       	ldd	r24, Y+6	; 0x06
     3e0:	88 23       	and	r24, r24
     3e2:	21 f0       	breq	.+8      	; 0x3ec <main+0x96>
					menu--;
     3e4:	8e 81       	ldd	r24, Y+6	; 0x06
     3e6:	81 50       	subi	r24, 0x01	; 1
     3e8:	8e 83       	std	Y+6, r24	; 0x06
     3ea:	02 c0       	rjmp	.+4      	; 0x3f0 <main+0x9a>
				else
					menu = TUNE;
     3ec:	82 e0       	ldi	r24, 0x02	; 2
     3ee:	8e 83       	std	Y+6, r24	; 0x06
					
				printf("\nmenu = %i", menu);
     3f0:	8e 81       	ldd	r24, Y+6	; 0x06
     3f2:	28 2f       	mov	r18, r24
     3f4:	30 e0       	ldi	r19, 0x00	; 0
     3f6:	00 d0       	rcall	.+0      	; 0x3f8 <main+0xa2>
     3f8:	00 d0       	rcall	.+0      	; 0x3fa <main+0xa4>
     3fa:	ed b7       	in	r30, 0x3d	; 61
     3fc:	fe b7       	in	r31, 0x3e	; 62
     3fe:	31 96       	adiw	r30, 0x01	; 1
     400:	81 e3       	ldi	r24, 0x31	; 49
     402:	91 e0       	ldi	r25, 0x01	; 1
     404:	91 83       	std	Z+1, r25	; 0x01
     406:	80 83       	st	Z, r24
     408:	33 83       	std	Z+3, r19	; 0x03
     40a:	22 83       	std	Z+2, r18	; 0x02
     40c:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
     410:	0f 90       	pop	r0
     412:	0f 90       	pop	r0
     414:	0f 90       	pop	r0
     416:	0f 90       	pop	r0
				
				//if (eeprom_read_byte(&eeMenu) != menu)
				//	eeprom_write_byte(&eeMenu, menu); 
					
				// draw the right menu
				switch(menu)
     418:	8e 81       	ldd	r24, Y+6	; 0x06
     41a:	28 2f       	mov	r18, r24
     41c:	30 e0       	ldi	r19, 0x00	; 0
     41e:	24 96       	adiw	r28, 0x04	; 4
     420:	3f af       	std	Y+63, r19	; 0x3f
     422:	2e af       	std	Y+62, r18	; 0x3e
     424:	24 97       	sbiw	r28, 0x04	; 4
     426:	24 96       	adiw	r28, 0x04	; 4
     428:	8e ad       	ldd	r24, Y+62	; 0x3e
     42a:	9f ad       	ldd	r25, Y+63	; 0x3f
     42c:	24 97       	sbiw	r28, 0x04	; 4
     42e:	81 30       	cpi	r24, 0x01	; 1
     430:	91 05       	cpc	r25, r1
     432:	09 f4       	brne	.+2      	; 0x436 <main+0xe0>
     434:	73 c0       	rjmp	.+230    	; 0x51c <main+0x1c6>
     436:	24 96       	adiw	r28, 0x04	; 4
     438:	2e ad       	ldd	r18, Y+62	; 0x3e
     43a:	3f ad       	ldd	r19, Y+63	; 0x3f
     43c:	24 97       	sbiw	r28, 0x04	; 4
     43e:	22 30       	cpi	r18, 0x02	; 2
     440:	31 05       	cpc	r19, r1
     442:	41 f0       	breq	.+16     	; 0x454 <main+0xfe>
     444:	24 96       	adiw	r28, 0x04	; 4
     446:	8e ad       	ldd	r24, Y+62	; 0x3e
     448:	9f ad       	ldd	r25, Y+63	; 0x3f
     44a:	24 97       	sbiw	r28, 0x04	; 4
     44c:	00 97       	sbiw	r24, 0x00	; 0
     44e:	09 f4       	brne	.+2      	; 0x452 <main+0xfc>
     450:	8b c0       	rjmp	.+278    	; 0x568 <main+0x212>
     452:	9e c0       	rjmp	.+316    	; 0x590 <main+0x23a>
				{
					case TUNE:
						lcd_gotoxy(0,0);
     454:	80 e0       	ldi	r24, 0x00	; 0
     456:	60 e0       	ldi	r22, 0x00	; 0
     458:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
						tmp = (readchan + 690) / 10;
     45c:	8b 81       	ldd	r24, Y+3	; 0x03
     45e:	9c 81       	ldd	r25, Y+4	; 0x04
     460:	8e 54       	subi	r24, 0x4E	; 78
     462:	9d 4f       	sbci	r25, 0xFD	; 253
     464:	2a e0       	ldi	r18, 0x0A	; 10
     466:	30 e0       	ldi	r19, 0x00	; 0
     468:	b9 01       	movw	r22, r18
     46a:	0e 94 81 15 	call	0x2b02	; 0x2b02 <__udivmodhi4>
     46e:	cb 01       	movw	r24, r22
     470:	9a 83       	std	Y+2, r25	; 0x02
     472:	89 83       	std	Y+1, r24	; 0x01
						sprintf(str, "Tuned: %d.%d MHz ", tmp, (readchan + 690) - tmp*10);
     474:	89 81       	ldd	r24, Y+1	; 0x01
     476:	9a 81       	ldd	r25, Y+2	; 0x02
     478:	9c 01       	movw	r18, r24
     47a:	22 0f       	add	r18, r18
     47c:	33 1f       	adc	r19, r19
     47e:	c9 01       	movw	r24, r18
     480:	88 0f       	add	r24, r24
     482:	99 1f       	adc	r25, r25
     484:	88 0f       	add	r24, r24
     486:	99 1f       	adc	r25, r25
     488:	28 0f       	add	r18, r24
     48a:	39 1f       	adc	r19, r25
     48c:	8b 81       	ldd	r24, Y+3	; 0x03
     48e:	9c 81       	ldd	r25, Y+4	; 0x04
     490:	82 1b       	sub	r24, r18
     492:	93 0b       	sbc	r25, r19
     494:	9c 01       	movw	r18, r24
     496:	2e 54       	subi	r18, 0x4E	; 78
     498:	3d 4f       	sbci	r19, 0xFD	; 253
     49a:	8d b7       	in	r24, 0x3d	; 61
     49c:	9e b7       	in	r25, 0x3e	; 62
     49e:	08 97       	sbiw	r24, 0x08	; 8
     4a0:	0f b6       	in	r0, 0x3f	; 63
     4a2:	f8 94       	cli
     4a4:	9e bf       	out	0x3e, r25	; 62
     4a6:	0f be       	out	0x3f, r0	; 63
     4a8:	8d bf       	out	0x3d, r24	; 61
     4aa:	ed b7       	in	r30, 0x3d	; 61
     4ac:	fe b7       	in	r31, 0x3e	; 62
     4ae:	31 96       	adiw	r30, 0x01	; 1
     4b0:	ce 01       	movw	r24, r28
     4b2:	c0 96       	adiw	r24, 0x30	; 48
     4b4:	91 83       	std	Z+1, r25	; 0x01
     4b6:	80 83       	st	Z, r24
     4b8:	8c e3       	ldi	r24, 0x3C	; 60
     4ba:	91 e0       	ldi	r25, 0x01	; 1
     4bc:	93 83       	std	Z+3, r25	; 0x03
     4be:	82 83       	std	Z+2, r24	; 0x02
     4c0:	89 81       	ldd	r24, Y+1	; 0x01
     4c2:	9a 81       	ldd	r25, Y+2	; 0x02
     4c4:	95 83       	std	Z+5, r25	; 0x05
     4c6:	84 83       	std	Z+4, r24	; 0x04
     4c8:	37 83       	std	Z+7, r19	; 0x07
     4ca:	26 83       	std	Z+6, r18	; 0x06
     4cc:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <sprintf>
     4d0:	2d b7       	in	r18, 0x3d	; 61
     4d2:	3e b7       	in	r19, 0x3e	; 62
     4d4:	28 5f       	subi	r18, 0xF8	; 248
     4d6:	3f 4f       	sbci	r19, 0xFF	; 255
     4d8:	0f b6       	in	r0, 0x3f	; 63
     4da:	f8 94       	cli
     4dc:	3e bf       	out	0x3e, r19	; 62
     4de:	0f be       	out	0x3f, r0	; 63
     4e0:	2d bf       	out	0x3d, r18	; 61
						lcd_puts(str);
     4e2:	ce 01       	movw	r24, r28
     4e4:	c0 96       	adiw	r24, 0x30	; 48
     4e6:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>
						printf(str);
     4ea:	00 d0       	rcall	.+0      	; 0x4ec <main+0x196>
     4ec:	ed b7       	in	r30, 0x3d	; 61
     4ee:	fe b7       	in	r31, 0x3e	; 62
     4f0:	31 96       	adiw	r30, 0x01	; 1
     4f2:	ce 01       	movw	r24, r28
     4f4:	c0 96       	adiw	r24, 0x30	; 48
     4f6:	91 83       	std	Z+1, r25	; 0x01
     4f8:	80 83       	st	Z, r24
     4fa:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
     4fe:	0f 90       	pop	r0
     500:	0f 90       	pop	r0
						printf("\n\n Tune menu selected");
     502:	00 d0       	rcall	.+0      	; 0x504 <main+0x1ae>
     504:	ed b7       	in	r30, 0x3d	; 61
     506:	fe b7       	in	r31, 0x3e	; 62
     508:	31 96       	adiw	r30, 0x01	; 1
     50a:	8e e4       	ldi	r24, 0x4E	; 78
     50c:	91 e0       	ldi	r25, 0x01	; 1
     50e:	91 83       	std	Z+1, r25	; 0x01
     510:	80 83       	st	Z, r24
     512:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
     516:	0f 90       	pop	r0
     518:	0f 90       	pop	r0
     51a:	3a c0       	rjmp	.+116    	; 0x590 <main+0x23a>
					
					break;
					
					case VOL:
						lcd_gotoxy(0,0);
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	60 e0       	ldi	r22, 0x00	; 0
     520:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
						lcd_puts("Volume          \n                ");
     524:	84 e6       	ldi	r24, 0x64	; 100
     526:	91 e0       	ldi	r25, 0x01	; 1
     528:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>
						
						lcd_gotoxy(0,1);
     52c:	80 e0       	ldi	r24, 0x00	; 0
     52e:	61 e0       	ldi	r22, 0x01	; 1
     530:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
						
						for (i = 0; i < volume; i++)
     534:	1f 82       	std	Y+7, r1	; 0x07
     536:	07 c0       	rjmp	.+14     	; 0x546 <main+0x1f0>
							lcd_puts(">"); // draws the volume bar
     538:	86 e8       	ldi	r24, 0x86	; 134
     53a:	91 e0       	ldi	r25, 0x01	; 1
     53c:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>
						lcd_gotoxy(0,0);
						lcd_puts("Volume          \n                ");
						
						lcd_gotoxy(0,1);
						
						for (i = 0; i < volume; i++)
     540:	8f 81       	ldd	r24, Y+7	; 0x07
     542:	8f 5f       	subi	r24, 0xFF	; 255
     544:	8f 83       	std	Y+7, r24	; 0x07
     546:	9f 81       	ldd	r25, Y+7	; 0x07
     548:	8d 81       	ldd	r24, Y+5	; 0x05
     54a:	98 17       	cp	r25, r24
     54c:	a8 f3       	brcs	.-22     	; 0x538 <main+0x1e2>
							lcd_puts(">"); // draws the volume bar
						
						printf("\n\n Volume menu selected");
     54e:	00 d0       	rcall	.+0      	; 0x550 <main+0x1fa>
     550:	ed b7       	in	r30, 0x3d	; 61
     552:	fe b7       	in	r31, 0x3e	; 62
     554:	31 96       	adiw	r30, 0x01	; 1
     556:	88 e8       	ldi	r24, 0x88	; 136
     558:	91 e0       	ldi	r25, 0x01	; 1
     55a:	91 83       	std	Z+1, r25	; 0x01
     55c:	80 83       	st	Z, r24
     55e:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
     562:	0f 90       	pop	r0
     564:	0f 90       	pop	r0
     566:	14 c0       	rjmp	.+40     	; 0x590 <main+0x23a>
					
					break;
					
					case SAVE:
						lcd_gotoxy(0,0);
     568:	80 e0       	ldi	r24, 0x00	; 0
     56a:	60 e0       	ldi	r22, 0x00	; 0
     56c:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
						lcd_puts("Save            \n                ");
     570:	80 ea       	ldi	r24, 0xA0	; 160
     572:	91 e0       	ldi	r25, 0x01	; 1
     574:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>
						
						
						printf("\n\n Save menu selected");
     578:	00 d0       	rcall	.+0      	; 0x57a <main+0x224>
     57a:	ed b7       	in	r30, 0x3d	; 61
     57c:	fe b7       	in	r31, 0x3e	; 62
     57e:	31 96       	adiw	r30, 0x01	; 1
     580:	82 ec       	ldi	r24, 0xC2	; 194
     582:	91 e0       	ldi	r25, 0x01	; 1
     584:	91 83       	std	Z+1, r25	; 0x01
     586:	80 83       	st	Z, r24
     588:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
     58c:	0f 90       	pop	r0
     58e:	0f 90       	pop	r0
					default :
					
					break;
				}
				
				wait_ms(100);
     590:	84 e6       	ldi	r24, 0x64	; 100
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	0e 94 6b 00 	call	0xd6	; 0xd6 <wait_ms>
				button_detect_3 = 0;
     598:	10 92 b0 05 	sts	0x05B0, r1
     59c:	08 c1       	rjmp	.+528    	; 0x7ae <main+0x458>
			}	
			else if (button_detect != 0)
     59e:	80 91 af 05 	lds	r24, 0x05AF
     5a2:	88 23       	and	r24, r24
     5a4:	09 f4       	brne	.+2      	; 0x5a8 <main+0x252>
     5a6:	03 c1       	rjmp	.+518    	; 0x7ae <main+0x458>
			{
				// so, we got a button interupt, let's do something

				
				switch(menu)
     5a8:	8e 81       	ldd	r24, Y+6	; 0x06
     5aa:	28 2f       	mov	r18, r24
     5ac:	30 e0       	ldi	r19, 0x00	; 0
     5ae:	22 96       	adiw	r28, 0x02	; 2
     5b0:	3f af       	std	Y+63, r19	; 0x3f
     5b2:	2e af       	std	Y+62, r18	; 0x3e
     5b4:	22 97       	sbiw	r28, 0x02	; 2
     5b6:	22 96       	adiw	r28, 0x02	; 2
     5b8:	8e ad       	ldd	r24, Y+62	; 0x3e
     5ba:	9f ad       	ldd	r25, Y+63	; 0x3f
     5bc:	22 97       	sbiw	r28, 0x02	; 2
     5be:	81 30       	cpi	r24, 0x01	; 1
     5c0:	91 05       	cpc	r25, r1
     5c2:	09 f4       	brne	.+2      	; 0x5c6 <main+0x270>
     5c4:	70 c0       	rjmp	.+224    	; 0x6a6 <main+0x350>
     5c6:	22 96       	adiw	r28, 0x02	; 2
     5c8:	2e ad       	ldd	r18, Y+62	; 0x3e
     5ca:	3f ad       	ldd	r19, Y+63	; 0x3f
     5cc:	22 97       	sbiw	r28, 0x02	; 2
     5ce:	22 30       	cpi	r18, 0x02	; 2
     5d0:	31 05       	cpc	r19, r1
     5d2:	41 f0       	breq	.+16     	; 0x5e4 <main+0x28e>
     5d4:	22 96       	adiw	r28, 0x02	; 2
     5d6:	8e ad       	ldd	r24, Y+62	; 0x3e
     5d8:	9f ad       	ldd	r25, Y+63	; 0x3f
     5da:	22 97       	sbiw	r28, 0x02	; 2
     5dc:	00 97       	sbiw	r24, 0x00	; 0
     5de:	09 f4       	brne	.+2      	; 0x5e2 <main+0x28c>
     5e0:	b7 c0       	rjmp	.+366    	; 0x750 <main+0x3fa>
     5e2:	df c0       	rjmp	.+446    	; 0x7a2 <main+0x44c>
				{
					case TUNE:
				
						if (button_detect == 1)
     5e4:	80 91 af 05 	lds	r24, 0x05AF
     5e8:	81 30       	cpi	r24, 0x01	; 1
     5ea:	39 f4       	brne	.+14     	; 0x5fa <main+0x2a4>
							readchan = execute('6', volume); // seek down
     5ec:	86 e3       	ldi	r24, 0x36	; 54
     5ee:	6d 81       	ldd	r22, Y+5	; 0x05
     5f0:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <execute>
     5f4:	9c 83       	std	Y+4, r25	; 0x04
     5f6:	8b 83       	std	Y+3, r24	; 0x03
     5f8:	0a c0       	rjmp	.+20     	; 0x60e <main+0x2b8>
						else if (button_detect == 2)
     5fa:	80 91 af 05 	lds	r24, 0x05AF
     5fe:	82 30       	cpi	r24, 0x02	; 2
     600:	31 f4       	brne	.+12     	; 0x60e <main+0x2b8>
							readchan = execute('5', volume); // seek up
     602:	85 e3       	ldi	r24, 0x35	; 53
     604:	6d 81       	ldd	r22, Y+5	; 0x05
     606:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <execute>
     60a:	9c 83       	std	Y+4, r25	; 0x04
     60c:	8b 83       	std	Y+3, r24	; 0x03
				
						// display new frequency
						lcd_gotoxy(0,0);
     60e:	80 e0       	ldi	r24, 0x00	; 0
     610:	60 e0       	ldi	r22, 0x00	; 0
     612:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
						tmp = (readchan + 690) / 10;
     616:	8b 81       	ldd	r24, Y+3	; 0x03
     618:	9c 81       	ldd	r25, Y+4	; 0x04
     61a:	8e 54       	subi	r24, 0x4E	; 78
     61c:	9d 4f       	sbci	r25, 0xFD	; 253
     61e:	2a e0       	ldi	r18, 0x0A	; 10
     620:	30 e0       	ldi	r19, 0x00	; 0
     622:	b9 01       	movw	r22, r18
     624:	0e 94 81 15 	call	0x2b02	; 0x2b02 <__udivmodhi4>
     628:	cb 01       	movw	r24, r22
     62a:	9a 83       	std	Y+2, r25	; 0x02
     62c:	89 83       	std	Y+1, r24	; 0x01
						sprintf(str, "Tuned: %d.%d MHz", tmp, (readchan + 690) - tmp*10);
     62e:	89 81       	ldd	r24, Y+1	; 0x01
     630:	9a 81       	ldd	r25, Y+2	; 0x02
     632:	9c 01       	movw	r18, r24
     634:	22 0f       	add	r18, r18
     636:	33 1f       	adc	r19, r19
     638:	c9 01       	movw	r24, r18
     63a:	88 0f       	add	r24, r24
     63c:	99 1f       	adc	r25, r25
     63e:	88 0f       	add	r24, r24
     640:	99 1f       	adc	r25, r25
     642:	28 0f       	add	r18, r24
     644:	39 1f       	adc	r19, r25
     646:	8b 81       	ldd	r24, Y+3	; 0x03
     648:	9c 81       	ldd	r25, Y+4	; 0x04
     64a:	82 1b       	sub	r24, r18
     64c:	93 0b       	sbc	r25, r19
     64e:	9c 01       	movw	r18, r24
     650:	2e 54       	subi	r18, 0x4E	; 78
     652:	3d 4f       	sbci	r19, 0xFD	; 253
     654:	8d b7       	in	r24, 0x3d	; 61
     656:	9e b7       	in	r25, 0x3e	; 62
     658:	08 97       	sbiw	r24, 0x08	; 8
     65a:	0f b6       	in	r0, 0x3f	; 63
     65c:	f8 94       	cli
     65e:	9e bf       	out	0x3e, r25	; 62
     660:	0f be       	out	0x3f, r0	; 63
     662:	8d bf       	out	0x3d, r24	; 61
     664:	ed b7       	in	r30, 0x3d	; 61
     666:	fe b7       	in	r31, 0x3e	; 62
     668:	31 96       	adiw	r30, 0x01	; 1
     66a:	ce 01       	movw	r24, r28
     66c:	c0 96       	adiw	r24, 0x30	; 48
     66e:	91 83       	std	Z+1, r25	; 0x01
     670:	80 83       	st	Z, r24
     672:	88 ed       	ldi	r24, 0xD8	; 216
     674:	91 e0       	ldi	r25, 0x01	; 1
     676:	93 83       	std	Z+3, r25	; 0x03
     678:	82 83       	std	Z+2, r24	; 0x02
     67a:	89 81       	ldd	r24, Y+1	; 0x01
     67c:	9a 81       	ldd	r25, Y+2	; 0x02
     67e:	95 83       	std	Z+5, r25	; 0x05
     680:	84 83       	std	Z+4, r24	; 0x04
     682:	37 83       	std	Z+7, r19	; 0x07
     684:	26 83       	std	Z+6, r18	; 0x06
     686:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <sprintf>
     68a:	2d b7       	in	r18, 0x3d	; 61
     68c:	3e b7       	in	r19, 0x3e	; 62
     68e:	28 5f       	subi	r18, 0xF8	; 248
     690:	3f 4f       	sbci	r19, 0xFF	; 255
     692:	0f b6       	in	r0, 0x3f	; 63
     694:	f8 94       	cli
     696:	3e bf       	out	0x3e, r19	; 62
     698:	0f be       	out	0x3f, r0	; 63
     69a:	2d bf       	out	0x3d, r18	; 61
						lcd_puts(str);
     69c:	ce 01       	movw	r24, r28
     69e:	c0 96       	adiw	r24, 0x30	; 48
     6a0:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>
     6a4:	7e c0       	rjmp	.+252    	; 0x7a2 <main+0x44c>
						
					break;
					
					case VOL:
						if (button_detect == 1)
     6a6:	80 91 af 05 	lds	r24, 0x05AF
     6aa:	81 30       	cpi	r24, 0x01	; 1
     6ac:	d1 f4       	brne	.+52     	; 0x6e2 <main+0x38c>
						{
							printf("\nV down fr %i", volume);
     6ae:	8d 81       	ldd	r24, Y+5	; 0x05
     6b0:	28 2f       	mov	r18, r24
     6b2:	30 e0       	ldi	r19, 0x00	; 0
     6b4:	00 d0       	rcall	.+0      	; 0x6b6 <main+0x360>
     6b6:	00 d0       	rcall	.+0      	; 0x6b8 <main+0x362>
     6b8:	ed b7       	in	r30, 0x3d	; 61
     6ba:	fe b7       	in	r31, 0x3e	; 62
     6bc:	31 96       	adiw	r30, 0x01	; 1
     6be:	89 ee       	ldi	r24, 0xE9	; 233
     6c0:	91 e0       	ldi	r25, 0x01	; 1
     6c2:	91 83       	std	Z+1, r25	; 0x01
     6c4:	80 83       	st	Z, r24
     6c6:	33 83       	std	Z+3, r19	; 0x03
     6c8:	22 83       	std	Z+2, r18	; 0x02
     6ca:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
     6ce:	0f 90       	pop	r0
     6d0:	0f 90       	pop	r0
     6d2:	0f 90       	pop	r0
     6d4:	0f 90       	pop	r0
							volume = (BYTE) execute('9', volume); // volume down
     6d6:	89 e3       	ldi	r24, 0x39	; 57
     6d8:	6d 81       	ldd	r22, Y+5	; 0x05
     6da:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <execute>
     6de:	8d 83       	std	Y+5, r24	; 0x05
     6e0:	1d c0       	rjmp	.+58     	; 0x71c <main+0x3c6>
						}
						else if (button_detect == 2)
     6e2:	80 91 af 05 	lds	r24, 0x05AF
     6e6:	82 30       	cpi	r24, 0x02	; 2
     6e8:	c9 f4       	brne	.+50     	; 0x71c <main+0x3c6>
						{
							printf("\nV up fr %i", volume);
     6ea:	8d 81       	ldd	r24, Y+5	; 0x05
     6ec:	28 2f       	mov	r18, r24
     6ee:	30 e0       	ldi	r19, 0x00	; 0
     6f0:	00 d0       	rcall	.+0      	; 0x6f2 <main+0x39c>
     6f2:	00 d0       	rcall	.+0      	; 0x6f4 <main+0x39e>
     6f4:	ed b7       	in	r30, 0x3d	; 61
     6f6:	fe b7       	in	r31, 0x3e	; 62
     6f8:	31 96       	adiw	r30, 0x01	; 1
     6fa:	87 ef       	ldi	r24, 0xF7	; 247
     6fc:	91 e0       	ldi	r25, 0x01	; 1
     6fe:	91 83       	std	Z+1, r25	; 0x01
     700:	80 83       	st	Z, r24
     702:	33 83       	std	Z+3, r19	; 0x03
     704:	22 83       	std	Z+2, r18	; 0x02
     706:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
     70a:	0f 90       	pop	r0
     70c:	0f 90       	pop	r0
     70e:	0f 90       	pop	r0
     710:	0f 90       	pop	r0
							volume = (BYTE) execute('8', volume); // volume up
     712:	88 e3       	ldi	r24, 0x38	; 56
     714:	6d 81       	ldd	r22, Y+5	; 0x05
     716:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <execute>
     71a:	8d 83       	std	Y+5, r24	; 0x05
						}
						
						lcd_gotoxy(0,0);
     71c:	80 e0       	ldi	r24, 0x00	; 0
     71e:	60 e0       	ldi	r22, 0x00	; 0
     720:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
						lcd_puts("Volume          \n                ");
     724:	84 e6       	ldi	r24, 0x64	; 100
     726:	91 e0       	ldi	r25, 0x01	; 1
     728:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>
						
						lcd_gotoxy(0,1);
     72c:	80 e0       	ldi	r24, 0x00	; 0
     72e:	61 e0       	ldi	r22, 0x01	; 1
     730:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
						
						for (i = 0; i < volume; i++)
     734:	1f 82       	std	Y+7, r1	; 0x07
     736:	07 c0       	rjmp	.+14     	; 0x746 <main+0x3f0>
							lcd_puts(">"); // draws the volume bar
     738:	86 e8       	ldi	r24, 0x86	; 134
     73a:	91 e0       	ldi	r25, 0x01	; 1
     73c:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>
						lcd_gotoxy(0,0);
						lcd_puts("Volume          \n                ");
						
						lcd_gotoxy(0,1);
						
						for (i = 0; i < volume; i++)
     740:	8f 81       	ldd	r24, Y+7	; 0x07
     742:	8f 5f       	subi	r24, 0xFF	; 255
     744:	8f 83       	std	Y+7, r24	; 0x07
     746:	9f 81       	ldd	r25, Y+7	; 0x07
     748:	8d 81       	ldd	r24, Y+5	; 0x05
     74a:	98 17       	cp	r25, r24
     74c:	a8 f3       	brcs	.-22     	; 0x738 <main+0x3e2>
     74e:	29 c0       	rjmp	.+82     	; 0x7a2 <main+0x44c>
							lcd_puts(">"); // draws the volume bar
					
					break;

					case SAVE:
						if (button_detect == 1)
     750:	80 91 af 05 	lds	r24, 0x05AF
     754:	81 30       	cpi	r24, 0x01	; 1
     756:	69 f4       	brne	.+26     	; 0x772 <main+0x41c>
						{
							printf("\nSave down");
     758:	00 d0       	rcall	.+0      	; 0x75a <main+0x404>
     75a:	ed b7       	in	r30, 0x3d	; 61
     75c:	fe b7       	in	r31, 0x3e	; 62
     75e:	31 96       	adiw	r30, 0x01	; 1
     760:	83 e0       	ldi	r24, 0x03	; 3
     762:	92 e0       	ldi	r25, 0x02	; 2
     764:	91 83       	std	Z+1, r25	; 0x01
     766:	80 83       	st	Z, r24
     768:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
     76c:	0f 90       	pop	r0
     76e:	0f 90       	pop	r0
     770:	10 c0       	rjmp	.+32     	; 0x792 <main+0x43c>
							
						}
						else if (button_detect == 2)
     772:	80 91 af 05 	lds	r24, 0x05AF
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f4       	brne	.+24     	; 0x792 <main+0x43c>
						{
							printf("\nSave up");
     77a:	00 d0       	rcall	.+0      	; 0x77c <main+0x426>
     77c:	ed b7       	in	r30, 0x3d	; 61
     77e:	fe b7       	in	r31, 0x3e	; 62
     780:	31 96       	adiw	r30, 0x01	; 1
     782:	8e e0       	ldi	r24, 0x0E	; 14
     784:	92 e0       	ldi	r25, 0x02	; 2
     786:	91 83       	std	Z+1, r25	; 0x01
     788:	80 83       	st	Z, r24
     78a:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
     78e:	0f 90       	pop	r0
     790:	0f 90       	pop	r0
							
						}
						
						lcd_gotoxy(0,0);
     792:	80 e0       	ldi	r24, 0x00	; 0
     794:	60 e0       	ldi	r22, 0x00	; 0
     796:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
						lcd_puts("Save            \n                ");
     79a:	80 ea       	ldi	r24, 0xA0	; 160
     79c:	91 e0       	ldi	r25, 0x01	; 1
     79e:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>
						
					break;
				}

				
				button_detect = 0;
     7a2:	10 92 af 05 	sts	0x05AF, r1
				wait_ms(100); 		// wait for pushbutton bouncing to ripple out
     7a6:	84 e6       	ldi	r24, 0x64	; 100
     7a8:	90 e0       	ldi	r25, 0x00	; 0
     7aa:	0e 94 6b 00 	call	0xd6	; 0xd6 <wait_ms>
			}
			


			timer_tick_detect = 0;			/* Clear the flag		*/
     7ae:	10 92 b1 05 	sts	0x05B1, r1
     7b2:	fe cd       	rjmp	.-1028   	; 0x3b0 <main+0x5a>

000007b4 <Init_TWI>:
	Baudrate 	: 100kHz @ 4MHz system clock
	Own address : OWN_ADR (Defined in TWI_driver.h)
****************************************************************************/

char Init_TWI(void)
{
     7b4:	df 93       	push	r29
     7b6:	cf 93       	push	r28
     7b8:	cd b7       	in	r28, 0x3d	; 61
     7ba:	de b7       	in	r29, 0x3e	; 62
	TWAR = OWN_ADR;					//Set own slave address
     7bc:	ea eb       	ldi	r30, 0xBA	; 186
     7be:	f0 e0       	ldi	r31, 0x00	; 0
     7c0:	8c e3       	ldi	r24, 0x3C	; 60
     7c2:	80 83       	st	Z, r24
	TWBR = 32;                    	//Set baud-rate to 100 KHz at 
     7c4:	e8 eb       	ldi	r30, 0xB8	; 184
     7c6:	f0 e0       	ldi	r31, 0x00	; 0
     7c8:	80 e2       	ldi	r24, 0x20	; 32
     7ca:	80 83       	st	Z, r24
									//8 MHz xtal
	TWCR = 1<<TWEN;					//Enable TWI-interface
     7cc:	ec eb       	ldi	r30, 0xBC	; 188
     7ce:	f0 e0       	ldi	r31, 0x00	; 0
     7d0:	84 e0       	ldi	r24, 0x04	; 4
     7d2:	80 83       	st	Z, r24

    return 1;
     7d4:	81 e0       	ldi	r24, 0x01	; 1
}    
     7d6:	cf 91       	pop	r28
     7d8:	df 91       	pop	r29
     7da:	08 95       	ret

000007dc <Wait_TWI_int>:
/****************************************************************************
	Function : void Wait_TWI_int(void)
	Loop until TWI interrupt flag is set
****************************************************************************/
void Wait_TWI_int(void)
{
     7dc:	df 93       	push	r29
     7de:	cf 93       	push	r28
     7e0:	cd b7       	in	r28, 0x3d	; 61
     7e2:	de b7       	in	r29, 0x3e	; 62
	while (!(TWCR & 1<<TWINT)); 
     7e4:	ec eb       	ldi	r30, 0xBC	; 188
     7e6:	f0 e0       	ldi	r31, 0x00	; 0
     7e8:	80 81       	ld	r24, Z
     7ea:	88 23       	and	r24, r24
     7ec:	dc f7       	brge	.-10     	; 0x7e4 <Wait_TWI_int+0x8>
}    
     7ee:	cf 91       	pop	r28
     7f0:	df 91       	pop	r29
     7f2:	08 95       	ret

000007f4 <Send_start>:
	Send a START condition to the bus and wait for the TWINT get set set to 
	see the result. If it failed return the TWSR value, if success return 
	SUCCESS.
****************************************************************************/
unsigned char	Send_start(void)
{
     7f4:	df 93       	push	r29
     7f6:	cf 93       	push	r28
     7f8:	0f 92       	push	r0
     7fa:	cd b7       	in	r28, 0x3d	; 61
     7fc:	de b7       	in	r29, 0x3e	; 62
	TWCR = (1<<TWINT | 1<<TWSTA | 1<<TWEN);			//Send START
     7fe:	ec eb       	ldi	r30, 0xBC	; 188
     800:	f0 e0       	ldi	r31, 0x00	; 0
     802:	84 ea       	ldi	r24, 0xA4	; 164
     804:	80 83       	st	Z, r24
	
	Wait_TWI_int();						//Wait for TWI interrupt flag set
     806:	0e 94 ee 03 	call	0x7dc	; 0x7dc <Wait_TWI_int>

    if((TWSR != START)&&(TWSR != REP_START))		//If status other than START 
     80a:	e9 eb       	ldi	r30, 0xB9	; 185
     80c:	f0 e0       	ldi	r31, 0x00	; 0
     80e:	80 81       	ld	r24, Z
     810:	88 30       	cpi	r24, 0x08	; 8
     812:	51 f0       	breq	.+20     	; 0x828 <Send_start+0x34>
     814:	e9 eb       	ldi	r30, 0xB9	; 185
     816:	f0 e0       	ldi	r31, 0x00	; 0
     818:	80 81       	ld	r24, Z
     81a:	80 31       	cpi	r24, 0x10	; 16
     81c:	29 f0       	breq	.+10     	; 0x828 <Send_start+0x34>
		return TWSR;					//transmitted(0x08) or Repeated
     81e:	e9 eb       	ldi	r30, 0xB9	; 185
     820:	f0 e0       	ldi	r31, 0x00	; 0
     822:	80 81       	ld	r24, Z
     824:	89 83       	std	Y+1, r24	; 0x01
     826:	02 c0       	rjmp	.+4      	; 0x82c <Send_start+0x38>
	return SUCCESS;						//START transmitted(0x10) 
     828:	8f ef       	ldi	r24, 0xFF	; 255
     82a:	89 83       	std	Y+1, r24	; 0x01
     82c:	89 81       	ldd	r24, Y+1	; 0x01
    									//-> error  and return TWSR.
    									//If success return	SUCCESS
}							
     82e:	0f 90       	pop	r0
     830:	cf 91       	pop	r28
     832:	df 91       	pop	r29
     834:	08 95       	ret

00000836 <Send_stop>:
/****************************************************************************
	Function :
	Send a STOP condition to the bus
****************************************************************************/
void Send_stop(void)
{
     836:	df 93       	push	r29
     838:	cf 93       	push	r28
     83a:	cd b7       	in	r28, 0x3d	; 61
     83c:	de b7       	in	r29, 0x3e	; 62
	TWCR = (1<<TWEN | 1<<TWINT | 1<<TWSTO)				;//Send STOP condition
     83e:	ec eb       	ldi	r30, 0xBC	; 188
     840:	f0 e0       	ldi	r31, 0x00	; 0
     842:	84 e9       	ldi	r24, 0x94	; 148
     844:	80 83       	st	Z, r24
}        
     846:	cf 91       	pop	r28
     848:	df 91       	pop	r29
     84a:	08 95       	ret

0000084c <Send_to_TWI>:
/****************************************************************************
	Function : unsigned char Send_to_TWI(tx_type *data_pack)
	Main TWI communication function. Handles all signaling against the bus.
****************************************************************************/
unsigned char Send_to_TWI(tx_type *data_pack)
{
     84c:	df 93       	push	r29
     84e:	cf 93       	push	r28
     850:	00 d0       	rcall	.+0      	; 0x852 <Send_to_TWI+0x6>
     852:	00 d0       	rcall	.+0      	; 0x854 <Send_to_TWI+0x8>
     854:	0f 92       	push	r0
     856:	cd b7       	in	r28, 0x3d	; 61
     858:	de b7       	in	r29, 0x3e	; 62
     85a:	9d 83       	std	Y+5, r25	; 0x05
     85c:	8c 83       	std	Y+4, r24	; 0x04
	unsigned char state,i,j;

	//cli();		// disallow interrupts during Xmit
	state = SUCCESS;
     85e:	8f ef       	ldi	r24, 0xFF	; 255
     860:	8b 83       	std	Y+3, r24	; 0x03
	
	
	for(i=0;(data_pack[i].slave_adr != OWN_ADR)&&(state == SUCCESS);i++)
     862:	1a 82       	std	Y+2, r1	; 0x02
     864:	93 c0       	rjmp	.+294    	; 0x98c <Send_to_TWI+0x140>
	{
		state = Send_start();				//Send START and repeated START
     866:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <Send_start>
     86a:	8b 83       	std	Y+3, r24	; 0x03
		if (state == SUCCESS)				
     86c:	8b 81       	ldd	r24, Y+3	; 0x03
     86e:	8f 3f       	cpi	r24, 0xFF	; 255
     870:	89 f4       	brne	.+34     	; 0x894 <Send_to_TWI+0x48>
			state = Send_adr(data_pack[i].slave_adr);//Send slave address+W/R
     872:	8a 81       	ldd	r24, Y+2	; 0x02
     874:	88 2f       	mov	r24, r24
     876:	90 e0       	ldi	r25, 0x00	; 0
     878:	9c 01       	movw	r18, r24
     87a:	22 0f       	add	r18, r18
     87c:	33 1f       	adc	r19, r19
     87e:	22 0f       	add	r18, r18
     880:	33 1f       	adc	r19, r19
     882:	8c 81       	ldd	r24, Y+4	; 0x04
     884:	9d 81       	ldd	r25, Y+5	; 0x05
     886:	fc 01       	movw	r30, r24
     888:	e2 0f       	add	r30, r18
     88a:	f3 1f       	adc	r31, r19
     88c:	80 81       	ld	r24, Z
     88e:	0e 94 09 05 	call	0xa12	; 0xa12 <Send_adr>
     892:	8b 83       	std	Y+3, r24	; 0x03
		
		/*Dependent on the R/W in the slave address it will receive or 
		transmitt data.*/
		if(!(data_pack[i].slave_adr & Read))
     894:	8a 81       	ldd	r24, Y+2	; 0x02
     896:	88 2f       	mov	r24, r24
     898:	90 e0       	ldi	r25, 0x00	; 0
     89a:	9c 01       	movw	r18, r24
     89c:	22 0f       	add	r18, r18
     89e:	33 1f       	adc	r19, r19
     8a0:	22 0f       	add	r18, r18
     8a2:	33 1f       	adc	r19, r19
     8a4:	8c 81       	ldd	r24, Y+4	; 0x04
     8a6:	9d 81       	ldd	r25, Y+5	; 0x05
     8a8:	fc 01       	movw	r30, r24
     8aa:	e2 0f       	add	r30, r18
     8ac:	f3 1f       	adc	r31, r19
     8ae:	80 81       	ld	r24, Z
     8b0:	88 2f       	mov	r24, r24
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	81 70       	andi	r24, 0x01	; 1
     8b6:	90 70       	andi	r25, 0x00	; 0
     8b8:	00 97       	sbiw	r24, 0x00	; 0
     8ba:	99 f5       	brne	.+102    	; 0x922 <Send_to_TWI+0xd6>
		{
			/*If W, it will transmitt data and loops until all data have been
			 shifted out*/
			for(j=0;((j<data_pack[i].size)&&(state == SUCCESS));j++)
     8bc:	19 82       	std	Y+1, r1	; 0x01
     8be:	1c c0       	rjmp	.+56     	; 0x8f8 <Send_to_TWI+0xac>
				state = Send_byte(data_pack[i].data_ptr[j]);
     8c0:	8a 81       	ldd	r24, Y+2	; 0x02
     8c2:	88 2f       	mov	r24, r24
     8c4:	90 e0       	ldi	r25, 0x00	; 0
     8c6:	9c 01       	movw	r18, r24
     8c8:	22 0f       	add	r18, r18
     8ca:	33 1f       	adc	r19, r19
     8cc:	22 0f       	add	r18, r18
     8ce:	33 1f       	adc	r19, r19
     8d0:	8c 81       	ldd	r24, Y+4	; 0x04
     8d2:	9d 81       	ldd	r25, Y+5	; 0x05
     8d4:	fc 01       	movw	r30, r24
     8d6:	e2 0f       	add	r30, r18
     8d8:	f3 1f       	adc	r31, r19
     8da:	22 81       	ldd	r18, Z+2	; 0x02
     8dc:	33 81       	ldd	r19, Z+3	; 0x03
     8de:	89 81       	ldd	r24, Y+1	; 0x01
     8e0:	88 2f       	mov	r24, r24
     8e2:	90 e0       	ldi	r25, 0x00	; 0
     8e4:	f9 01       	movw	r30, r18
     8e6:	e8 0f       	add	r30, r24
     8e8:	f9 1f       	adc	r31, r25
     8ea:	80 81       	ld	r24, Z
     8ec:	0e 94 e5 04 	call	0x9ca	; 0x9ca <Send_byte>
     8f0:	8b 83       	std	Y+3, r24	; 0x03
		transmitt data.*/
		if(!(data_pack[i].slave_adr & Read))
		{
			/*If W, it will transmitt data and loops until all data have been
			 shifted out*/
			for(j=0;((j<data_pack[i].size)&&(state == SUCCESS));j++)
     8f2:	89 81       	ldd	r24, Y+1	; 0x01
     8f4:	8f 5f       	subi	r24, 0xFF	; 255
     8f6:	89 83       	std	Y+1, r24	; 0x01
     8f8:	8a 81       	ldd	r24, Y+2	; 0x02
     8fa:	88 2f       	mov	r24, r24
     8fc:	90 e0       	ldi	r25, 0x00	; 0
     8fe:	9c 01       	movw	r18, r24
     900:	22 0f       	add	r18, r18
     902:	33 1f       	adc	r19, r19
     904:	22 0f       	add	r18, r18
     906:	33 1f       	adc	r19, r19
     908:	8c 81       	ldd	r24, Y+4	; 0x04
     90a:	9d 81       	ldd	r25, Y+5	; 0x05
     90c:	fc 01       	movw	r30, r24
     90e:	e2 0f       	add	r30, r18
     910:	f3 1f       	adc	r31, r19
     912:	91 81       	ldd	r25, Z+1	; 0x01
     914:	89 81       	ldd	r24, Y+1	; 0x01
     916:	89 17       	cp	r24, r25
     918:	b0 f5       	brcc	.+108    	; 0x986 <Send_to_TWI+0x13a>
     91a:	8b 81       	ldd	r24, Y+3	; 0x03
     91c:	8f 3f       	cpi	r24, 0xFF	; 255
     91e:	81 f2       	breq	.-96     	; 0x8c0 <Send_to_TWI+0x74>
     920:	32 c0       	rjmp	.+100    	; 0x986 <Send_to_TWI+0x13a>
			/*If R, it will receive data and loops until all data have been
			 shifted in. When j == 0x00 this is the last byte and a NACK 
			 will be sent to the slave to make it stop transmitting */
//			for(j=0;((j<data_pack[i].size)&&(state == SUCCESS));j++)
//				state = Get_byte(data_pack[i].data_ptr++,j);
			for(j=data_pack[i].size-1;(j!=0xFF&&(state == SUCCESS));j--)
     922:	8a 81       	ldd	r24, Y+2	; 0x02
     924:	88 2f       	mov	r24, r24
     926:	90 e0       	ldi	r25, 0x00	; 0
     928:	9c 01       	movw	r18, r24
     92a:	22 0f       	add	r18, r18
     92c:	33 1f       	adc	r19, r19
     92e:	22 0f       	add	r18, r18
     930:	33 1f       	adc	r19, r19
     932:	8c 81       	ldd	r24, Y+4	; 0x04
     934:	9d 81       	ldd	r25, Y+5	; 0x05
     936:	fc 01       	movw	r30, r24
     938:	e2 0f       	add	r30, r18
     93a:	f3 1f       	adc	r31, r19
     93c:	81 81       	ldd	r24, Z+1	; 0x01
     93e:	81 50       	subi	r24, 0x01	; 1
     940:	89 83       	std	Y+1, r24	; 0x01
     942:	1b c0       	rjmp	.+54     	; 0x97a <Send_to_TWI+0x12e>
				state = Get_byte(data_pack[i].data_ptr++,j);
     944:	8a 81       	ldd	r24, Y+2	; 0x02
     946:	88 2f       	mov	r24, r24
     948:	90 e0       	ldi	r25, 0x00	; 0
     94a:	9c 01       	movw	r18, r24
     94c:	22 0f       	add	r18, r18
     94e:	33 1f       	adc	r19, r19
     950:	22 0f       	add	r18, r18
     952:	33 1f       	adc	r19, r19
     954:	8c 81       	ldd	r24, Y+4	; 0x04
     956:	9d 81       	ldd	r25, Y+5	; 0x05
     958:	fc 01       	movw	r30, r24
     95a:	e2 0f       	add	r30, r18
     95c:	f3 1f       	adc	r31, r19
     95e:	82 81       	ldd	r24, Z+2	; 0x02
     960:	93 81       	ldd	r25, Z+3	; 0x03
     962:	9c 01       	movw	r18, r24
     964:	01 96       	adiw	r24, 0x01	; 1
     966:	93 83       	std	Z+3, r25	; 0x03
     968:	82 83       	std	Z+2, r24	; 0x02
     96a:	c9 01       	movw	r24, r18
     96c:	69 81       	ldd	r22, Y+1	; 0x01
     96e:	0e 94 32 05 	call	0xa64	; 0xa64 <Get_byte>
     972:	8b 83       	std	Y+3, r24	; 0x03
			/*If R, it will receive data and loops until all data have been
			 shifted in. When j == 0x00 this is the last byte and a NACK 
			 will be sent to the slave to make it stop transmitting */
//			for(j=0;((j<data_pack[i].size)&&(state == SUCCESS));j++)
//				state = Get_byte(data_pack[i].data_ptr++,j);
			for(j=data_pack[i].size-1;(j!=0xFF&&(state == SUCCESS));j--)
     974:	89 81       	ldd	r24, Y+1	; 0x01
     976:	81 50       	subi	r24, 0x01	; 1
     978:	89 83       	std	Y+1, r24	; 0x01
     97a:	89 81       	ldd	r24, Y+1	; 0x01
     97c:	8f 3f       	cpi	r24, 0xFF	; 255
     97e:	19 f0       	breq	.+6      	; 0x986 <Send_to_TWI+0x13a>
     980:	8b 81       	ldd	r24, Y+3	; 0x03
     982:	8f 3f       	cpi	r24, 0xFF	; 255
     984:	f9 f2       	breq	.-66     	; 0x944 <Send_to_TWI+0xf8>

	//cli();		// disallow interrupts during Xmit
	state = SUCCESS;
	
	
	for(i=0;(data_pack[i].slave_adr != OWN_ADR)&&(state == SUCCESS);i++)
     986:	8a 81       	ldd	r24, Y+2	; 0x02
     988:	8f 5f       	subi	r24, 0xFF	; 255
     98a:	8a 83       	std	Y+2, r24	; 0x02
     98c:	8a 81       	ldd	r24, Y+2	; 0x02
     98e:	88 2f       	mov	r24, r24
     990:	90 e0       	ldi	r25, 0x00	; 0
     992:	9c 01       	movw	r18, r24
     994:	22 0f       	add	r18, r18
     996:	33 1f       	adc	r19, r19
     998:	22 0f       	add	r18, r18
     99a:	33 1f       	adc	r19, r19
     99c:	8c 81       	ldd	r24, Y+4	; 0x04
     99e:	9d 81       	ldd	r25, Y+5	; 0x05
     9a0:	fc 01       	movw	r30, r24
     9a2:	e2 0f       	add	r30, r18
     9a4:	f3 1f       	adc	r31, r19
     9a6:	80 81       	ld	r24, Z
     9a8:	8c 33       	cpi	r24, 0x3C	; 60
     9aa:	21 f0       	breq	.+8      	; 0x9b4 <Send_to_TWI+0x168>
     9ac:	8b 81       	ldd	r24, Y+3	; 0x03
     9ae:	8f 3f       	cpi	r24, 0xFF	; 255
     9b0:	09 f4       	brne	.+2      	; 0x9b4 <Send_to_TWI+0x168>
     9b2:	59 cf       	rjmp	.-334    	; 0x866 <Send_to_TWI+0x1a>
//				state = Get_byte(data_pack[i].data_ptr++,j);
			for(j=data_pack[i].size-1;(j!=0xFF&&(state == SUCCESS));j--)
				state = Get_byte(data_pack[i].data_ptr++,j);
		}					
	}
  	Send_stop();				//Send STOP
     9b4:	0e 94 1b 04 	call	0x836	; 0x836 <Send_stop>
  	//sei();		// enable interrupts 
	return state;				//Return SUCCESS if OK, else return TWSR 
     9b8:	8b 81       	ldd	r24, Y+3	; 0x03
}
     9ba:	0f 90       	pop	r0
     9bc:	0f 90       	pop	r0
     9be:	0f 90       	pop	r0
     9c0:	0f 90       	pop	r0
     9c2:	0f 90       	pop	r0
     9c4:	cf 91       	pop	r28
     9c6:	df 91       	pop	r29
     9c8:	08 95       	ret

000009ca <Send_byte>:
/****************************************************************************
	Function : unsigned char Send_byte(unsigned char data)
	Send one byte to the bus.
****************************************************************************/
unsigned char Send_byte(unsigned char data)
{
     9ca:	df 93       	push	r29
     9cc:	cf 93       	push	r28
     9ce:	00 d0       	rcall	.+0      	; 0x9d0 <Send_byte+0x6>
     9d0:	cd b7       	in	r28, 0x3d	; 61
     9d2:	de b7       	in	r29, 0x3e	; 62
     9d4:	89 83       	std	Y+1, r24	; 0x01
	Wait_TWI_int();				//Wait for TWI interrupt flag set
     9d6:	0e 94 ee 03 	call	0x7dc	; 0x7dc <Wait_TWI_int>

	TWDR = data;
     9da:	eb eb       	ldi	r30, 0xBB	; 187
     9dc:	f0 e0       	ldi	r31, 0x00	; 0
     9de:	89 81       	ldd	r24, Y+1	; 0x01
     9e0:	80 83       	st	Z, r24
 	TWCR = (1<<TWINT | 1<<TWEN);   		//Clear int flag to send byte 
     9e2:	ec eb       	ldi	r30, 0xBC	; 188
     9e4:	f0 e0       	ldi	r31, 0x00	; 0
     9e6:	84 e8       	ldi	r24, 0x84	; 132
     9e8:	80 83       	st	Z, r24

	Wait_TWI_int();				//Wait for TWI interrupt flag set
     9ea:	0e 94 ee 03 	call	0x7dc	; 0x7dc <Wait_TWI_int>

	if(TWSR != MTX_DATA_ACK)		//If NACK received return TWSR
     9ee:	e9 eb       	ldi	r30, 0xB9	; 185
     9f0:	f0 e0       	ldi	r31, 0x00	; 0
     9f2:	80 81       	ld	r24, Z
     9f4:	88 32       	cpi	r24, 0x28	; 40
     9f6:	29 f0       	breq	.+10     	; 0xa02 <Send_byte+0x38>
		return TWSR;																
     9f8:	e9 eb       	ldi	r30, 0xB9	; 185
     9fa:	f0 e0       	ldi	r31, 0x00	; 0
     9fc:	80 81       	ld	r24, Z
     9fe:	8a 83       	std	Y+2, r24	; 0x02
     a00:	02 c0       	rjmp	.+4      	; 0xa06 <Send_byte+0x3c>
	return SUCCESS;				//Else return SUCCESS
     a02:	8f ef       	ldi	r24, 0xFF	; 255
     a04:	8a 83       	std	Y+2, r24	; 0x02
     a06:	8a 81       	ldd	r24, Y+2	; 0x02
}	
     a08:	0f 90       	pop	r0
     a0a:	0f 90       	pop	r0
     a0c:	cf 91       	pop	r28
     a0e:	df 91       	pop	r29
     a10:	08 95       	ret

00000a12 <Send_adr>:
/****************************************************************************
	Function : unsigned char Send_adr(unsigned char adr)							
	Send a SLA+W/R to the bus
****************************************************************************/
unsigned char Send_adr(unsigned char adr)
{
     a12:	df 93       	push	r29
     a14:	cf 93       	push	r28
     a16:	00 d0       	rcall	.+0      	; 0xa18 <Send_adr+0x6>
     a18:	cd b7       	in	r28, 0x3d	; 61
     a1a:	de b7       	in	r29, 0x3e	; 62
     a1c:	89 83       	std	Y+1, r24	; 0x01
	Wait_TWI_int();					//Wait for TWI interrupt flag set
     a1e:	0e 94 ee 03 	call	0x7dc	; 0x7dc <Wait_TWI_int>

	TWDR = adr;
     a22:	eb eb       	ldi	r30, 0xBB	; 187
     a24:	f0 e0       	ldi	r31, 0x00	; 0
     a26:	89 81       	ldd	r24, Y+1	; 0x01
     a28:	80 83       	st	Z, r24
	TWCR = ((1<<TWINT)+(1<<TWEN));   		//Clear int flag to send byte 
     a2a:	ec eb       	ldi	r30, 0xBC	; 188
     a2c:	f0 e0       	ldi	r31, 0x00	; 0
     a2e:	84 e8       	ldi	r24, 0x84	; 132
     a30:	80 83       	st	Z, r24

	Wait_TWI_int();					//Wait for TWI interrupt flag set
     a32:	0e 94 ee 03 	call	0x7dc	; 0x7dc <Wait_TWI_int>

	if((TWSR != MTX_ADR_ACK)&&(TWSR != MRX_ADR_ACK))	//If NACK received return
     a36:	e9 eb       	ldi	r30, 0xB9	; 185
     a38:	f0 e0       	ldi	r31, 0x00	; 0
     a3a:	80 81       	ld	r24, Z
     a3c:	88 31       	cpi	r24, 0x18	; 24
     a3e:	51 f0       	breq	.+20     	; 0xa54 <Send_adr+0x42>
     a40:	e9 eb       	ldi	r30, 0xB9	; 185
     a42:	f0 e0       	ldi	r31, 0x00	; 0
     a44:	80 81       	ld	r24, Z
     a46:	80 34       	cpi	r24, 0x40	; 64
     a48:	29 f0       	breq	.+10     	; 0xa54 <Send_adr+0x42>
										//TWSR
		return TWSR;
     a4a:	e9 eb       	ldi	r30, 0xB9	; 185
     a4c:	f0 e0       	ldi	r31, 0x00	; 0
     a4e:	80 81       	ld	r24, Z
     a50:	8a 83       	std	Y+2, r24	; 0x02
     a52:	02 c0       	rjmp	.+4      	; 0xa58 <Send_adr+0x46>

	return SUCCESS;							//Else return SUCCESS
     a54:	8f ef       	ldi	r24, 0xFF	; 255
     a56:	8a 83       	std	Y+2, r24	; 0x02
     a58:	8a 81       	ldd	r24, Y+2	; 0x02
}	
     a5a:	0f 90       	pop	r0
     a5c:	0f 90       	pop	r0
     a5e:	cf 91       	pop	r28
     a60:	df 91       	pop	r29
     a62:	08 95       	ret

00000a64 <Get_byte>:
	Wait for TWINT to receive one byte from the slave and send ACK. If this 
	is the last byte the master will send NACK to tell the slave that it 
	shall stop transmitting.  
****************************************************************************/
unsigned char Get_byte(unsigned char *rx_ptr,char last_byte)
{
     a64:	df 93       	push	r29
     a66:	cf 93       	push	r28
     a68:	00 d0       	rcall	.+0      	; 0xa6a <Get_byte+0x6>
     a6a:	00 d0       	rcall	.+0      	; 0xa6c <Get_byte+0x8>
     a6c:	cd b7       	in	r28, 0x3d	; 61
     a6e:	de b7       	in	r29, 0x3e	; 62
     a70:	9a 83       	std	Y+2, r25	; 0x02
     a72:	89 83       	std	Y+1, r24	; 0x01
     a74:	6b 83       	std	Y+3, r22	; 0x03
	Wait_TWI_int();							//Wait for TWI interrupt flag set
     a76:	0e 94 ee 03 	call	0x7dc	; 0x7dc <Wait_TWI_int>

	/*When receiving the last byte from the slave it will be sent a NACK to 
	make the slave stop transmitting, all bits before the last will get 
	an ACK*/
	if(last_byte)							//Not the last byte
     a7a:	8b 81       	ldd	r24, Y+3	; 0x03
     a7c:	88 23       	and	r24, r24
     a7e:	29 f0       	breq	.+10     	; 0xa8a <Get_byte+0x26>
		//Clear int flag and enable acknowledge to receive data.
		TWCR = (1<<TWINT | 1<<TWEA | 1<<TWEN);
     a80:	ec eb       	ldi	r30, 0xBC	; 188
     a82:	f0 e0       	ldi	r31, 0x00	; 0
     a84:	84 ec       	ldi	r24, 0xC4	; 196
     a86:	80 83       	st	Z, r24
     a88:	04 c0       	rjmp	.+8      	; 0xa92 <Get_byte+0x2e>
	else									//Last byte
		/*Clear int flag to and do not enable acknowledge to tell the slave 
		to stop transmitting*/
		TWCR = (1<<TWINT | 1<<TWEN); 			
     a8a:	ec eb       	ldi	r30, 0xBC	; 188
     a8c:	f0 e0       	ldi	r31, 0x00	; 0
     a8e:	84 e8       	ldi	r24, 0x84	; 132
     a90:	80 83       	st	Z, r24
	Wait_TWI_int();							//Wait for TWI interrupt flag set
     a92:	0e 94 ee 03 	call	0x7dc	; 0x7dc <Wait_TWI_int>

	*rx_ptr = TWDR;							//Save received byte
     a96:	eb eb       	ldi	r30, 0xBB	; 187
     a98:	f0 e0       	ldi	r31, 0x00	; 0
     a9a:	80 81       	ld	r24, Z
     a9c:	e9 81       	ldd	r30, Y+1	; 0x01
     a9e:	fa 81       	ldd	r31, Y+2	; 0x02
     aa0:	80 83       	st	Z, r24

	/*If ACK has been transmitted or this was the last byte and NACK has been
	sent -> return SUCCESS, else return TWSR*/	
 	if(((TWSR == MRX_DATA_NACK)&&(last_byte == 0))||(TWSR == MRX_DATA_ACK))
     aa2:	e9 eb       	ldi	r30, 0xB9	; 185
     aa4:	f0 e0       	ldi	r31, 0x00	; 0
     aa6:	80 81       	ld	r24, Z
     aa8:	88 35       	cpi	r24, 0x58	; 88
     aaa:	19 f4       	brne	.+6      	; 0xab2 <Get_byte+0x4e>
     aac:	8b 81       	ldd	r24, Y+3	; 0x03
     aae:	88 23       	and	r24, r24
     ab0:	29 f0       	breq	.+10     	; 0xabc <Get_byte+0x58>
     ab2:	e9 eb       	ldi	r30, 0xB9	; 185
     ab4:	f0 e0       	ldi	r31, 0x00	; 0
     ab6:	80 81       	ld	r24, Z
     ab8:	80 35       	cpi	r24, 0x50	; 80
     aba:	19 f4       	brne	.+6      	; 0xac2 <Get_byte+0x5e>
		return SUCCESS;	  
     abc:	8f ef       	ldi	r24, 0xFF	; 255
     abe:	8c 83       	std	Y+4, r24	; 0x04
     ac0:	04 c0       	rjmp	.+8      	; 0xaca <Get_byte+0x66>
	return TWSR;
     ac2:	e9 eb       	ldi	r30, 0xB9	; 185
     ac4:	f0 e0       	ldi	r31, 0x00	; 0
     ac6:	80 81       	ld	r24, Z
     ac8:	8c 83       	std	Y+4, r24	; 0x04
     aca:	8c 81       	ldd	r24, Y+4	; 0x04
}
     acc:	0f 90       	pop	r0
     ace:	0f 90       	pop	r0
     ad0:	0f 90       	pop	r0
     ad2:	0f 90       	pop	r0
     ad4:	cf 91       	pop	r28
     ad6:	df 91       	pop	r29
     ad8:	08 95       	ret

00000ada <read_i2c_word>:
* Requirements	:
*
* Description	: This function reads a byte from a device connected to the I2C-bus
***************************************************************** */
WORD read_i2c_word(unsigned char slaveadr, unsigned char reg)
{
     ada:	df 93       	push	r29
     adc:	cf 93       	push	r28
     ade:	cd b7       	in	r28, 0x3d	; 61
     ae0:	de b7       	in	r29, 0x3e	; 62
     ae2:	66 97       	sbiw	r28, 0x16	; 22
     ae4:	0f b6       	in	r0, 0x3f	; 63
     ae6:	f8 94       	cli
     ae8:	de bf       	out	0x3e, r29	; 62
     aea:	0f be       	out	0x3f, r0	; 63
     aec:	cd bf       	out	0x3d, r28	; 61
     aee:	8b 8b       	std	Y+19, r24	; 0x13
     af0:	6c 8b       	std	Y+20, r22	; 0x14
	BYTE temp[2];
	BYTE *janne;
	unsigned char banan;
	tx_type tx_frame[3];

	janne = &temp[0];
     af2:	ce 01       	movw	r24, r28
     af4:	04 96       	adiw	r24, 0x04	; 4
     af6:	9a 83       	std	Y+2, r25	; 0x02
     af8:	89 83       	std	Y+1, r24	; 0x01
	banan = reg;
     afa:	8c 89       	ldd	r24, Y+20	; 0x14
     afc:	8e 83       	std	Y+6, r24	; 0x06
	state = SUCCESS;
     afe:	8f ef       	ldi	r24, 0xFF	; 255
     b00:	8b 83       	std	Y+3, r24	; 0x03
	
	tx_frame[0].slave_adr = slaveadr + Write;	// Slave adr + Write
     b02:	8b 89       	ldd	r24, Y+19	; 0x13
     b04:	8f 83       	std	Y+7, r24	; 0x07
	tx_frame[0].size = 1;						// Number of bytes to send
     b06:	81 e0       	ldi	r24, 0x01	; 1
     b08:	88 87       	std	Y+8, r24	; 0x08
	tx_frame[0].data_ptr = &banan;				// Set the pointer to temp's address
     b0a:	ce 01       	movw	r24, r28
     b0c:	06 96       	adiw	r24, 0x06	; 6
     b0e:	9a 87       	std	Y+10, r25	; 0x0a
     b10:	89 87       	std	Y+9, r24	; 0x09
	//tx_frame[0].data_ptr[0] = reg;				// Access 

	tx_frame[1].slave_adr = slaveadr + Read;	// Init a Master Read
     b12:	8b 89       	ldd	r24, Y+19	; 0x13
     b14:	8f 5f       	subi	r24, 0xFF	; 255
     b16:	8b 87       	std	Y+11, r24	; 0x0b
	tx_frame[1].size = 2;						// Number of bytes to read
     b18:	82 e0       	ldi	r24, 0x02	; 2
     b1a:	8c 87       	std	Y+12, r24	; 0x0c
	tx_frame[1].data_ptr = janne;				// Set the pointer to temp's address
     b1c:	89 81       	ldd	r24, Y+1	; 0x01
     b1e:	9a 81       	ldd	r25, Y+2	; 0x02
     b20:	9e 87       	std	Y+14, r25	; 0x0e
     b22:	8d 87       	std	Y+13, r24	; 0x0d

	tx_frame[2].slave_adr = OWN_ADR;			// Set to OWN_ADR to end TWI frame
     b24:	8c e3       	ldi	r24, 0x3C	; 60
     b26:	8f 87       	std	Y+15, r24	; 0x0f

	state =Send_to_TWI(tx_frame);				// Call the Master TWI driver with
     b28:	ce 01       	movw	r24, r28
     b2a:	07 96       	adiw	r24, 0x07	; 7
     b2c:	0e 94 26 04 	call	0x84c	; 0x84c <Send_to_TWI>
     b30:	8b 83       	std	Y+3, r24	; 0x03
												// a pointer to the first struct 
												// in the package
												
	if(state != SUCCESS)						//If error occured during the TWI
     b32:	8b 81       	ldd	r24, Y+3	; 0x03
     b34:	8f 3f       	cpi	r24, 0xFF	; 255
     b36:	29 f0       	breq	.+10     	; 0xb42 <read_i2c_word+0x68>
		return 0x80;							//comunication, return TWSR
     b38:	80 e8       	ldi	r24, 0x80	; 128
     b3a:	90 e0       	ldi	r25, 0x00	; 0
     b3c:	9e 8b       	std	Y+22, r25	; 0x16
     b3e:	8d 8b       	std	Y+21, r24	; 0x15
     b40:	0c c0       	rjmp	.+24     	; 0xb5a <read_i2c_word+0x80>

	
	
	return (temp[0] << 8)| temp[1];								//If error, return 0x80
     b42:	8c 81       	ldd	r24, Y+4	; 0x04
     b44:	88 2f       	mov	r24, r24
     b46:	90 e0       	ldi	r25, 0x00	; 0
     b48:	38 2f       	mov	r19, r24
     b4a:	22 27       	eor	r18, r18
     b4c:	8d 81       	ldd	r24, Y+5	; 0x05
     b4e:	88 2f       	mov	r24, r24
     b50:	90 e0       	ldi	r25, 0x00	; 0
     b52:	82 2b       	or	r24, r18
     b54:	93 2b       	or	r25, r19
     b56:	9e 8b       	std	Y+22, r25	; 0x16
     b58:	8d 8b       	std	Y+21, r24	; 0x15
     b5a:	8d 89       	ldd	r24, Y+21	; 0x15
     b5c:	9e 89       	ldd	r25, Y+22	; 0x16

}
     b5e:	66 96       	adiw	r28, 0x16	; 22
     b60:	0f b6       	in	r0, 0x3f	; 63
     b62:	f8 94       	cli
     b64:	de bf       	out	0x3e, r29	; 62
     b66:	0f be       	out	0x3f, r0	; 63
     b68:	cd bf       	out	0x3d, r28	; 61
     b6a:	cf 91       	pop	r28
     b6c:	df 91       	pop	r29
     b6e:	08 95       	ret

00000b70 <read_i2c_byte>:
* Requirements	:
*
* Description	: This function reads a byte from a device connected to the I2C-bus
***************************************************************** */
unsigned char read_i2c_byte(unsigned char slaveadr, unsigned char reg)
{
     b70:	df 93       	push	r29
     b72:	cf 93       	push	r28
     b74:	cd b7       	in	r28, 0x3d	; 61
     b76:	de b7       	in	r29, 0x3e	; 62
     b78:	61 97       	sbiw	r28, 0x11	; 17
     b7a:	0f b6       	in	r0, 0x3f	; 63
     b7c:	f8 94       	cli
     b7e:	de bf       	out	0x3e, r29	; 62
     b80:	0f be       	out	0x3f, r0	; 63
     b82:	cd bf       	out	0x3d, r28	; 61
     b84:	8f 87       	std	Y+15, r24	; 0x0f
     b86:	68 8b       	std	Y+16, r22	; 0x10

	unsigned char state;
	unsigned char temp;
	tx_type tx_frame[3];

	state = SUCCESS;
     b88:	8f ef       	ldi	r24, 0xFF	; 255
     b8a:	89 83       	std	Y+1, r24	; 0x01
	
	tx_frame[0].slave_adr = slaveadr + Write;	// Slave adr + Write
     b8c:	8f 85       	ldd	r24, Y+15	; 0x0f
     b8e:	8b 83       	std	Y+3, r24	; 0x03
	tx_frame[0].size = 1;						// Number of bytes to send
     b90:	81 e0       	ldi	r24, 0x01	; 1
     b92:	8c 83       	std	Y+4, r24	; 0x04
	tx_frame[0].data_ptr = &temp;				// Set the pointer to temp's address
     b94:	ce 01       	movw	r24, r28
     b96:	02 96       	adiw	r24, 0x02	; 2
     b98:	9e 83       	std	Y+6, r25	; 0x06
     b9a:	8d 83       	std	Y+5, r24	; 0x05
	tx_frame[0].data_ptr[0] = reg;				// Access 
     b9c:	ed 81       	ldd	r30, Y+5	; 0x05
     b9e:	fe 81       	ldd	r31, Y+6	; 0x06
     ba0:	88 89       	ldd	r24, Y+16	; 0x10
     ba2:	80 83       	st	Z, r24

	tx_frame[1].slave_adr = slaveadr + Read;	// Init a Master Read
     ba4:	8f 85       	ldd	r24, Y+15	; 0x0f
     ba6:	8f 5f       	subi	r24, 0xFF	; 255
     ba8:	8f 83       	std	Y+7, r24	; 0x07
	tx_frame[1].size = 1;						// Number of bytes to read
     baa:	81 e0       	ldi	r24, 0x01	; 1
     bac:	88 87       	std	Y+8, r24	; 0x08
	tx_frame[1].data_ptr = &temp;				// Set the pointer to temp's address
     bae:	ce 01       	movw	r24, r28
     bb0:	02 96       	adiw	r24, 0x02	; 2
     bb2:	9a 87       	std	Y+10, r25	; 0x0a
     bb4:	89 87       	std	Y+9, r24	; 0x09

	tx_frame[2].slave_adr = OWN_ADR;			// Set to OWN_ADR to end TWI frame
     bb6:	8c e3       	ldi	r24, 0x3C	; 60
     bb8:	8b 87       	std	Y+11, r24	; 0x0b

	state =Send_to_TWI(tx_frame);				// Call the Master TWI driver with
     bba:	ce 01       	movw	r24, r28
     bbc:	03 96       	adiw	r24, 0x03	; 3
     bbe:	0e 94 26 04 	call	0x84c	; 0x84c <Send_to_TWI>
     bc2:	89 83       	std	Y+1, r24	; 0x01
												// a pointer to the first struct 
												// in the package
												
	if(state != SUCCESS)						//If error occured during the TWI
     bc4:	89 81       	ldd	r24, Y+1	; 0x01
     bc6:	8f 3f       	cpi	r24, 0xFF	; 255
     bc8:	19 f0       	breq	.+6      	; 0xbd0 <read_i2c_byte+0x60>
		return 0x80;							//comunication, return TWSR
     bca:	80 e8       	ldi	r24, 0x80	; 128
     bcc:	89 8b       	std	Y+17, r24	; 0x11
     bce:	02 c0       	rjmp	.+4      	; 0xbd4 <read_i2c_byte+0x64>
	return temp;								//If error, return 0x80
     bd0:	8a 81       	ldd	r24, Y+2	; 0x02
     bd2:	89 8b       	std	Y+17, r24	; 0x11
     bd4:	89 89       	ldd	r24, Y+17	; 0x11

}
     bd6:	61 96       	adiw	r28, 0x11	; 17
     bd8:	0f b6       	in	r0, 0x3f	; 63
     bda:	f8 94       	cli
     bdc:	de bf       	out	0x3e, r29	; 62
     bde:	0f be       	out	0x3f, r0	; 63
     be0:	cd bf       	out	0x3d, r28	; 61
     be2:	cf 91       	pop	r28
     be4:	df 91       	pop	r29
     be6:	08 95       	ret

00000be8 <write_i2c_data>:
*
* Requirements	:
*
***************************************************************** */
unsigned char write_i2c_data(unsigned char slave_adr, unsigned char adr, unsigned char size, BYTE *data)
{
     be8:	df 93       	push	r29
     bea:	cf 93       	push	r28
     bec:	cd b7       	in	r28, 0x3d	; 61
     bee:	de b7       	in	r29, 0x3e	; 62
     bf0:	66 97       	sbiw	r28, 0x16	; 22
     bf2:	0f b6       	in	r0, 0x3f	; 63
     bf4:	f8 94       	cli
     bf6:	de bf       	out	0x3e, r29	; 62
     bf8:	0f be       	out	0x3f, r0	; 63
     bfa:	cd bf       	out	0x3d, r28	; 61
     bfc:	8a 8b       	std	Y+18, r24	; 0x12
     bfe:	6b 8b       	std	Y+19, r22	; 0x13
     c00:	4c 8b       	std	Y+20, r20	; 0x14
     c02:	3e 8b       	std	Y+22, r19	; 0x16
     c04:	2d 8b       	std	Y+21, r18	; 0x15
	BYTE urban[3];
	tx_type tx_frame[3];
	unsigned char state;
	unsigned char i;
	
	urban[0] = adr;
     c06:	8b 89       	ldd	r24, Y+19	; 0x13
     c08:	8b 83       	std	Y+3, r24	; 0x03
	urban[2] = *data++;
     c0a:	ed 89       	ldd	r30, Y+21	; 0x15
     c0c:	fe 89       	ldd	r31, Y+22	; 0x16
     c0e:	80 81       	ld	r24, Z
     c10:	8d 83       	std	Y+5, r24	; 0x05
     c12:	8d 89       	ldd	r24, Y+21	; 0x15
     c14:	9e 89       	ldd	r25, Y+22	; 0x16
     c16:	01 96       	adiw	r24, 0x01	; 1
     c18:	9e 8b       	std	Y+22, r25	; 0x16
     c1a:	8d 8b       	std	Y+21, r24	; 0x15
	urban[1] = *data;
     c1c:	ed 89       	ldd	r30, Y+21	; 0x15
     c1e:	fe 89       	ldd	r31, Y+22	; 0x16
     c20:	80 81       	ld	r24, Z
     c22:	8c 83       	std	Y+4, r24	; 0x04
	
	tx_frame[0].slave_adr = slave_adr + Write;
     c24:	8a 89       	ldd	r24, Y+18	; 0x12
     c26:	8e 83       	std	Y+6, r24	; 0x06
	tx_frame[0].size = size+1;
     c28:	8c 89       	ldd	r24, Y+20	; 0x14
     c2a:	8f 5f       	subi	r24, 0xFF	; 255
     c2c:	8f 83       	std	Y+7, r24	; 0x07
	tx_frame[0].data_ptr = urban;
     c2e:	ce 01       	movw	r24, r28
     c30:	03 96       	adiw	r24, 0x03	; 3
     c32:	99 87       	std	Y+9, r25	; 0x09
     c34:	88 87       	std	Y+8, r24	; 0x08
		
	tx_frame[1].slave_adr = OWN_ADR;	/* set own_adr to mark end of frames */
     c36:	8c e3       	ldi	r24, 0x3C	; 60
     c38:	8a 87       	std	Y+10, r24	; 0x0a
	
	state = 0x00;
     c3a:	1a 82       	std	Y+2, r1	; 0x02
			
	for (i=0; i< 10; i++)
     c3c:	19 82       	std	Y+1, r1	; 0x01
     c3e:	0f c0       	rjmp	.+30     	; 0xc5e <write_i2c_data+0x76>
	{
		state = Send_to_TWI(tx_frame);
     c40:	ce 01       	movw	r24, r28
     c42:	06 96       	adiw	r24, 0x06	; 6
     c44:	0e 94 26 04 	call	0x84c	; 0x84c <Send_to_TWI>
     c48:	8a 83       	std	Y+2, r24	; 0x02
		if(state == SUCCESS)
     c4a:	8a 81       	ldd	r24, Y+2	; 0x02
     c4c:	8f 3f       	cpi	r24, 0xFF	; 255
     c4e:	51 f0       	breq	.+20     	; 0xc64 <write_i2c_data+0x7c>
			break;
		wait_ms(5);
     c50:	85 e0       	ldi	r24, 0x05	; 5
     c52:	90 e0       	ldi	r25, 0x00	; 0
     c54:	0e 94 6b 00 	call	0xd6	; 0xd6 <wait_ms>
		
	tx_frame[1].slave_adr = OWN_ADR;	/* set own_adr to mark end of frames */
	
	state = 0x00;
			
	for (i=0; i< 10; i++)
     c58:	89 81       	ldd	r24, Y+1	; 0x01
     c5a:	8f 5f       	subi	r24, 0xFF	; 255
     c5c:	89 83       	std	Y+1, r24	; 0x01
     c5e:	89 81       	ldd	r24, Y+1	; 0x01
     c60:	8a 30       	cpi	r24, 0x0A	; 10
     c62:	70 f3       	brcs	.-36     	; 0xc40 <write_i2c_data+0x58>
		state = Send_to_TWI(tx_frame);
		if(state == SUCCESS)
			break;
		wait_ms(5);
	}
	return(state);
     c64:	8a 81       	ldd	r24, Y+2	; 0x02
}
     c66:	66 96       	adiw	r28, 0x16	; 22
     c68:	0f b6       	in	r0, 0x3f	; 63
     c6a:	f8 94       	cli
     c6c:	de bf       	out	0x3e, r29	; 62
     c6e:	0f be       	out	0x3f, r0	; 63
     c70:	cd bf       	out	0x3d, r28	; 61
     c72:	cf 91       	pop	r28
     c74:	df 91       	pop	r29
     c76:	08 95       	ret

00000c78 <init_i2c>:


void init_i2c(void)
{
     c78:	df 93       	push	r29
     c7a:	cf 93       	push	r28
     c7c:	cd b7       	in	r28, 0x3d	; 61
     c7e:	de b7       	in	r29, 0x3e	; 62
	Init_TWI();							/* Init I2C interface (VID_TWI_driver.c) */
     c80:	0e 94 da 03 	call	0x7b4	; 0x7b4 <Init_TWI>
}
     c84:	cf 91       	pop	r28
     c86:	df 91       	pop	r29
     c88:	08 95       	ret

00000c8a <i2c_get_ack>:

BYTE i2c_get_ack(BYTE slaveadr, BYTE *answer, BYTE retsize)
{
     c8a:	df 93       	push	r29
     c8c:	cf 93       	push	r28
     c8e:	cd b7       	in	r28, 0x3d	; 61
     c90:	de b7       	in	r29, 0x3e	; 62
     c92:	2e 97       	sbiw	r28, 0x0e	; 14
     c94:	0f b6       	in	r0, 0x3f	; 63
     c96:	f8 94       	cli
     c98:	de bf       	out	0x3e, r29	; 62
     c9a:	0f be       	out	0x3f, r0	; 63
     c9c:	cd bf       	out	0x3d, r28	; 61
     c9e:	8a 87       	std	Y+10, r24	; 0x0a
     ca0:	7c 87       	std	Y+12, r23	; 0x0c
     ca2:	6b 87       	std	Y+11, r22	; 0x0b
     ca4:	4d 87       	std	Y+13, r20	; 0x0d

	unsigned char state;
	tx_type tx_frame[2];

	state = SUCCESS;
     ca6:	8f ef       	ldi	r24, 0xFF	; 255
     ca8:	89 83       	std	Y+1, r24	; 0x01
	
	tx_frame[0].slave_adr = slaveadr + Read;	// Slave adr + Write
     caa:	8a 85       	ldd	r24, Y+10	; 0x0a
     cac:	8f 5f       	subi	r24, 0xFF	; 255
     cae:	8a 83       	std	Y+2, r24	; 0x02
	tx_frame[0].size = 4;						// Number of bytes to send
     cb0:	84 e0       	ldi	r24, 0x04	; 4
     cb2:	8b 83       	std	Y+3, r24	; 0x03
	tx_frame[0].data_ptr = answer;				// Set the pointer to temp's address
     cb4:	8b 85       	ldd	r24, Y+11	; 0x0b
     cb6:	9c 85       	ldd	r25, Y+12	; 0x0c
     cb8:	9d 83       	std	Y+5, r25	; 0x05
     cba:	8c 83       	std	Y+4, r24	; 0x04


	tx_frame[1].slave_adr = OWN_ADR;			// Set to OWN_ADR to end TWI frame
     cbc:	8c e3       	ldi	r24, 0x3C	; 60
     cbe:	8e 83       	std	Y+6, r24	; 0x06

	state =Send_to_TWI(tx_frame);				// Call the Master TWI driver with
     cc0:	ce 01       	movw	r24, r28
     cc2:	02 96       	adiw	r24, 0x02	; 2
     cc4:	0e 94 26 04 	call	0x84c	; 0x84c <Send_to_TWI>
     cc8:	89 83       	std	Y+1, r24	; 0x01
												// a pointer to the first struct 
												// in the package
												
	if(state != SUCCESS)						// If error occured during the TWI
     cca:	89 81       	ldd	r24, Y+1	; 0x01
     ccc:	8f 3f       	cpi	r24, 0xFF	; 255
     cce:	19 f0       	breq	.+6      	; 0xcd6 <i2c_get_ack+0x4c>
		return 0x80;							// comunication, return TWSR
     cd0:	80 e8       	ldi	r24, 0x80	; 128
     cd2:	8e 87       	std	Y+14, r24	; 0x0e
     cd4:	01 c0       	rjmp	.+2      	; 0xcd8 <i2c_get_ack+0x4e>
	else										// If error, return 0x80
		return 0;								
     cd6:	1e 86       	std	Y+14, r1	; 0x0e
     cd8:	8e 85       	ldd	r24, Y+14	; 0x0e
     cda:	2e 96       	adiw	r28, 0x0e	; 14
     cdc:	0f b6       	in	r0, 0x3f	; 63
     cde:	f8 94       	cli
     ce0:	de bf       	out	0x3e, r29	; 62
     ce2:	0f be       	out	0x3f, r0	; 63
     ce4:	cd bf       	out	0x3d, r28	; 61
     ce6:	cf 91       	pop	r28
     ce8:	df 91       	pop	r29
     cea:	08 95       	ret

00000cec <uart_init>:
#include "uart.h"
#include <avr/io.h>	

void uart_init(unsigned int ubrr)
{
     cec:	df 93       	push	r29
     cee:	cf 93       	push	r28
     cf0:	00 d0       	rcall	.+0      	; 0xcf2 <uart_init+0x6>
     cf2:	cd b7       	in	r28, 0x3d	; 61
     cf4:	de b7       	in	r29, 0x3e	; 62
     cf6:	9a 83       	std	Y+2, r25	; 0x02
     cf8:	89 83       	std	Y+1, r24	; 0x01
	/* Set baud rate */
	UBRR0H = (unsigned char) (ubrr>>8);
     cfa:	e5 ec       	ldi	r30, 0xC5	; 197
     cfc:	f0 e0       	ldi	r31, 0x00	; 0
     cfe:	89 81       	ldd	r24, Y+1	; 0x01
     d00:	9a 81       	ldd	r25, Y+2	; 0x02
     d02:	89 2f       	mov	r24, r25
     d04:	99 27       	eor	r25, r25
     d06:	80 83       	st	Z, r24
	UBRR0L = (unsigned char) ubrr;
     d08:	e4 ec       	ldi	r30, 0xC4	; 196
     d0a:	f0 e0       	ldi	r31, 0x00	; 0
     d0c:	89 81       	ldd	r24, Y+1	; 0x01
     d0e:	80 83       	st	Z, r24
	
	/* Enable receiver and transmitter */
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
     d10:	e1 ec       	ldi	r30, 0xC1	; 193
     d12:	f0 e0       	ldi	r31, 0x00	; 0
     d14:	88 e1       	ldi	r24, 0x18	; 24
     d16:	80 83       	st	Z, r24
	
	/* Set frame format: 8 data, 1 stop bit */
	//UCSRC = (1<<URSEL)|(1<<UCSZ)|(1<<UCSZ);
	UCSR0C = (1<<USBS0)|(3<<UCSZ00);
     d18:	e2 ec       	ldi	r30, 0xC2	; 194
     d1a:	f0 e0       	ldi	r31, 0x00	; 0
     d1c:	8e e0       	ldi	r24, 0x0E	; 14
     d1e:	80 83       	st	Z, r24
}
     d20:	0f 90       	pop	r0
     d22:	0f 90       	pop	r0
     d24:	cf 91       	pop	r28
     d26:	df 91       	pop	r29
     d28:	08 95       	ret

00000d2a <uart_send_byte>:

void uart_send_byte(unsigned char *data)
{
     d2a:	df 93       	push	r29
     d2c:	cf 93       	push	r28
     d2e:	00 d0       	rcall	.+0      	; 0xd30 <uart_send_byte+0x6>
     d30:	cd b7       	in	r28, 0x3d	; 61
     d32:	de b7       	in	r29, 0x3e	; 62
     d34:	9a 83       	std	Y+2, r25	; 0x02
     d36:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
     d38:	e0 ec       	ldi	r30, 0xC0	; 192
     d3a:	f0 e0       	ldi	r31, 0x00	; 0
     d3c:	80 81       	ld	r24, Z
     d3e:	88 2f       	mov	r24, r24
     d40:	90 e0       	ldi	r25, 0x00	; 0
     d42:	80 72       	andi	r24, 0x20	; 32
     d44:	90 70       	andi	r25, 0x00	; 0
     d46:	00 97       	sbiw	r24, 0x00	; 0
     d48:	b9 f3       	breq	.-18     	; 0xd38 <uart_send_byte+0xe>
	;
	
	/* Put data into buffer, sends the data */
	UDR0 = *data;
     d4a:	e6 ec       	ldi	r30, 0xC6	; 198
     d4c:	f0 e0       	ldi	r31, 0x00	; 0
     d4e:	a9 81       	ldd	r26, Y+1	; 0x01
     d50:	ba 81       	ldd	r27, Y+2	; 0x02
     d52:	8c 91       	ld	r24, X
     d54:	80 83       	st	Z, r24
}
     d56:	0f 90       	pop	r0
     d58:	0f 90       	pop	r0
     d5a:	cf 91       	pop	r28
     d5c:	df 91       	pop	r29
     d5e:	08 95       	ret

00000d60 <copy_str>:

extern void copy_str(const char *in, unsigned char *msg, unsigned char length)
{
     d60:	df 93       	push	r29
     d62:	cf 93       	push	r28
     d64:	00 d0       	rcall	.+0      	; 0xd66 <copy_str+0x6>
     d66:	00 d0       	rcall	.+0      	; 0xd68 <copy_str+0x8>
     d68:	00 d0       	rcall	.+0      	; 0xd6a <copy_str+0xa>
     d6a:	cd b7       	in	r28, 0x3d	; 61
     d6c:	de b7       	in	r29, 0x3e	; 62
     d6e:	9b 83       	std	Y+3, r25	; 0x03
     d70:	8a 83       	std	Y+2, r24	; 0x02
     d72:	7d 83       	std	Y+5, r23	; 0x05
     d74:	6c 83       	std	Y+4, r22	; 0x04
     d76:	4e 83       	std	Y+6, r20	; 0x06
	unsigned char i;
	
	for (i = 0; i < length; i++)
     d78:	19 82       	std	Y+1, r1	; 0x01
     d7a:	13 c0       	rjmp	.+38     	; 0xda2 <copy_str+0x42>
	{ 
		*msg++ = *in++; 		// copy text string byte by byte
     d7c:	ea 81       	ldd	r30, Y+2	; 0x02
     d7e:	fb 81       	ldd	r31, Y+3	; 0x03
     d80:	80 81       	ld	r24, Z
     d82:	ec 81       	ldd	r30, Y+4	; 0x04
     d84:	fd 81       	ldd	r31, Y+5	; 0x05
     d86:	80 83       	st	Z, r24
     d88:	8c 81       	ldd	r24, Y+4	; 0x04
     d8a:	9d 81       	ldd	r25, Y+5	; 0x05
     d8c:	01 96       	adiw	r24, 0x01	; 1
     d8e:	9d 83       	std	Y+5, r25	; 0x05
     d90:	8c 83       	std	Y+4, r24	; 0x04
     d92:	8a 81       	ldd	r24, Y+2	; 0x02
     d94:	9b 81       	ldd	r25, Y+3	; 0x03
     d96:	01 96       	adiw	r24, 0x01	; 1
     d98:	9b 83       	std	Y+3, r25	; 0x03
     d9a:	8a 83       	std	Y+2, r24	; 0x02

extern void copy_str(const char *in, unsigned char *msg, unsigned char length)
{
	unsigned char i;
	
	for (i = 0; i < length; i++)
     d9c:	89 81       	ldd	r24, Y+1	; 0x01
     d9e:	8f 5f       	subi	r24, 0xFF	; 255
     da0:	89 83       	std	Y+1, r24	; 0x01
     da2:	99 81       	ldd	r25, Y+1	; 0x01
     da4:	8e 81       	ldd	r24, Y+6	; 0x06
     da6:	98 17       	cp	r25, r24
     da8:	48 f3       	brcs	.-46     	; 0xd7c <copy_str+0x1c>
	{ 
		*msg++ = *in++; 		// copy text string byte by byte
	}

     daa:	26 96       	adiw	r28, 0x06	; 6
     dac:	0f b6       	in	r0, 0x3f	; 63
     dae:	f8 94       	cli
     db0:	de bf       	out	0x3e, r29	; 62
     db2:	0f be       	out	0x3f, r0	; 63
     db4:	cd bf       	out	0x3d, r28	; 61
     db6:	cf 91       	pop	r28
     db8:	df 91       	pop	r29
     dba:	08 95       	ret

00000dbc <toggle_e>:


#if LCD_IO_MODE
/* toggle Enable Pin to initiate write */
static void toggle_e(void)
{
     dbc:	df 93       	push	r29
     dbe:	cf 93       	push	r28
     dc0:	cd b7       	in	r28, 0x3d	; 61
     dc2:	de b7       	in	r29, 0x3e	; 62
    lcd_e_high();
     dc4:	a2 e2       	ldi	r26, 0x22	; 34
     dc6:	b0 e0       	ldi	r27, 0x00	; 0
     dc8:	e2 e2       	ldi	r30, 0x22	; 34
     dca:	f0 e0       	ldi	r31, 0x00	; 0
     dcc:	80 81       	ld	r24, Z
     dce:	80 64       	ori	r24, 0x40	; 64
     dd0:	8c 93       	st	X, r24
    lcd_e_delay();
     dd2:	00 c0       	rjmp	.+0      	; 0xdd4 <toggle_e+0x18>
    lcd_e_low();
     dd4:	a2 e2       	ldi	r26, 0x22	; 34
     dd6:	b0 e0       	ldi	r27, 0x00	; 0
     dd8:	e2 e2       	ldi	r30, 0x22	; 34
     dda:	f0 e0       	ldi	r31, 0x00	; 0
     ddc:	80 81       	ld	r24, Z
     dde:	8f 7b       	andi	r24, 0xBF	; 191
     de0:	8c 93       	st	X, r24
}
     de2:	cf 91       	pop	r28
     de4:	df 91       	pop	r29
     de6:	08 95       	ret

00000de8 <lcd_write>:
                 0: write instruction
Returns:  none
*************************************************************************/
#if LCD_IO_MODE
static void lcd_write(uint8_t data,uint8_t rs) 
{
     de8:	df 93       	push	r29
     dea:	cf 93       	push	r28
     dec:	00 d0       	rcall	.+0      	; 0xdee <lcd_write+0x6>
     dee:	0f 92       	push	r0
     df0:	cd b7       	in	r28, 0x3d	; 61
     df2:	de b7       	in	r29, 0x3e	; 62
     df4:	8a 83       	std	Y+2, r24	; 0x02
     df6:	6b 83       	std	Y+3, r22	; 0x03
    unsigned char dataBits ;


    if (rs) {   /* write data        (RS=1, RW=0) */
     df8:	8b 81       	ldd	r24, Y+3	; 0x03
     dfa:	88 23       	and	r24, r24
     dfc:	41 f0       	breq	.+16     	; 0xe0e <lcd_write+0x26>
       lcd_rs_high();
     dfe:	a2 e2       	ldi	r26, 0x22	; 34
     e00:	b0 e0       	ldi	r27, 0x00	; 0
     e02:	e2 e2       	ldi	r30, 0x22	; 34
     e04:	f0 e0       	ldi	r31, 0x00	; 0
     e06:	80 81       	ld	r24, Z
     e08:	80 61       	ori	r24, 0x10	; 16
     e0a:	8c 93       	st	X, r24
     e0c:	07 c0       	rjmp	.+14     	; 0xe1c <lcd_write+0x34>
    } else {    /* write instruction (RS=0, RW=0) */
       lcd_rs_low();
     e0e:	a2 e2       	ldi	r26, 0x22	; 34
     e10:	b0 e0       	ldi	r27, 0x00	; 0
     e12:	e2 e2       	ldi	r30, 0x22	; 34
     e14:	f0 e0       	ldi	r31, 0x00	; 0
     e16:	80 81       	ld	r24, Z
     e18:	8f 7e       	andi	r24, 0xEF	; 239
     e1a:	8c 93       	st	X, r24
    }
    lcd_rw_low();
     e1c:	a2 e2       	ldi	r26, 0x22	; 34
     e1e:	b0 e0       	ldi	r27, 0x00	; 0
     e20:	e2 e2       	ldi	r30, 0x22	; 34
     e22:	f0 e0       	ldi	r31, 0x00	; 0
     e24:	80 81       	ld	r24, Z
     e26:	8f 7d       	andi	r24, 0xDF	; 223
     e28:	8c 93       	st	X, r24

    if ( ( &LCD_DATA0_PORT == &LCD_DATA1_PORT) && ( &LCD_DATA1_PORT == &LCD_DATA2_PORT ) && ( &LCD_DATA2_PORT == &LCD_DATA3_PORT )
      && (LCD_DATA0_PIN == 0) && (LCD_DATA1_PIN == 1) && (LCD_DATA2_PIN == 2) && (LCD_DATA3_PIN == 3) )
    {
        /* configure data pins as output */
        DDR(LCD_DATA0_PORT) |= 0x0F;
     e2a:	a1 e2       	ldi	r26, 0x21	; 33
     e2c:	b0 e0       	ldi	r27, 0x00	; 0
     e2e:	e1 e2       	ldi	r30, 0x21	; 33
     e30:	f0 e0       	ldi	r31, 0x00	; 0
     e32:	80 81       	ld	r24, Z
     e34:	8f 60       	ori	r24, 0x0F	; 15
     e36:	8c 93       	st	X, r24

        /* output high nibble first */
        dataBits = LCD_DATA0_PORT & 0xF0;
     e38:	e2 e2       	ldi	r30, 0x22	; 34
     e3a:	f0 e0       	ldi	r31, 0x00	; 0
     e3c:	80 81       	ld	r24, Z
     e3e:	80 7f       	andi	r24, 0xF0	; 240
     e40:	89 83       	std	Y+1, r24	; 0x01
        LCD_DATA0_PORT = dataBits |((data>>4)&0x0F);
     e42:	e2 e2       	ldi	r30, 0x22	; 34
     e44:	f0 e0       	ldi	r31, 0x00	; 0
     e46:	8a 81       	ldd	r24, Y+2	; 0x02
     e48:	98 2f       	mov	r25, r24
     e4a:	92 95       	swap	r25
     e4c:	9f 70       	andi	r25, 0x0F	; 15
     e4e:	89 81       	ldd	r24, Y+1	; 0x01
     e50:	89 2b       	or	r24, r25
     e52:	80 83       	st	Z, r24
        lcd_e_toggle();
     e54:	0e 94 de 06 	call	0xdbc	; 0xdbc <toggle_e>

        /* output low nibble */
        LCD_DATA0_PORT = dataBits | (data&0x0F);
     e58:	e2 e2       	ldi	r30, 0x22	; 34
     e5a:	f0 e0       	ldi	r31, 0x00	; 0
     e5c:	8a 81       	ldd	r24, Y+2	; 0x02
     e5e:	98 2f       	mov	r25, r24
     e60:	9f 70       	andi	r25, 0x0F	; 15
     e62:	89 81       	ldd	r24, Y+1	; 0x01
     e64:	89 2b       	or	r24, r25
     e66:	80 83       	st	Z, r24
        lcd_e_toggle();
     e68:	0e 94 de 06 	call	0xdbc	; 0xdbc <toggle_e>

        /* all data pins high (inactive) */
        LCD_DATA0_PORT = dataBits | 0x0F;
     e6c:	e2 e2       	ldi	r30, 0x22	; 34
     e6e:	f0 e0       	ldi	r31, 0x00	; 0
     e70:	89 81       	ldd	r24, Y+1	; 0x01
     e72:	8f 60       	ori	r24, 0x0F	; 15
     e74:	80 83       	st	Z, r24
        LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);
        LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);
        LCD_DATA2_PORT |= _BV(LCD_DATA2_PIN);
        LCD_DATA3_PORT |= _BV(LCD_DATA3_PIN);
    }
}
     e76:	0f 90       	pop	r0
     e78:	0f 90       	pop	r0
     e7a:	0f 90       	pop	r0
     e7c:	cf 91       	pop	r28
     e7e:	df 91       	pop	r29
     e80:	08 95       	ret

00000e82 <lcd_read>:
                 0: read busy flag / address counter
Returns:  byte read from LCD controller
*************************************************************************/
#if LCD_IO_MODE
static uint8_t lcd_read(uint8_t rs) 
{
     e82:	df 93       	push	r29
     e84:	cf 93       	push	r28
     e86:	00 d0       	rcall	.+0      	; 0xe88 <lcd_read+0x6>
     e88:	cd b7       	in	r28, 0x3d	; 61
     e8a:	de b7       	in	r29, 0x3e	; 62
     e8c:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data;
    
    
    if (rs)
     e8e:	8a 81       	ldd	r24, Y+2	; 0x02
     e90:	88 23       	and	r24, r24
     e92:	41 f0       	breq	.+16     	; 0xea4 <lcd_read+0x22>
        lcd_rs_high();                       /* RS=1: read data      */
     e94:	a2 e2       	ldi	r26, 0x22	; 34
     e96:	b0 e0       	ldi	r27, 0x00	; 0
     e98:	e2 e2       	ldi	r30, 0x22	; 34
     e9a:	f0 e0       	ldi	r31, 0x00	; 0
     e9c:	80 81       	ld	r24, Z
     e9e:	80 61       	ori	r24, 0x10	; 16
     ea0:	8c 93       	st	X, r24
     ea2:	07 c0       	rjmp	.+14     	; 0xeb2 <lcd_read+0x30>
    else
        lcd_rs_low();                        /* RS=0: read busy flag */
     ea4:	a2 e2       	ldi	r26, 0x22	; 34
     ea6:	b0 e0       	ldi	r27, 0x00	; 0
     ea8:	e2 e2       	ldi	r30, 0x22	; 34
     eaa:	f0 e0       	ldi	r31, 0x00	; 0
     eac:	80 81       	ld	r24, Z
     eae:	8f 7e       	andi	r24, 0xEF	; 239
     eb0:	8c 93       	st	X, r24
    lcd_rw_high();                           /* RW=1  read mode      */
     eb2:	a2 e2       	ldi	r26, 0x22	; 34
     eb4:	b0 e0       	ldi	r27, 0x00	; 0
     eb6:	e2 e2       	ldi	r30, 0x22	; 34
     eb8:	f0 e0       	ldi	r31, 0x00	; 0
     eba:	80 81       	ld	r24, Z
     ebc:	80 62       	ori	r24, 0x20	; 32
     ebe:	8c 93       	st	X, r24
    
    if ( ( &LCD_DATA0_PORT == &LCD_DATA1_PORT) && ( &LCD_DATA1_PORT == &LCD_DATA2_PORT ) && ( &LCD_DATA2_PORT == &LCD_DATA3_PORT )
      && ( LCD_DATA0_PIN == 0 )&& (LCD_DATA1_PIN == 1) && (LCD_DATA2_PIN == 2) && (LCD_DATA3_PIN == 3) )
    {
        DDR(LCD_DATA0_PORT) &= 0xF0;         /* configure data pins as input */
     ec0:	a1 e2       	ldi	r26, 0x21	; 33
     ec2:	b0 e0       	ldi	r27, 0x00	; 0
     ec4:	e1 e2       	ldi	r30, 0x21	; 33
     ec6:	f0 e0       	ldi	r31, 0x00	; 0
     ec8:	80 81       	ld	r24, Z
     eca:	80 7f       	andi	r24, 0xF0	; 240
     ecc:	8c 93       	st	X, r24
        
        lcd_e_high();
     ece:	a2 e2       	ldi	r26, 0x22	; 34
     ed0:	b0 e0       	ldi	r27, 0x00	; 0
     ed2:	e2 e2       	ldi	r30, 0x22	; 34
     ed4:	f0 e0       	ldi	r31, 0x00	; 0
     ed6:	80 81       	ld	r24, Z
     ed8:	80 64       	ori	r24, 0x40	; 64
     eda:	8c 93       	st	X, r24
        lcd_e_delay();        
     edc:	00 c0       	rjmp	.+0      	; 0xede <lcd_read+0x5c>
        data = PIN(LCD_DATA0_PORT) << 4;     /* read high nibble first */
     ede:	e0 e2       	ldi	r30, 0x20	; 32
     ee0:	f0 e0       	ldi	r31, 0x00	; 0
     ee2:	80 81       	ld	r24, Z
     ee4:	82 95       	swap	r24
     ee6:	80 7f       	andi	r24, 0xF0	; 240
     ee8:	89 83       	std	Y+1, r24	; 0x01
        lcd_e_low();
     eea:	a2 e2       	ldi	r26, 0x22	; 34
     eec:	b0 e0       	ldi	r27, 0x00	; 0
     eee:	e2 e2       	ldi	r30, 0x22	; 34
     ef0:	f0 e0       	ldi	r31, 0x00	; 0
     ef2:	80 81       	ld	r24, Z
     ef4:	8f 7b       	andi	r24, 0xBF	; 191
     ef6:	8c 93       	st	X, r24
        
        lcd_e_delay();                       /* Enable 500ns low       */
     ef8:	00 c0       	rjmp	.+0      	; 0xefa <lcd_read+0x78>
        
        lcd_e_high();
     efa:	a2 e2       	ldi	r26, 0x22	; 34
     efc:	b0 e0       	ldi	r27, 0x00	; 0
     efe:	e2 e2       	ldi	r30, 0x22	; 34
     f00:	f0 e0       	ldi	r31, 0x00	; 0
     f02:	80 81       	ld	r24, Z
     f04:	80 64       	ori	r24, 0x40	; 64
     f06:	8c 93       	st	X, r24
        lcd_e_delay();
     f08:	00 c0       	rjmp	.+0      	; 0xf0a <lcd_read+0x88>
        data |= PIN(LCD_DATA0_PORT)&0x0F;    /* read low nibble        */
     f0a:	e0 e2       	ldi	r30, 0x20	; 32
     f0c:	f0 e0       	ldi	r31, 0x00	; 0
     f0e:	80 81       	ld	r24, Z
     f10:	98 2f       	mov	r25, r24
     f12:	9f 70       	andi	r25, 0x0F	; 15
     f14:	89 81       	ldd	r24, Y+1	; 0x01
     f16:	89 2b       	or	r24, r25
     f18:	89 83       	std	Y+1, r24	; 0x01
        lcd_e_low();
     f1a:	a2 e2       	ldi	r26, 0x22	; 34
     f1c:	b0 e0       	ldi	r27, 0x00	; 0
     f1e:	e2 e2       	ldi	r30, 0x22	; 34
     f20:	f0 e0       	ldi	r31, 0x00	; 0
     f22:	80 81       	ld	r24, Z
     f24:	8f 7b       	andi	r24, 0xBF	; 191
     f26:	8c 93       	st	X, r24
        if ( PIN(LCD_DATA1_PORT) & _BV(LCD_DATA1_PIN) ) data |= 0x02;
        if ( PIN(LCD_DATA2_PORT) & _BV(LCD_DATA2_PIN) ) data |= 0x04;
        if ( PIN(LCD_DATA3_PORT) & _BV(LCD_DATA3_PIN) ) data |= 0x08;        
        lcd_e_low();
    }
    return data;
     f28:	89 81       	ldd	r24, Y+1	; 0x01
}
     f2a:	0f 90       	pop	r0
     f2c:	0f 90       	pop	r0
     f2e:	cf 91       	pop	r28
     f30:	df 91       	pop	r29
     f32:	08 95       	ret

00000f34 <lcd_waitbusy>:
/*************************************************************************
loops while lcd is busy, returns address counter
*************************************************************************/
static uint8_t lcd_waitbusy(void)

{
     f34:	df 93       	push	r29
     f36:	cf 93       	push	r28
     f38:	cd b7       	in	r28, 0x3d	; 61
     f3a:	de b7       	in	r29, 0x3e	; 62
    register uint8_t c;
    
    /* wait until busy flag is cleared */
    while ( (c=lcd_read(0)) & (1<<LCD_BUSY)) {}
     f3c:	80 e0       	ldi	r24, 0x00	; 0
     f3e:	0e 94 41 07 	call	0xe82	; 0xe82 <lcd_read>
     f42:	88 23       	and	r24, r24
     f44:	dc f3       	brlt	.-10     	; 0xf3c <lcd_waitbusy+0x8>
    
    /* the address counter is updated 4us after the busy flag is cleared */
    delay(2);
     f46:	84 e0       	ldi	r24, 0x04	; 4
     f48:	90 e0       	ldi	r25, 0x00	; 0
     f4a:	0e 94 ad 07 	call	0xf5a	; 0xf5a <_delayFourCycles>

    /* now read the address counter */
    return (lcd_read(0));  // return address counter
     f4e:	80 e0       	ldi	r24, 0x00	; 0
     f50:	0e 94 41 07 	call	0xe82	; 0xe82 <lcd_read>
    
}/* lcd_waitbusy */
     f54:	cf 91       	pop	r28
     f56:	df 91       	pop	r29
     f58:	08 95       	ret

00000f5a <_delayFourCycles>:

/*************************************************************************
 delay loop for small accurate delays: 16-bit counter, 4 cycles/loop
*************************************************************************/
static inline void _delayFourCycles(unsigned int __count)
{
     f5a:	df 93       	push	r29
     f5c:	cf 93       	push	r28
     f5e:	00 d0       	rcall	.+0      	; 0xf60 <_delayFourCycles+0x6>
     f60:	cd b7       	in	r28, 0x3d	; 61
     f62:	de b7       	in	r29, 0x3e	; 62
     f64:	9a 83       	std	Y+2, r25	; 0x02
     f66:	89 83       	std	Y+1, r24	; 0x01
    if ( __count == 0 )    
     f68:	89 81       	ldd	r24, Y+1	; 0x01
     f6a:	9a 81       	ldd	r25, Y+2	; 0x02
     f6c:	00 97       	sbiw	r24, 0x00	; 0
     f6e:	11 f4       	brne	.+4      	; 0xf74 <_delayFourCycles+0x1a>
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
     f70:	00 c0       	rjmp	.+0      	; 0xf72 <_delayFourCycles+0x18>
     f72:	06 c0       	rjmp	.+12     	; 0xf80 <_delayFourCycles+0x26>
    else
        __asm__ __volatile__ (
     f74:	89 81       	ldd	r24, Y+1	; 0x01
     f76:	9a 81       	ldd	r25, Y+2	; 0x02
     f78:	01 97       	sbiw	r24, 0x01	; 1
     f7a:	f1 f7       	brne	.-4      	; 0xf78 <_delayFourCycles+0x1e>
     f7c:	9a 83       	std	Y+2, r25	; 0x02
     f7e:	89 83       	std	Y+1, r24	; 0x01
    	    "1: sbiw %0,1" "\n\t"                  
    	    "brne 1b"                              // 4 cycles/loop
    	    : "=w" (__count)
    	    : "0" (__count)
    	   );
}
     f80:	0f 90       	pop	r0
     f82:	0f 90       	pop	r0
     f84:	cf 91       	pop	r28
     f86:	df 91       	pop	r29
     f88:	08 95       	ret

00000f8a <lcd_command>:
Send LCD controller instruction command
Input:   instruction to send to LCD controller, see HD44780 data sheet
Returns: none
*************************************************************************/
void lcd_command(uint8_t cmd)
{
     f8a:	df 93       	push	r29
     f8c:	cf 93       	push	r28
     f8e:	0f 92       	push	r0
     f90:	cd b7       	in	r28, 0x3d	; 61
     f92:	de b7       	in	r29, 0x3e	; 62
     f94:	89 83       	std	Y+1, r24	; 0x01
    lcd_waitbusy();
     f96:	0e 94 9a 07 	call	0xf34	; 0xf34 <lcd_waitbusy>
    lcd_write(cmd,0);
     f9a:	89 81       	ldd	r24, Y+1	; 0x01
     f9c:	60 e0       	ldi	r22, 0x00	; 0
     f9e:	0e 94 f4 06 	call	0xde8	; 0xde8 <lcd_write>
}
     fa2:	0f 90       	pop	r0
     fa4:	cf 91       	pop	r28
     fa6:	df 91       	pop	r29
     fa8:	08 95       	ret

00000faa <lcd_data>:
Send data byte to LCD controller 
Input:   data to send to LCD controller, see HD44780 data sheet
Returns: none
*************************************************************************/
void lcd_data(uint8_t data)
{
     faa:	df 93       	push	r29
     fac:	cf 93       	push	r28
     fae:	0f 92       	push	r0
     fb0:	cd b7       	in	r28, 0x3d	; 61
     fb2:	de b7       	in	r29, 0x3e	; 62
     fb4:	89 83       	std	Y+1, r24	; 0x01
    lcd_waitbusy();
     fb6:	0e 94 9a 07 	call	0xf34	; 0xf34 <lcd_waitbusy>
    lcd_write(data,1);
     fba:	89 81       	ldd	r24, Y+1	; 0x01
     fbc:	61 e0       	ldi	r22, 0x01	; 1
     fbe:	0e 94 f4 06 	call	0xde8	; 0xde8 <lcd_write>
}
     fc2:	0f 90       	pop	r0
     fc4:	cf 91       	pop	r28
     fc6:	df 91       	pop	r29
     fc8:	08 95       	ret

00000fca <lcd_gotoxy>:
Input:    x  horizontal position  (0: left most position)
          y  vertical position    (0: first line)
Returns:  none
*************************************************************************/
void lcd_gotoxy(uint8_t x, uint8_t y)
{
     fca:	df 93       	push	r29
     fcc:	cf 93       	push	r28
     fce:	00 d0       	rcall	.+0      	; 0xfd0 <lcd_gotoxy+0x6>
     fd0:	cd b7       	in	r28, 0x3d	; 61
     fd2:	de b7       	in	r29, 0x3e	; 62
     fd4:	89 83       	std	Y+1, r24	; 0x01
     fd6:	6a 83       	std	Y+2, r22	; 0x02
#if LCD_LINES==1
    lcd_command((1<<LCD_DDRAM)+LCD_START_LINE1+x);
#endif
#if LCD_LINES==2
    if ( y==0 ) 
     fd8:	8a 81       	ldd	r24, Y+2	; 0x02
     fda:	88 23       	and	r24, r24
     fdc:	29 f4       	brne	.+10     	; 0xfe8 <lcd_gotoxy+0x1e>
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE1+x);
     fde:	89 81       	ldd	r24, Y+1	; 0x01
     fe0:	80 58       	subi	r24, 0x80	; 128
     fe2:	0e 94 c5 07 	call	0xf8a	; 0xf8a <lcd_command>
     fe6:	04 c0       	rjmp	.+8      	; 0xff0 <lcd_gotoxy+0x26>
    else
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE2+x);
     fe8:	89 81       	ldd	r24, Y+1	; 0x01
     fea:	80 54       	subi	r24, 0x40	; 64
     fec:	0e 94 c5 07 	call	0xf8a	; 0xf8a <lcd_command>
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE3+x);
    else /* y==3 */
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE4+x);
#endif

}/* lcd_gotoxy */
     ff0:	0f 90       	pop	r0
     ff2:	0f 90       	pop	r0
     ff4:	cf 91       	pop	r28
     ff6:	df 91       	pop	r29
     ff8:	08 95       	ret

00000ffa <lcd_getxy>:


/*************************************************************************
*************************************************************************/
int lcd_getxy(void)
{
     ffa:	df 93       	push	r29
     ffc:	cf 93       	push	r28
     ffe:	cd b7       	in	r28, 0x3d	; 61
    1000:	de b7       	in	r29, 0x3e	; 62
    return lcd_waitbusy();
    1002:	0e 94 9a 07 	call	0xf34	; 0xf34 <lcd_waitbusy>
    1006:	88 2f       	mov	r24, r24
    1008:	90 e0       	ldi	r25, 0x00	; 0
}
    100a:	cf 91       	pop	r28
    100c:	df 91       	pop	r29
    100e:	08 95       	ret

00001010 <lcd_clrscr>:

/*************************************************************************
Clear display and set cursor to home position
*************************************************************************/
void lcd_clrscr(void)
{
    1010:	df 93       	push	r29
    1012:	cf 93       	push	r28
    1014:	cd b7       	in	r28, 0x3d	; 61
    1016:	de b7       	in	r29, 0x3e	; 62
    lcd_command(1<<LCD_CLR);
    1018:	81 e0       	ldi	r24, 0x01	; 1
    101a:	0e 94 c5 07 	call	0xf8a	; 0xf8a <lcd_command>
}
    101e:	cf 91       	pop	r28
    1020:	df 91       	pop	r29
    1022:	08 95       	ret

00001024 <lcd_home>:

/*************************************************************************
Set cursor to home position
*************************************************************************/
void lcd_home(void)
{
    1024:	df 93       	push	r29
    1026:	cf 93       	push	r28
    1028:	cd b7       	in	r28, 0x3d	; 61
    102a:	de b7       	in	r29, 0x3e	; 62
    lcd_command(1<<LCD_HOME);
    102c:	82 e0       	ldi	r24, 0x02	; 2
    102e:	0e 94 c5 07 	call	0xf8a	; 0xf8a <lcd_command>
}
    1032:	cf 91       	pop	r28
    1034:	df 91       	pop	r29
    1036:	08 95       	ret

00001038 <lcd_putc>:
Display character at current cursor position 
Input:    character to be displayed                                       
Returns:  none
*************************************************************************/
void lcd_putc(char c)
{
    1038:	df 93       	push	r29
    103a:	cf 93       	push	r28
    103c:	00 d0       	rcall	.+0      	; 0x103e <lcd_putc+0x6>
    103e:	cd b7       	in	r28, 0x3d	; 61
    1040:	de b7       	in	r29, 0x3e	; 62
    1042:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t pos;


    pos = lcd_waitbusy();   // read busy-flag and address counter
    1044:	0e 94 9a 07 	call	0xf34	; 0xf34 <lcd_waitbusy>
    1048:	89 83       	std	Y+1, r24	; 0x01
    if (c=='\n')
    104a:	8a 81       	ldd	r24, Y+2	; 0x02
    104c:	8a 30       	cpi	r24, 0x0A	; 10
    104e:	21 f4       	brne	.+8      	; 0x1058 <lcd_putc+0x20>
    {
        lcd_newline(pos);
    1050:	89 81       	ldd	r24, Y+1	; 0x01
    1052:	0e 94 35 08 	call	0x106a	; 0x106a <lcd_newline>
    1056:	04 c0       	rjmp	.+8      	; 0x1060 <lcd_putc+0x28>
            lcd_write((1<<LCD_DDRAM)+LCD_START_LINE1,0);
        }
#endif
        lcd_waitbusy();
#endif
        lcd_write(c, 1);
    1058:	8a 81       	ldd	r24, Y+2	; 0x02
    105a:	61 e0       	ldi	r22, 0x01	; 1
    105c:	0e 94 f4 06 	call	0xde8	; 0xde8 <lcd_write>
    }

}/* lcd_putc */
    1060:	0f 90       	pop	r0
    1062:	0f 90       	pop	r0
    1064:	cf 91       	pop	r28
    1066:	df 91       	pop	r29
    1068:	08 95       	ret

0000106a <lcd_newline>:
/*************************************************************************
Move cursor to the start of next line or to the first line if the cursor 
is already on the last line.
*************************************************************************/
static inline void lcd_newline(uint8_t pos)
{
    106a:	df 93       	push	r29
    106c:	cf 93       	push	r28
    106e:	00 d0       	rcall	.+0      	; 0x1070 <lcd_newline+0x6>
    1070:	cd b7       	in	r28, 0x3d	; 61
    1072:	de b7       	in	r29, 0x3e	; 62
    1074:	89 83       	std	Y+1, r24	; 0x01

#if LCD_LINES==1
    addressCounter = 0;
#endif
#if LCD_LINES==2
    if ( pos < (LCD_START_LINE2) )
    1076:	89 81       	ldd	r24, Y+1	; 0x01
    1078:	80 34       	cpi	r24, 0x40	; 64
    107a:	18 f4       	brcc	.+6      	; 0x1082 <lcd_newline+0x18>
        addressCounter = LCD_START_LINE2;
    107c:	80 e4       	ldi	r24, 0x40	; 64
    107e:	8a 83       	std	Y+2, r24	; 0x02
    1080:	01 c0       	rjmp	.+2      	; 0x1084 <lcd_newline+0x1a>
    else
        addressCounter = LCD_START_LINE1;
    1082:	1a 82       	std	Y+2, r1	; 0x02
        addressCounter = LCD_START_LINE4;
    else 
        addressCounter = LCD_START_LINE1;
#endif
#endif
    lcd_command((1<<LCD_DDRAM)+addressCounter);
    1084:	8a 81       	ldd	r24, Y+2	; 0x02
    1086:	80 58       	subi	r24, 0x80	; 128
    1088:	0e 94 c5 07 	call	0xf8a	; 0xf8a <lcd_command>

}/* lcd_newline */
    108c:	0f 90       	pop	r0
    108e:	0f 90       	pop	r0
    1090:	cf 91       	pop	r28
    1092:	df 91       	pop	r29
    1094:	08 95       	ret

00001096 <lcd_puts>:
Input:    string to be displayed
Returns:  none
*************************************************************************/
void lcd_puts(const char *s)
/* print string on lcd (no auto linefeed) */
{
    1096:	df 93       	push	r29
    1098:	cf 93       	push	r28
    109a:	00 d0       	rcall	.+0      	; 0x109c <lcd_puts+0x6>
    109c:	00 d0       	rcall	.+0      	; 0x109e <lcd_puts+0x8>
    109e:	cd b7       	in	r28, 0x3d	; 61
    10a0:	de b7       	in	r29, 0x3e	; 62
    10a2:	9a 83       	std	Y+2, r25	; 0x02
    10a4:	89 83       	std	Y+1, r24	; 0x01
    10a6:	03 c0       	rjmp	.+6      	; 0x10ae <lcd_puts+0x18>
    register char c;

    while ( (c = *s++) ) {
        lcd_putc(c);
    10a8:	8b 81       	ldd	r24, Y+3	; 0x03
    10aa:	0e 94 1c 08 	call	0x1038	; 0x1038 <lcd_putc>
void lcd_puts(const char *s)
/* print string on lcd (no auto linefeed) */
{
    register char c;

    while ( (c = *s++) ) {
    10ae:	e9 81       	ldd	r30, Y+1	; 0x01
    10b0:	fa 81       	ldd	r31, Y+2	; 0x02
    10b2:	80 81       	ld	r24, Z
    10b4:	8b 83       	std	Y+3, r24	; 0x03
    10b6:	8b 81       	ldd	r24, Y+3	; 0x03
    10b8:	8c 83       	std	Y+4, r24	; 0x04
    10ba:	8c 81       	ldd	r24, Y+4	; 0x04
    10bc:	88 23       	and	r24, r24
    10be:	11 f0       	breq	.+4      	; 0x10c4 <lcd_puts+0x2e>
    10c0:	81 e0       	ldi	r24, 0x01	; 1
    10c2:	8c 83       	std	Y+4, r24	; 0x04
    10c4:	8c 81       	ldd	r24, Y+4	; 0x04
    10c6:	29 81       	ldd	r18, Y+1	; 0x01
    10c8:	3a 81       	ldd	r19, Y+2	; 0x02
    10ca:	2f 5f       	subi	r18, 0xFF	; 255
    10cc:	3f 4f       	sbci	r19, 0xFF	; 255
    10ce:	3a 83       	std	Y+2, r19	; 0x02
    10d0:	29 83       	std	Y+1, r18	; 0x01
    10d2:	88 23       	and	r24, r24
    10d4:	49 f7       	brne	.-46     	; 0x10a8 <lcd_puts+0x12>
        lcd_putc(c);
    }

}/* lcd_puts */
    10d6:	0f 90       	pop	r0
    10d8:	0f 90       	pop	r0
    10da:	0f 90       	pop	r0
    10dc:	0f 90       	pop	r0
    10de:	cf 91       	pop	r28
    10e0:	df 91       	pop	r29
    10e2:	08 95       	ret

000010e4 <lcd_puts_p>:
Input:     string from program memory be be displayed                                        
Returns:   none
*************************************************************************/
void lcd_puts_p(const char *progmem_s)
/* print string from program memory on lcd (no auto linefeed) */
{
    10e4:	df 93       	push	r29
    10e6:	cf 93       	push	r28
    10e8:	00 d0       	rcall	.+0      	; 0x10ea <lcd_puts_p+0x6>
    10ea:	00 d0       	rcall	.+0      	; 0x10ec <lcd_puts_p+0x8>
    10ec:	00 d0       	rcall	.+0      	; 0x10ee <lcd_puts_p+0xa>
    10ee:	cd b7       	in	r28, 0x3d	; 61
    10f0:	de b7       	in	r29, 0x3e	; 62
    10f2:	9d 83       	std	Y+5, r25	; 0x05
    10f4:	8c 83       	std	Y+4, r24	; 0x04
    10f6:	03 c0       	rjmp	.+6      	; 0x10fe <lcd_puts_p+0x1a>
    register char c;

    while ( (c = pgm_read_byte(progmem_s++)) ) {
        lcd_putc(c);
    10f8:	8e 81       	ldd	r24, Y+6	; 0x06
    10fa:	0e 94 1c 08 	call	0x1038	; 0x1038 <lcd_putc>
void lcd_puts_p(const char *progmem_s)
/* print string from program memory on lcd (no auto linefeed) */
{
    register char c;

    while ( (c = pgm_read_byte(progmem_s++)) ) {
    10fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1100:	9d 81       	ldd	r25, Y+5	; 0x05
    1102:	9b 83       	std	Y+3, r25	; 0x03
    1104:	8a 83       	std	Y+2, r24	; 0x02
    1106:	8c 81       	ldd	r24, Y+4	; 0x04
    1108:	9d 81       	ldd	r25, Y+5	; 0x05
    110a:	01 96       	adiw	r24, 0x01	; 1
    110c:	9d 83       	std	Y+5, r25	; 0x05
    110e:	8c 83       	std	Y+4, r24	; 0x04
    1110:	ea 81       	ldd	r30, Y+2	; 0x02
    1112:	fb 81       	ldd	r31, Y+3	; 0x03
    1114:	84 91       	lpm	r24, Z+
    1116:	89 83       	std	Y+1, r24	; 0x01
    1118:	89 81       	ldd	r24, Y+1	; 0x01
    111a:	8e 83       	std	Y+6, r24	; 0x06
    111c:	8e 81       	ldd	r24, Y+6	; 0x06
    111e:	88 23       	and	r24, r24
    1120:	59 f7       	brne	.-42     	; 0x10f8 <lcd_puts_p+0x14>
        lcd_putc(c);
    }

}/* lcd_puts_p */
    1122:	26 96       	adiw	r28, 0x06	; 6
    1124:	0f b6       	in	r0, 0x3f	; 63
    1126:	f8 94       	cli
    1128:	de bf       	out	0x3e, r29	; 62
    112a:	0f be       	out	0x3f, r0	; 63
    112c:	cd bf       	out	0x3d, r28	; 61
    112e:	cf 91       	pop	r28
    1130:	df 91       	pop	r29
    1132:	08 95       	ret

00001134 <lcd_init>:
                   LCD_DISP_ON_CURSOR      display on, cursor on
                   LCD_DISP_CURSOR_BLINK   display on, cursor on flashing
Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
    1134:	df 93       	push	r29
    1136:	cf 93       	push	r28
    1138:	0f 92       	push	r0
    113a:	cd b7       	in	r28, 0x3d	; 61
    113c:	de b7       	in	r29, 0x3e	; 62
    113e:	89 83       	std	Y+1, r24	; 0x01
      && ( &LCD_RS_PORT == &LCD_DATA0_PORT) && ( &LCD_RW_PORT == &LCD_DATA0_PORT) && (&LCD_E_PORT == &LCD_DATA0_PORT)
      && (LCD_DATA0_PIN == 0 ) && (LCD_DATA1_PIN == 1) && (LCD_DATA2_PIN == 2) && (LCD_DATA3_PIN == 3) 
      && (LCD_RS_PIN == 4 ) && (LCD_RW_PIN == 5) && (LCD_E_PIN == 6 ) )
    {
        /* configure all port bits as output (all LCD lines on same port) */
        DDR(LCD_DATA0_PORT) |= 0x7F;
    1140:	a1 e2       	ldi	r26, 0x21	; 33
    1142:	b0 e0       	ldi	r27, 0x00	; 0
    1144:	e1 e2       	ldi	r30, 0x21	; 33
    1146:	f0 e0       	ldi	r31, 0x00	; 0
    1148:	80 81       	ld	r24, Z
    114a:	8f 67       	ori	r24, 0x7F	; 127
    114c:	8c 93       	st	X, r24
        DDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);
        DDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);
        DDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
    }
    delay(16000);        /* wait 16ms or more after power-on       */
    114e:	80 e0       	ldi	r24, 0x00	; 0
    1150:	9d e7       	ldi	r25, 0x7D	; 125
    1152:	0e 94 ad 07 	call	0xf5a	; 0xf5a <_delayFourCycles>
    
    /* initial write to lcd is 8bit */
    LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);  // _BV(LCD_FUNCTION)>>4;
    1156:	a2 e2       	ldi	r26, 0x22	; 34
    1158:	b0 e0       	ldi	r27, 0x00	; 0
    115a:	e2 e2       	ldi	r30, 0x22	; 34
    115c:	f0 e0       	ldi	r31, 0x00	; 0
    115e:	80 81       	ld	r24, Z
    1160:	82 60       	ori	r24, 0x02	; 2
    1162:	8c 93       	st	X, r24
    LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);  // _BV(LCD_FUNCTION_8BIT)>>4;
    1164:	a2 e2       	ldi	r26, 0x22	; 34
    1166:	b0 e0       	ldi	r27, 0x00	; 0
    1168:	e2 e2       	ldi	r30, 0x22	; 34
    116a:	f0 e0       	ldi	r31, 0x00	; 0
    116c:	80 81       	ld	r24, Z
    116e:	81 60       	ori	r24, 0x01	; 1
    1170:	8c 93       	st	X, r24
    lcd_e_toggle();
    1172:	0e 94 de 06 	call	0xdbc	; 0xdbc <toggle_e>
    delay(4992);         /* delay, busy flag can't be checked here */
    1176:	80 e0       	ldi	r24, 0x00	; 0
    1178:	97 e2       	ldi	r25, 0x27	; 39
    117a:	0e 94 ad 07 	call	0xf5a	; 0xf5a <_delayFourCycles>
   
    /* repeat last command */ 
    lcd_e_toggle();      
    117e:	0e 94 de 06 	call	0xdbc	; 0xdbc <toggle_e>
    delay(64);           /* delay, busy flag can't be checked here */
    1182:	80 e8       	ldi	r24, 0x80	; 128
    1184:	90 e0       	ldi	r25, 0x00	; 0
    1186:	0e 94 ad 07 	call	0xf5a	; 0xf5a <_delayFourCycles>
    
    /* repeat last command a third time */
    lcd_e_toggle();      
    118a:	0e 94 de 06 	call	0xdbc	; 0xdbc <toggle_e>
    delay(64);           /* delay, busy flag can't be checked here */
    118e:	80 e8       	ldi	r24, 0x80	; 128
    1190:	90 e0       	ldi	r25, 0x00	; 0
    1192:	0e 94 ad 07 	call	0xf5a	; 0xf5a <_delayFourCycles>

    /* now configure for 4bit mode */
    LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);   // LCD_FUNCTION_4BIT_1LINE>>4
    1196:	a2 e2       	ldi	r26, 0x22	; 34
    1198:	b0 e0       	ldi	r27, 0x00	; 0
    119a:	e2 e2       	ldi	r30, 0x22	; 34
    119c:	f0 e0       	ldi	r31, 0x00	; 0
    119e:	80 81       	ld	r24, Z
    11a0:	8e 7f       	andi	r24, 0xFE	; 254
    11a2:	8c 93       	st	X, r24
    lcd_e_toggle();
    11a4:	0e 94 de 06 	call	0xdbc	; 0xdbc <toggle_e>
    delay(64);           /* some displays need this additional delay */
    11a8:	80 e8       	ldi	r24, 0x80	; 128
    11aa:	90 e0       	ldi	r25, 0x00	; 0
    11ac:	0e 94 ad 07 	call	0xf5a	; 0xf5a <_delayFourCycles>
    /* Display with KS0073 controller requires special commands for enabling 4 line mode */
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_ON);
	lcd_command(KS0073_4LINES_MODE);
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_OFF);
#else
    lcd_command(LCD_FUNCTION_DEFAULT);      /* function set: display lines  */
    11b0:	88 e2       	ldi	r24, 0x28	; 40
    11b2:	0e 94 c5 07 	call	0xf8a	; 0xf8a <lcd_command>
#endif
    lcd_command(LCD_DISP_OFF);              /* display off                  */
    11b6:	88 e0       	ldi	r24, 0x08	; 8
    11b8:	0e 94 c5 07 	call	0xf8a	; 0xf8a <lcd_command>
    lcd_clrscr();                           /* display clear                */ 
    11bc:	0e 94 08 08 	call	0x1010	; 0x1010 <lcd_clrscr>
    lcd_command(LCD_MODE_DEFAULT);          /* set entry mode               */
    11c0:	86 e0       	ldi	r24, 0x06	; 6
    11c2:	0e 94 c5 07 	call	0xf8a	; 0xf8a <lcd_command>
    lcd_command(dispAttr);                  /* display/cursor control       */
    11c6:	89 81       	ldd	r24, Y+1	; 0x01
    11c8:	0e 94 c5 07 	call	0xf8a	; 0xf8a <lcd_command>

}/* lcd_init */
    11cc:	0f 90       	pop	r0
    11ce:	cf 91       	pop	r28
    11d0:	df 91       	pop	r29
    11d2:	08 95       	ret

000011d4 <execute>:
//    return(0);
//	
//}
//
uint16_t execute(char option, BYTE volume)
{
    11d4:	df 93       	push	r29
    11d6:	cf 93       	push	r28
    11d8:	00 d0       	rcall	.+0      	; 0x11da <execute+0x6>
    11da:	00 d0       	rcall	.+0      	; 0x11dc <execute+0x8>
    11dc:	cd b7       	in	r28, 0x3d	; 61
    11de:	de b7       	in	r29, 0x3e	; 62
    11e0:	89 83       	std	Y+1, r24	; 0x01
    11e2:	6a 83       	std	Y+2, r22	; 0x02
	//Runs functions based on the user value input through the serial port
	
	if(option == '1')
    11e4:	89 81       	ldd	r24, Y+1	; 0x01
    11e6:	81 33       	cpi	r24, 0x31	; 49
    11e8:	a1 f4       	brne	.+40     	; 0x1212 <execute+0x3e>
	{
		printf("\n\n\tSending Array Values\n");
    11ea:	8b e3       	ldi	r24, 0x3B	; 59
    11ec:	92 e0       	ldi	r25, 0x02	; 2
    11ee:	0e 94 ab 12 	call	0x2556	; 0x2556 <puts>
		lcd_gotoxy(0,1);
    11f2:	80 e0       	ldi	r24, 0x00	; 0
    11f4:	61 e0       	ldi	r22, 0x01	; 1
    11f6:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
		lcd_puts("1 Sending values");
    11fa:	83 e5       	ldi	r24, 0x53	; 83
    11fc:	92 e0       	ldi	r25, 0x02	; 2
    11fe:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>
        send_all_regs(register_values);
    1202:	87 e1       	ldi	r24, 0x17	; 23
    1204:	92 e0       	ldi	r25, 0x02	; 2
    1206:	0e 94 71 11 	call	0x22e2	; 0x22e2 <send_all_regs>
        printf("\n\t\tDone\n");
    120a:	84 e6       	ldi	r24, 0x64	; 100
    120c:	92 e0       	ldi	r25, 0x02	; 2
    120e:	0e 94 ab 12 	call	0x2556	; 0x2556 <puts>
	};
	
	if(option == '2')
    1212:	89 81       	ldd	r24, Y+1	; 0x01
    1214:	82 33       	cpi	r24, 0x32	; 50
    1216:	51 f4       	brne	.+20     	; 0x122c <execute+0x58>
	{
		lcd_gotoxy(0,1);
    1218:	80 e0       	ldi	r24, 0x00	; 0
    121a:	61 e0       	ldi	r22, 0x01	; 1
    121c:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
		lcd_puts("2 Printing array");
    1220:	8c e6       	ldi	r24, 0x6C	; 108
    1222:	92 e0       	ldi	r25, 0x02	; 2
    1224:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>

		print_array();
    1228:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <print_array>
	};
	
	if(option == '3')	
    122c:	89 81       	ldd	r24, Y+1	; 0x01
    122e:	83 33       	cpi	r24, 0x33	; 51
    1230:	59 f4       	brne	.+22     	; 0x1248 <execute+0x74>
    {
		lcd_gotoxy(0,1);
    1232:	80 e0       	ldi	r24, 0x00	; 0
    1234:	61 e0       	ldi	r22, 0x01	; 1
    1236:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
		lcd_puts("3 Set array opt ");
    123a:	8d e7       	ldi	r24, 0x7D	; 125
    123c:	92 e0       	ldi	r25, 0x02	; 2
    123e:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>
		set_array_value(option);
    1242:	89 81       	ldd	r24, Y+1	; 0x01
    1244:	0e 94 46 0d 	call	0x1a8c	; 0x1a8c <set_array_value>
	};
	
	if(option == '4')
    1248:	89 81       	ldd	r24, Y+1	; 0x01
    124a:	84 33       	cpi	r24, 0x34	; 52
    124c:	71 f4       	brne	.+28     	; 0x126a <execute+0x96>
	{
		printf("\n\n\tRead All\n");
    124e:	8e e8       	ldi	r24, 0x8E	; 142
    1250:	92 e0       	ldi	r25, 0x02	; 2
    1252:	0e 94 ab 12 	call	0x2556	; 0x2556 <puts>
		lcd_gotoxy(0,1);
    1256:	80 e0       	ldi	r24, 0x00	; 0
    1258:	61 e0       	ldi	r22, 0x01	; 1
    125a:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
		lcd_puts("4 Read all      ");
    125e:	8a e9       	ldi	r24, 0x9A	; 154
    1260:	92 e0       	ldi	r25, 0x02	; 2
    1262:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>

        ar1000readall();
    1266:	0e 94 1a 11 	call	0x2234	; 0x2234 <ar1000readall>
	};
	
	if(option == '5')
    126a:	89 81       	ldd	r24, Y+1	; 0x01
    126c:	85 33       	cpi	r24, 0x35	; 53
    126e:	71 f4       	brne	.+28     	; 0x128c <execute+0xb8>
	{
		lcd_gotoxy(0,1);
    1270:	80 e0       	ldi	r24, 0x00	; 0
    1272:	61 e0       	ldi	r22, 0x01	; 1
    1274:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
		lcd_puts("5 Seek Up       ");
    1278:	8b ea       	ldi	r24, 0xAB	; 171
    127a:	92 e0       	ldi	r25, 0x02	; 2
    127c:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>

		return seek(SEEK_DIR_UP);
    1280:	81 e0       	ldi	r24, 0x01	; 1
    1282:	0e 94 2d 0a 	call	0x145a	; 0x145a <seek>
    1286:	9c 83       	std	Y+4, r25	; 0x04
    1288:	8b 83       	std	Y+3, r24	; 0x03
    128a:	c6 c0       	rjmp	.+396    	; 0x1418 <execute+0x244>
	};

	if(option == '6')
    128c:	89 81       	ldd	r24, Y+1	; 0x01
    128e:	86 33       	cpi	r24, 0x36	; 54
    1290:	71 f4       	brne	.+28     	; 0x12ae <execute+0xda>
	{
		lcd_gotoxy(0,1);
    1292:	80 e0       	ldi	r24, 0x00	; 0
    1294:	61 e0       	ldi	r22, 0x01	; 1
    1296:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
		lcd_puts("6 Seek Down     ");
    129a:	8c eb       	ldi	r24, 0xBC	; 188
    129c:	92 e0       	ldi	r25, 0x02	; 2
    129e:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>

		return seek(SEEK_DIR_DOWN);
    12a2:	80 e0       	ldi	r24, 0x00	; 0
    12a4:	0e 94 2d 0a 	call	0x145a	; 0x145a <seek>
    12a8:	9c 83       	std	Y+4, r25	; 0x04
    12aa:	8b 83       	std	Y+3, r24	; 0x03
    12ac:	b5 c0       	rjmp	.+362    	; 0x1418 <execute+0x244>
	};

	if(option == '7')
    12ae:	89 81       	ldd	r24, Y+1	; 0x01
    12b0:	87 33       	cpi	r24, 0x37	; 55
    12b2:	a1 f4       	brne	.+40     	; 0x12dc <execute+0x108>
	{
		printf("\n\n\tCalibrating\n");
    12b4:	8d ec       	ldi	r24, 0xCD	; 205
    12b6:	92 e0       	ldi	r25, 0x02	; 2
    12b8:	0e 94 ab 12 	call	0x2556	; 0x2556 <puts>
		lcd_gotoxy(0,1);
    12bc:	80 e0       	ldi	r24, 0x00	; 0
    12be:	61 e0       	ldi	r22, 0x01	; 1
    12c0:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
		lcd_puts("7 Calibrating       ");
    12c4:	8c ed       	ldi	r24, 0xDC	; 220
    12c6:	92 e0       	ldi	r25, 0x02	; 2
    12c8:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>
        ar1000calibration(register_values);
    12cc:	87 e1       	ldi	r24, 0x17	; 23
    12ce:	92 e0       	ldi	r25, 0x02	; 2
    12d0:	0e 94 b5 11 	call	0x236a	; 0x236a <ar1000calibration>
        printf("\n\t\tDone\n");
    12d4:	84 e6       	ldi	r24, 0x64	; 100
    12d6:	92 e0       	ldi	r25, 0x02	; 2
    12d8:	0e 94 ab 12 	call	0x2556	; 0x2556 <puts>
	};

	if(option == '8')
    12dc:	89 81       	ldd	r24, Y+1	; 0x01
    12de:	88 33       	cpi	r24, 0x38	; 56
    12e0:	b9 f5       	brne	.+110    	; 0x1350 <execute+0x17c>
	{
		printf("\n\n\tVolume up from %i\n", volume);
    12e2:	8a 81       	ldd	r24, Y+2	; 0x02
    12e4:	28 2f       	mov	r18, r24
    12e6:	30 e0       	ldi	r19, 0x00	; 0
    12e8:	00 d0       	rcall	.+0      	; 0x12ea <execute+0x116>
    12ea:	00 d0       	rcall	.+0      	; 0x12ec <execute+0x118>
    12ec:	ed b7       	in	r30, 0x3d	; 61
    12ee:	fe b7       	in	r31, 0x3e	; 62
    12f0:	31 96       	adiw	r30, 0x01	; 1
    12f2:	81 ef       	ldi	r24, 0xF1	; 241
    12f4:	92 e0       	ldi	r25, 0x02	; 2
    12f6:	91 83       	std	Z+1, r25	; 0x01
    12f8:	80 83       	st	Z, r24
    12fa:	33 83       	std	Z+3, r19	; 0x03
    12fc:	22 83       	std	Z+2, r18	; 0x02
    12fe:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1302:	0f 90       	pop	r0
    1304:	0f 90       	pop	r0
    1306:	0f 90       	pop	r0
    1308:	0f 90       	pop	r0
		if (volume < 16)
    130a:	8a 81       	ldd	r24, Y+2	; 0x02
    130c:	80 31       	cpi	r24, 0x10	; 16
    130e:	18 f4       	brcc	.+6      	; 0x1316 <execute+0x142>
			volume++;
    1310:	8a 81       	ldd	r24, Y+2	; 0x02
    1312:	8f 5f       	subi	r24, 0xFF	; 255
    1314:	8a 83       	std	Y+2, r24	; 0x02

		set_volume(volume);
    1316:	8a 81       	ldd	r24, Y+2	; 0x02
    1318:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <set_volume>
		printf("\n\n\tVolume set to %i\n", volume);
    131c:	8a 81       	ldd	r24, Y+2	; 0x02
    131e:	28 2f       	mov	r18, r24
    1320:	30 e0       	ldi	r19, 0x00	; 0
    1322:	00 d0       	rcall	.+0      	; 0x1324 <execute+0x150>
    1324:	00 d0       	rcall	.+0      	; 0x1326 <execute+0x152>
    1326:	ed b7       	in	r30, 0x3d	; 61
    1328:	fe b7       	in	r31, 0x3e	; 62
    132a:	31 96       	adiw	r30, 0x01	; 1
    132c:	87 e0       	ldi	r24, 0x07	; 7
    132e:	93 e0       	ldi	r25, 0x03	; 3
    1330:	91 83       	std	Z+1, r25	; 0x01
    1332:	80 83       	st	Z, r24
    1334:	33 83       	std	Z+3, r19	; 0x03
    1336:	22 83       	std	Z+2, r18	; 0x02
    1338:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    133c:	0f 90       	pop	r0
    133e:	0f 90       	pop	r0
    1340:	0f 90       	pop	r0
    1342:	0f 90       	pop	r0
		
		return (uint16_t) volume;
    1344:	8a 81       	ldd	r24, Y+2	; 0x02
    1346:	28 2f       	mov	r18, r24
    1348:	30 e0       	ldi	r19, 0x00	; 0
    134a:	3c 83       	std	Y+4, r19	; 0x04
    134c:	2b 83       	std	Y+3, r18	; 0x03
    134e:	64 c0       	rjmp	.+200    	; 0x1418 <execute+0x244>
	};

	if(option == '9')
    1350:	89 81       	ldd	r24, Y+1	; 0x01
    1352:	89 33       	cpi	r24, 0x39	; 57
    1354:	b9 f5       	brne	.+110    	; 0x13c4 <execute+0x1f0>
	{
		printf("\n\n\tVolume down from %i\n", volume);
    1356:	8a 81       	ldd	r24, Y+2	; 0x02
    1358:	28 2f       	mov	r18, r24
    135a:	30 e0       	ldi	r19, 0x00	; 0
    135c:	00 d0       	rcall	.+0      	; 0x135e <execute+0x18a>
    135e:	00 d0       	rcall	.+0      	; 0x1360 <execute+0x18c>
    1360:	ed b7       	in	r30, 0x3d	; 61
    1362:	fe b7       	in	r31, 0x3e	; 62
    1364:	31 96       	adiw	r30, 0x01	; 1
    1366:	8c e1       	ldi	r24, 0x1C	; 28
    1368:	93 e0       	ldi	r25, 0x03	; 3
    136a:	91 83       	std	Z+1, r25	; 0x01
    136c:	80 83       	st	Z, r24
    136e:	33 83       	std	Z+3, r19	; 0x03
    1370:	22 83       	std	Z+2, r18	; 0x02
    1372:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1376:	0f 90       	pop	r0
    1378:	0f 90       	pop	r0
    137a:	0f 90       	pop	r0
    137c:	0f 90       	pop	r0
		if (volume > 0)
    137e:	8a 81       	ldd	r24, Y+2	; 0x02
    1380:	88 23       	and	r24, r24
    1382:	19 f0       	breq	.+6      	; 0x138a <execute+0x1b6>
			volume--;
    1384:	8a 81       	ldd	r24, Y+2	; 0x02
    1386:	81 50       	subi	r24, 0x01	; 1
    1388:	8a 83       	std	Y+2, r24	; 0x02

		
		set_volume(volume);
    138a:	8a 81       	ldd	r24, Y+2	; 0x02
    138c:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <set_volume>
		printf("\n\n\tVolume set to %i\n", volume);
    1390:	8a 81       	ldd	r24, Y+2	; 0x02
    1392:	28 2f       	mov	r18, r24
    1394:	30 e0       	ldi	r19, 0x00	; 0
    1396:	00 d0       	rcall	.+0      	; 0x1398 <execute+0x1c4>
    1398:	00 d0       	rcall	.+0      	; 0x139a <execute+0x1c6>
    139a:	ed b7       	in	r30, 0x3d	; 61
    139c:	fe b7       	in	r31, 0x3e	; 62
    139e:	31 96       	adiw	r30, 0x01	; 1
    13a0:	87 e0       	ldi	r24, 0x07	; 7
    13a2:	93 e0       	ldi	r25, 0x03	; 3
    13a4:	91 83       	std	Z+1, r25	; 0x01
    13a6:	80 83       	st	Z, r24
    13a8:	33 83       	std	Z+3, r19	; 0x03
    13aa:	22 83       	std	Z+2, r18	; 0x02
    13ac:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    13b0:	0f 90       	pop	r0
    13b2:	0f 90       	pop	r0
    13b4:	0f 90       	pop	r0
    13b6:	0f 90       	pop	r0
		
		return (uint16_t) volume;
    13b8:	8a 81       	ldd	r24, Y+2	; 0x02
    13ba:	28 2f       	mov	r18, r24
    13bc:	30 e0       	ldi	r19, 0x00	; 0
    13be:	3c 83       	std	Y+4, r19	; 0x04
    13c0:	2b 83       	std	Y+3, r18	; 0x03
    13c2:	2a c0       	rjmp	.+84     	; 0x1418 <execute+0x244>
	};

	if(option == 'm')
    13c4:	89 81       	ldd	r24, Y+1	; 0x01
    13c6:	8d 36       	cpi	r24, 0x6D	; 109
    13c8:	89 f4       	brne	.+34     	; 0x13ec <execute+0x218>
	{
		printf("\n\n\tMute\n");
    13ca:	84 e3       	ldi	r24, 0x34	; 52
    13cc:	93 e0       	ldi	r25, 0x03	; 3
    13ce:	0e 94 ab 12 	call	0x2556	; 0x2556 <puts>
		
		PORTB &= ~(1<<PB1); // set PB1 = MUTE_N to 0
    13d2:	a5 e2       	ldi	r26, 0x25	; 37
    13d4:	b0 e0       	ldi	r27, 0x00	; 0
    13d6:	e5 e2       	ldi	r30, 0x25	; 37
    13d8:	f0 e0       	ldi	r31, 0x00	; 0
    13da:	80 81       	ld	r24, Z
    13dc:	8d 7f       	andi	r24, 0xFD	; 253
    13de:	8c 93       	st	X, r24
		
		return (uint16_t) volume;
    13e0:	8a 81       	ldd	r24, Y+2	; 0x02
    13e2:	28 2f       	mov	r18, r24
    13e4:	30 e0       	ldi	r19, 0x00	; 0
    13e6:	3c 83       	std	Y+4, r19	; 0x04
    13e8:	2b 83       	std	Y+3, r18	; 0x03
    13ea:	16 c0       	rjmp	.+44     	; 0x1418 <execute+0x244>
	};
	
	if(option == 'u')
    13ec:	89 81       	ldd	r24, Y+1	; 0x01
    13ee:	85 37       	cpi	r24, 0x75	; 117
    13f0:	89 f4       	brne	.+34     	; 0x1414 <execute+0x240>
	{
		printf("\n\n\tUnmute\n");
    13f2:	8c e3       	ldi	r24, 0x3C	; 60
    13f4:	93 e0       	ldi	r25, 0x03	; 3
    13f6:	0e 94 ab 12 	call	0x2556	; 0x2556 <puts>
		
		PORTB |= (1<<PB1); // set PB1 = MUTE_N to 1
    13fa:	a5 e2       	ldi	r26, 0x25	; 37
    13fc:	b0 e0       	ldi	r27, 0x00	; 0
    13fe:	e5 e2       	ldi	r30, 0x25	; 37
    1400:	f0 e0       	ldi	r31, 0x00	; 0
    1402:	80 81       	ld	r24, Z
    1404:	82 60       	ori	r24, 0x02	; 2
    1406:	8c 93       	st	X, r24
		
		return (uint16_t) volume;
    1408:	8a 81       	ldd	r24, Y+2	; 0x02
    140a:	28 2f       	mov	r18, r24
    140c:	30 e0       	ldi	r19, 0x00	; 0
    140e:	3c 83       	std	Y+4, r19	; 0x04
    1410:	2b 83       	std	Y+3, r18	; 0x03
    1412:	02 c0       	rjmp	.+4      	; 0x1418 <execute+0x244>
	};
	
	return 0;
    1414:	1c 82       	std	Y+4, r1	; 0x04
    1416:	1b 82       	std	Y+3, r1	; 0x03
    1418:	8b 81       	ldd	r24, Y+3	; 0x03
    141a:	9c 81       	ldd	r25, Y+4	; 0x04
		
}
    141c:	0f 90       	pop	r0
    141e:	0f 90       	pop	r0
    1420:	0f 90       	pop	r0
    1422:	0f 90       	pop	r0
    1424:	cf 91       	pop	r28
    1426:	df 91       	pop	r29
    1428:	08 95       	ret

0000142a <write_ar1000_word>:

void write_ar1000_word(uint8_t address)
{
    142a:	df 93       	push	r29
    142c:	cf 93       	push	r28
    142e:	0f 92       	push	r0
    1430:	cd b7       	in	r28, 0x3d	; 61
    1432:	de b7       	in	r29, 0x3e	; 62
    1434:	89 83       	std	Y+1, r24	; 0x01
	write_i2c_data(TUNER, address, 2, (BYTE *) (register_values+address));
    1436:	27 e1       	ldi	r18, 0x17	; 23
    1438:	32 e0       	ldi	r19, 0x02	; 2
    143a:	89 81       	ldd	r24, Y+1	; 0x01
    143c:	88 2f       	mov	r24, r24
    143e:	90 e0       	ldi	r25, 0x00	; 0
    1440:	88 0f       	add	r24, r24
    1442:	99 1f       	adc	r25, r25
    1444:	28 0f       	add	r18, r24
    1446:	39 1f       	adc	r19, r25
    1448:	80 e2       	ldi	r24, 0x20	; 32
    144a:	69 81       	ldd	r22, Y+1	; 0x01
    144c:	42 e0       	ldi	r20, 0x02	; 2
    144e:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <write_i2c_data>
}
    1452:	0f 90       	pop	r0
    1454:	cf 91       	pop	r28
    1456:	df 91       	pop	r29
    1458:	08 95       	ret

0000145a <seek>:
- Wait STC flag (Seek/Tune Complete, in Status register)
- Clear hmute Bit
- Update Functions (optional)
*/
uint16_t seek(uint8_t direction)
{
    145a:	df 93       	push	r29
    145c:	cf 93       	push	r28
    145e:	cd b7       	in	r28, 0x3d	; 61
    1460:	de b7       	in	r29, 0x3e	; 62
    1462:	69 97       	sbiw	r28, 0x19	; 25
    1464:	0f b6       	in	r0, 0x3f	; 63
    1466:	f8 94       	cli
    1468:	de bf       	out	0x3e, r29	; 62
    146a:	0f be       	out	0x3f, r0	; 63
    146c:	cd bf       	out	0x3d, r28	; 61
    146e:	8f 8b       	std	Y+23, r24	; 0x17
	uint16_t readchan, time_out, tmp;
	char str[16];

	
	printf("\n\t Seeking \n");
    1470:	86 e4       	ldi	r24, 0x46	; 70
    1472:	93 e0       	ldi	r25, 0x03	; 3
    1474:	0e 94 ab 12 	call	0x2556	; 0x2556 <puts>
	
	register_values[01] = 0x5b17; // hmute = on
    1478:	87 e1       	ldi	r24, 0x17	; 23
    147a:	9b e5       	ldi	r25, 0x5B	; 91
    147c:	90 93 1a 02 	sts	0x021A, r25
    1480:	80 93 19 02 	sts	0x0219, r24
	write_ar1000_word(1);	
    1484:	81 e0       	ldi	r24, 0x01	; 1
    1486:	0e 94 15 0a 	call	0x142a	; 0x142a <write_ar1000_word>
	

	if (direction == SEEK_DIR_UP)
    148a:	8f 89       	ldd	r24, Y+23	; 0x17
    148c:	81 30       	cpi	r24, 0x01	; 1
    148e:	39 f4       	brne	.+14     	; 0x149e <seek+0x44>
		register_values[03] = 0xA030;  //turn off seek, seek up, set threshold to 16*3
    1490:	80 e3       	ldi	r24, 0x30	; 48
    1492:	90 ea       	ldi	r25, 0xA0	; 160
    1494:	90 93 1e 02 	sts	0x021E, r25
    1498:	80 93 1d 02 	sts	0x021D, r24
    149c:	06 c0       	rjmp	.+12     	; 0x14aa <seek+0x50>
	else
		register_values[03] = 0x2030;  //turn off seek, seek down, set threshold to 16*3
    149e:	80 e3       	ldi	r24, 0x30	; 48
    14a0:	90 e2       	ldi	r25, 0x20	; 32
    14a2:	90 93 1e 02 	sts	0x021E, r25
    14a6:	80 93 1d 02 	sts	0x021D, r24
		
	write_ar1000_word(3);
    14aa:	83 e0       	ldi	r24, 0x03	; 3
    14ac:	0e 94 15 0a 	call	0x142a	; 0x142a <write_ar1000_word>
	
	// set previous channel as starting point for next search
	readchan = (ar1000read(0x13) & 0xFF80) >> 7;
    14b0:	83 e1       	ldi	r24, 0x13	; 19
    14b2:	0e 94 63 11 	call	0x22c6	; 0x22c6 <ar1000read>
    14b6:	88 0f       	add	r24, r24
    14b8:	89 2f       	mov	r24, r25
    14ba:	88 1f       	adc	r24, r24
    14bc:	99 0b       	sbc	r25, r25
    14be:	91 95       	neg	r25
    14c0:	9e 83       	std	Y+6, r25	; 0x06
    14c2:	8d 83       	std	Y+5, r24	; 0x05
	if (readchan != 0)
    14c4:	8d 81       	ldd	r24, Y+5	; 0x05
    14c6:	9e 81       	ldd	r25, Y+6	; 0x06
    14c8:	00 97       	sbiw	r24, 0x00	; 0
    14ca:	39 f0       	breq	.+14     	; 0x14da <seek+0x80>
		register_values[2] = readchan; 
    14cc:	8d 81       	ldd	r24, Y+5	; 0x05
    14ce:	9e 81       	ldd	r25, Y+6	; 0x06
    14d0:	90 93 1c 02 	sts	0x021C, r25
    14d4:	80 93 1b 02 	sts	0x021B, r24
    14d8:	06 c0       	rjmp	.+12     	; 0x14e6 <seek+0x8c>
	else
		register_values[2] = 0xF4B9; // standard value, equates to 87.5 MHz
    14da:	89 eb       	ldi	r24, 0xB9	; 185
    14dc:	94 ef       	ldi	r25, 0xF4	; 244
    14de:	90 93 1c 02 	sts	0x021C, r25
    14e2:	80 93 1b 02 	sts	0x021B, r24
	
	write_ar1000_word(2);
    14e6:	82 e0       	ldi	r24, 0x02	; 2
    14e8:	0e 94 15 0a 	call	0x142a	; 0x142a <write_ar1000_word>
	
	if (direction == SEEK_DIR_UP)
    14ec:	8f 89       	ldd	r24, Y+23	; 0x17
    14ee:	81 30       	cpi	r24, 0x01	; 1
    14f0:	39 f4       	brne	.+14     	; 0x1500 <seek+0xa6>
		register_values[03] = 0xE010;  //turn on seek, seek up, set threshold to 16
    14f2:	80 e1       	ldi	r24, 0x10	; 16
    14f4:	90 ee       	ldi	r25, 0xE0	; 224
    14f6:	90 93 1e 02 	sts	0x021E, r25
    14fa:	80 93 1d 02 	sts	0x021D, r24
    14fe:	06 c0       	rjmp	.+12     	; 0x150c <seek+0xb2>
	else
		register_values[03] = 0x6010;  //turn on seek, seek down, set threshold to 16
    1500:	80 e1       	ldi	r24, 0x10	; 16
    1502:	90 e6       	ldi	r25, 0x60	; 96
    1504:	90 93 1e 02 	sts	0x021E, r25
    1508:	80 93 1d 02 	sts	0x021D, r24
		
	write_ar1000_word(3);
    150c:	83 e0       	ldi	r24, 0x03	; 3
    150e:	0e 94 15 0a 	call	0x142a	; 0x142a <write_ar1000_word>
	
	// wait for up to 200 ms for search to finish
	time_out = 100;
    1512:	84 e6       	ldi	r24, 0x64	; 100
    1514:	90 e0       	ldi	r25, 0x00	; 0
    1516:	9c 83       	std	Y+4, r25	; 0x04
    1518:	8b 83       	std	Y+3, r24	; 0x03
    151a:	04 c0       	rjmp	.+8      	; 0x1524 <seek+0xca>
	while ((ar1000read(0x13) & 0x0020) == 0 && (time_out-- > 0))
		wait_ms(2);
    151c:	82 e0       	ldi	r24, 0x02	; 2
    151e:	90 e0       	ldi	r25, 0x00	; 0
    1520:	0e 94 6b 00 	call	0xd6	; 0xd6 <wait_ms>
		
	write_ar1000_word(3);
	
	// wait for up to 200 ms for search to finish
	time_out = 100;
	while ((ar1000read(0x13) & 0x0020) == 0 && (time_out-- > 0))
    1524:	83 e1       	ldi	r24, 0x13	; 19
    1526:	0e 94 63 11 	call	0x22c6	; 0x22c6 <ar1000read>
    152a:	80 72       	andi	r24, 0x20	; 32
    152c:	90 70       	andi	r25, 0x00	; 0
    152e:	00 97       	sbiw	r24, 0x00	; 0
    1530:	79 f4       	brne	.+30     	; 0x1550 <seek+0xf6>
    1532:	19 8e       	std	Y+25, r1	; 0x19
    1534:	8b 81       	ldd	r24, Y+3	; 0x03
    1536:	9c 81       	ldd	r25, Y+4	; 0x04
    1538:	00 97       	sbiw	r24, 0x00	; 0
    153a:	11 f0       	breq	.+4      	; 0x1540 <seek+0xe6>
    153c:	81 e0       	ldi	r24, 0x01	; 1
    153e:	89 8f       	std	Y+25, r24	; 0x19
    1540:	8b 81       	ldd	r24, Y+3	; 0x03
    1542:	9c 81       	ldd	r25, Y+4	; 0x04
    1544:	01 97       	sbiw	r24, 0x01	; 1
    1546:	9c 83       	std	Y+4, r25	; 0x04
    1548:	8b 83       	std	Y+3, r24	; 0x03
    154a:	99 8d       	ldd	r25, Y+25	; 0x19
    154c:	99 23       	and	r25, r25
    154e:	31 f7       	brne	.-52     	; 0x151c <seek+0xc2>
		wait_ms(2);

	readchan = (ar1000read(0x13) & 0xFF80) >> 7;
    1550:	83 e1       	ldi	r24, 0x13	; 19
    1552:	0e 94 63 11 	call	0x22c6	; 0x22c6 <ar1000read>
    1556:	88 0f       	add	r24, r24
    1558:	89 2f       	mov	r24, r25
    155a:	88 1f       	adc	r24, r24
    155c:	99 0b       	sbc	r25, r25
    155e:	91 95       	neg	r25
    1560:	9e 83       	std	Y+6, r25	; 0x06
    1562:	8d 83       	std	Y+5, r24	; 0x05
	
	if (time_out-- == 0)
    1564:	18 8e       	std	Y+24, r1	; 0x18
    1566:	8b 81       	ldd	r24, Y+3	; 0x03
    1568:	9c 81       	ldd	r25, Y+4	; 0x04
    156a:	00 97       	sbiw	r24, 0x00	; 0
    156c:	11 f4       	brne	.+4      	; 0x1572 <seek+0x118>
    156e:	81 e0       	ldi	r24, 0x01	; 1
    1570:	88 8f       	std	Y+24, r24	; 0x18
    1572:	8b 81       	ldd	r24, Y+3	; 0x03
    1574:	9c 81       	ldd	r25, Y+4	; 0x04
    1576:	01 97       	sbiw	r24, 0x01	; 1
    1578:	9c 83       	std	Y+4, r25	; 0x04
    157a:	8b 83       	std	Y+3, r24	; 0x03
    157c:	98 8d       	ldd	r25, Y+24	; 0x18
    157e:	99 23       	and	r25, r25
    1580:	69 f0       	breq	.+26     	; 0x159c <seek+0x142>
		printf("\nSeek failed!");
    1582:	00 d0       	rcall	.+0      	; 0x1584 <seek+0x12a>
    1584:	ed b7       	in	r30, 0x3d	; 61
    1586:	fe b7       	in	r31, 0x3e	; 62
    1588:	31 96       	adiw	r30, 0x01	; 1
    158a:	82 e5       	ldi	r24, 0x52	; 82
    158c:	93 e0       	ldi	r25, 0x03	; 3
    158e:	91 83       	std	Z+1, r25	; 0x01
    1590:	80 83       	st	Z, r24
    1592:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1596:	0f 90       	pop	r0
    1598:	0f 90       	pop	r0
    159a:	a6 c0       	rjmp	.+332    	; 0x16e8 <seek+0x28e>
	else
	{
		printf("\nReadchan = %d", readchan);
    159c:	00 d0       	rcall	.+0      	; 0x159e <seek+0x144>
    159e:	00 d0       	rcall	.+0      	; 0x15a0 <seek+0x146>
    15a0:	ed b7       	in	r30, 0x3d	; 61
    15a2:	fe b7       	in	r31, 0x3e	; 62
    15a4:	31 96       	adiw	r30, 0x01	; 1
    15a6:	80 e6       	ldi	r24, 0x60	; 96
    15a8:	93 e0       	ldi	r25, 0x03	; 3
    15aa:	91 83       	std	Z+1, r25	; 0x01
    15ac:	80 83       	st	Z, r24
    15ae:	8d 81       	ldd	r24, Y+5	; 0x05
    15b0:	9e 81       	ldd	r25, Y+6	; 0x06
    15b2:	93 83       	std	Z+3, r25	; 0x03
    15b4:	82 83       	std	Z+2, r24	; 0x02
    15b6:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    15ba:	0f 90       	pop	r0
    15bc:	0f 90       	pop	r0
    15be:	0f 90       	pop	r0
    15c0:	0f 90       	pop	r0
		tmp = (readchan + 690) / 10;
    15c2:	8d 81       	ldd	r24, Y+5	; 0x05
    15c4:	9e 81       	ldd	r25, Y+6	; 0x06
    15c6:	8e 54       	subi	r24, 0x4E	; 78
    15c8:	9d 4f       	sbci	r25, 0xFD	; 253
    15ca:	2a e0       	ldi	r18, 0x0A	; 10
    15cc:	30 e0       	ldi	r19, 0x00	; 0
    15ce:	b9 01       	movw	r22, r18
    15d0:	0e 94 81 15 	call	0x2b02	; 0x2b02 <__udivmodhi4>
    15d4:	cb 01       	movw	r24, r22
    15d6:	9a 83       	std	Y+2, r25	; 0x02
    15d8:	89 83       	std	Y+1, r24	; 0x01
		printf("\nTuned to frequency %d.%d MHz", tmp, (readchan + 690) - tmp*10);
    15da:	89 81       	ldd	r24, Y+1	; 0x01
    15dc:	9a 81       	ldd	r25, Y+2	; 0x02
    15de:	9c 01       	movw	r18, r24
    15e0:	22 0f       	add	r18, r18
    15e2:	33 1f       	adc	r19, r19
    15e4:	c9 01       	movw	r24, r18
    15e6:	88 0f       	add	r24, r24
    15e8:	99 1f       	adc	r25, r25
    15ea:	88 0f       	add	r24, r24
    15ec:	99 1f       	adc	r25, r25
    15ee:	28 0f       	add	r18, r24
    15f0:	39 1f       	adc	r19, r25
    15f2:	8d 81       	ldd	r24, Y+5	; 0x05
    15f4:	9e 81       	ldd	r25, Y+6	; 0x06
    15f6:	82 1b       	sub	r24, r18
    15f8:	93 0b       	sbc	r25, r19
    15fa:	9c 01       	movw	r18, r24
    15fc:	2e 54       	subi	r18, 0x4E	; 78
    15fe:	3d 4f       	sbci	r19, 0xFD	; 253
    1600:	00 d0       	rcall	.+0      	; 0x1602 <seek+0x1a8>
    1602:	00 d0       	rcall	.+0      	; 0x1604 <seek+0x1aa>
    1604:	00 d0       	rcall	.+0      	; 0x1606 <seek+0x1ac>
    1606:	ed b7       	in	r30, 0x3d	; 61
    1608:	fe b7       	in	r31, 0x3e	; 62
    160a:	31 96       	adiw	r30, 0x01	; 1
    160c:	8f e6       	ldi	r24, 0x6F	; 111
    160e:	93 e0       	ldi	r25, 0x03	; 3
    1610:	91 83       	std	Z+1, r25	; 0x01
    1612:	80 83       	st	Z, r24
    1614:	89 81       	ldd	r24, Y+1	; 0x01
    1616:	9a 81       	ldd	r25, Y+2	; 0x02
    1618:	93 83       	std	Z+3, r25	; 0x03
    161a:	82 83       	std	Z+2, r24	; 0x02
    161c:	35 83       	std	Z+5, r19	; 0x05
    161e:	24 83       	std	Z+4, r18	; 0x04
    1620:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1624:	8d b7       	in	r24, 0x3d	; 61
    1626:	9e b7       	in	r25, 0x3e	; 62
    1628:	06 96       	adiw	r24, 0x06	; 6
    162a:	0f b6       	in	r0, 0x3f	; 63
    162c:	f8 94       	cli
    162e:	9e bf       	out	0x3e, r25	; 62
    1630:	0f be       	out	0x3f, r0	; 63
    1632:	8d bf       	out	0x3d, r24	; 61

		register_values[2] = readchan | 0x0000; // set freq and TUNE
    1634:	8d 81       	ldd	r24, Y+5	; 0x05
    1636:	9e 81       	ldd	r25, Y+6	; 0x06
    1638:	90 93 1c 02 	sts	0x021C, r25
    163c:	80 93 1b 02 	sts	0x021B, r24
		write_ar1000_word(2);
    1640:	82 e0       	ldi	r24, 0x02	; 2
    1642:	0e 94 15 0a 	call	0x142a	; 0x142a <write_ar1000_word>

		register_values[2] = readchan | 0x0200; // set freq and TUNE
    1646:	8d 81       	ldd	r24, Y+5	; 0x05
    1648:	9e 81       	ldd	r25, Y+6	; 0x06
    164a:	92 60       	ori	r25, 0x02	; 2
    164c:	90 93 1c 02 	sts	0x021C, r25
    1650:	80 93 1b 02 	sts	0x021B, r24
		write_ar1000_word(2);
    1654:	82 e0       	ldi	r24, 0x02	; 2
    1656:	0e 94 15 0a 	call	0x142a	; 0x142a <write_ar1000_word>
		
		register_values[1] = 0x5b15; // hmute = off
    165a:	85 e1       	ldi	r24, 0x15	; 21
    165c:	9b e5       	ldi	r25, 0x5B	; 91
    165e:	90 93 1a 02 	sts	0x021A, r25
    1662:	80 93 19 02 	sts	0x0219, r24
		write_ar1000_word(1);
    1666:	81 e0       	ldi	r24, 0x01	; 1
    1668:	0e 94 15 0a 	call	0x142a	; 0x142a <write_ar1000_word>
		
		lcd_gotoxy(0,0);
    166c:	80 e0       	ldi	r24, 0x00	; 0
    166e:	60 e0       	ldi	r22, 0x00	; 0
    1670:	0e 94 e5 07 	call	0xfca	; 0xfca <lcd_gotoxy>
		sprintf(str, "Tuned: %d.%d MHz", tmp, (readchan + 690) - tmp*10);
    1674:	89 81       	ldd	r24, Y+1	; 0x01
    1676:	9a 81       	ldd	r25, Y+2	; 0x02
    1678:	9c 01       	movw	r18, r24
    167a:	22 0f       	add	r18, r18
    167c:	33 1f       	adc	r19, r19
    167e:	c9 01       	movw	r24, r18
    1680:	88 0f       	add	r24, r24
    1682:	99 1f       	adc	r25, r25
    1684:	88 0f       	add	r24, r24
    1686:	99 1f       	adc	r25, r25
    1688:	28 0f       	add	r18, r24
    168a:	39 1f       	adc	r19, r25
    168c:	8d 81       	ldd	r24, Y+5	; 0x05
    168e:	9e 81       	ldd	r25, Y+6	; 0x06
    1690:	82 1b       	sub	r24, r18
    1692:	93 0b       	sbc	r25, r19
    1694:	9c 01       	movw	r18, r24
    1696:	2e 54       	subi	r18, 0x4E	; 78
    1698:	3d 4f       	sbci	r19, 0xFD	; 253
    169a:	8d b7       	in	r24, 0x3d	; 61
    169c:	9e b7       	in	r25, 0x3e	; 62
    169e:	08 97       	sbiw	r24, 0x08	; 8
    16a0:	0f b6       	in	r0, 0x3f	; 63
    16a2:	f8 94       	cli
    16a4:	9e bf       	out	0x3e, r25	; 62
    16a6:	0f be       	out	0x3f, r0	; 63
    16a8:	8d bf       	out	0x3d, r24	; 61
    16aa:	ed b7       	in	r30, 0x3d	; 61
    16ac:	fe b7       	in	r31, 0x3e	; 62
    16ae:	31 96       	adiw	r30, 0x01	; 1
    16b0:	ce 01       	movw	r24, r28
    16b2:	07 96       	adiw	r24, 0x07	; 7
    16b4:	91 83       	std	Z+1, r25	; 0x01
    16b6:	80 83       	st	Z, r24
    16b8:	8d e8       	ldi	r24, 0x8D	; 141
    16ba:	93 e0       	ldi	r25, 0x03	; 3
    16bc:	93 83       	std	Z+3, r25	; 0x03
    16be:	82 83       	std	Z+2, r24	; 0x02
    16c0:	89 81       	ldd	r24, Y+1	; 0x01
    16c2:	9a 81       	ldd	r25, Y+2	; 0x02
    16c4:	95 83       	std	Z+5, r25	; 0x05
    16c6:	84 83       	std	Z+4, r24	; 0x04
    16c8:	37 83       	std	Z+7, r19	; 0x07
    16ca:	26 83       	std	Z+6, r18	; 0x06
    16cc:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <sprintf>
    16d0:	8d b7       	in	r24, 0x3d	; 61
    16d2:	9e b7       	in	r25, 0x3e	; 62
    16d4:	08 96       	adiw	r24, 0x08	; 8
    16d6:	0f b6       	in	r0, 0x3f	; 63
    16d8:	f8 94       	cli
    16da:	9e bf       	out	0x3e, r25	; 62
    16dc:	0f be       	out	0x3f, r0	; 63
    16de:	8d bf       	out	0x3d, r24	; 61
		lcd_puts(str);
    16e0:	ce 01       	movw	r24, r28
    16e2:	07 96       	adiw	r24, 0x07	; 7
    16e4:	0e 94 4b 08 	call	0x1096	; 0x1096 <lcd_puts>
	
	//there are many other functions in registers R02 and R03, 
	//for example the R03 value also changes the volume of the 
	//reciever and the R02 value also activates the tune bit
	
	return readchan;
    16e8:	8d 81       	ldd	r24, Y+5	; 0x05
    16ea:	9e 81       	ldd	r25, Y+6	; 0x06
}
    16ec:	69 96       	adiw	r28, 0x19	; 25
    16ee:	0f b6       	in	r0, 0x3f	; 63
    16f0:	f8 94       	cli
    16f2:	de bf       	out	0x3e, r29	; 62
    16f4:	0f be       	out	0x3f, r0	; 63
    16f6:	cd bf       	out	0x3d, r28	; 61
    16f8:	cf 91       	pop	r28
    16fa:	df 91       	pop	r29
    16fc:	08 95       	ret

000016fe <set_volume>:


void set_volume(uint8_t volume)
{
    16fe:	df 93       	push	r29
    1700:	cf 93       	push	r28
    1702:	cd b7       	in	r28, 0x3d	; 61
    1704:	de b7       	in	r29, 0x3e	; 62
    1706:	65 97       	sbiw	r28, 0x15	; 21
    1708:	0f b6       	in	r0, 0x3f	; 63
    170a:	f8 94       	cli
    170c:	de bf       	out	0x3e, r29	; 62
    170e:	0f be       	out	0x3f, r0	; 63
    1710:	cd bf       	out	0x3d, r28	; 61
    1712:	8b 8b       	std	Y+19, r24	; 0x13
	char str[16];
	
	BYTE vol1, vol2;

	
	printf("\n\t volume set to %i \n", volume);
    1714:	8b 89       	ldd	r24, Y+19	; 0x13
    1716:	28 2f       	mov	r18, r24
    1718:	30 e0       	ldi	r19, 0x00	; 0
    171a:	00 d0       	rcall	.+0      	; 0x171c <set_volume+0x1e>
    171c:	00 d0       	rcall	.+0      	; 0x171e <set_volume+0x20>
    171e:	ed b7       	in	r30, 0x3d	; 61
    1720:	fe b7       	in	r31, 0x3e	; 62
    1722:	31 96       	adiw	r30, 0x01	; 1
    1724:	8e e9       	ldi	r24, 0x9E	; 158
    1726:	93 e0       	ldi	r25, 0x03	; 3
    1728:	91 83       	std	Z+1, r25	; 0x01
    172a:	80 83       	st	Z, r24
    172c:	33 83       	std	Z+3, r19	; 0x03
    172e:	22 83       	std	Z+2, r18	; 0x02
    1730:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1734:	0f 90       	pop	r0
    1736:	0f 90       	pop	r0
    1738:	0f 90       	pop	r0
    173a:	0f 90       	pop	r0
	

	switch(volume)
    173c:	8b 89       	ldd	r24, Y+19	; 0x13
    173e:	28 2f       	mov	r18, r24
    1740:	30 e0       	ldi	r19, 0x00	; 0
    1742:	3d 8b       	std	Y+21, r19	; 0x15
    1744:	2c 8b       	std	Y+20, r18	; 0x14
    1746:	8c 89       	ldd	r24, Y+20	; 0x14
    1748:	9d 89       	ldd	r25, Y+21	; 0x15
    174a:	88 30       	cpi	r24, 0x08	; 8
    174c:	91 05       	cpc	r25, r1
    174e:	09 f4       	brne	.+2      	; 0x1752 <set_volume+0x54>
    1750:	93 c0       	rjmp	.+294    	; 0x1878 <set_volume+0x17a>
    1752:	2c 89       	ldd	r18, Y+20	; 0x14
    1754:	3d 89       	ldd	r19, Y+21	; 0x15
    1756:	29 30       	cpi	r18, 0x09	; 9
    1758:	31 05       	cpc	r19, r1
    175a:	b4 f5       	brge	.+108    	; 0x17c8 <set_volume+0xca>
    175c:	8c 89       	ldd	r24, Y+20	; 0x14
    175e:	9d 89       	ldd	r25, Y+21	; 0x15
    1760:	83 30       	cpi	r24, 0x03	; 3
    1762:	91 05       	cpc	r25, r1
    1764:	09 f4       	brne	.+2      	; 0x1768 <set_volume+0x6a>
    1766:	6f c0       	rjmp	.+222    	; 0x1846 <set_volume+0x148>
    1768:	2c 89       	ldd	r18, Y+20	; 0x14
    176a:	3d 89       	ldd	r19, Y+21	; 0x15
    176c:	24 30       	cpi	r18, 0x04	; 4
    176e:	31 05       	cpc	r19, r1
    1770:	94 f4       	brge	.+36     	; 0x1796 <set_volume+0x98>
    1772:	8c 89       	ldd	r24, Y+20	; 0x14
    1774:	9d 89       	ldd	r25, Y+21	; 0x15
    1776:	81 30       	cpi	r24, 0x01	; 1
    1778:	91 05       	cpc	r25, r1
    177a:	09 f4       	brne	.+2      	; 0x177e <set_volume+0x80>
    177c:	5a c0       	rjmp	.+180    	; 0x1832 <set_volume+0x134>
    177e:	2c 89       	ldd	r18, Y+20	; 0x14
    1780:	3d 89       	ldd	r19, Y+21	; 0x15
    1782:	22 30       	cpi	r18, 0x02	; 2
    1784:	31 05       	cpc	r19, r1
    1786:	0c f0       	brlt	.+2      	; 0x178a <set_volume+0x8c>
    1788:	59 c0       	rjmp	.+178    	; 0x183c <set_volume+0x13e>
    178a:	8c 89       	ldd	r24, Y+20	; 0x14
    178c:	9d 89       	ldd	r25, Y+21	; 0x15
    178e:	00 97       	sbiw	r24, 0x00	; 0
    1790:	09 f4       	brne	.+2      	; 0x1794 <set_volume+0x96>
    1792:	4b c0       	rjmp	.+150    	; 0x182a <set_volume+0x12c>
    1794:	9d c0       	rjmp	.+314    	; 0x18d0 <set_volume+0x1d2>
    1796:	2c 89       	ldd	r18, Y+20	; 0x14
    1798:	3d 89       	ldd	r19, Y+21	; 0x15
    179a:	25 30       	cpi	r18, 0x05	; 5
    179c:	31 05       	cpc	r19, r1
    179e:	09 f4       	brne	.+2      	; 0x17a2 <set_volume+0xa4>
    17a0:	5c c0       	rjmp	.+184    	; 0x185a <set_volume+0x15c>
    17a2:	8c 89       	ldd	r24, Y+20	; 0x14
    17a4:	9d 89       	ldd	r25, Y+21	; 0x15
    17a6:	85 30       	cpi	r24, 0x05	; 5
    17a8:	91 05       	cpc	r25, r1
    17aa:	0c f4       	brge	.+2      	; 0x17ae <set_volume+0xb0>
    17ac:	51 c0       	rjmp	.+162    	; 0x1850 <set_volume+0x152>
    17ae:	2c 89       	ldd	r18, Y+20	; 0x14
    17b0:	3d 89       	ldd	r19, Y+21	; 0x15
    17b2:	26 30       	cpi	r18, 0x06	; 6
    17b4:	31 05       	cpc	r19, r1
    17b6:	09 f4       	brne	.+2      	; 0x17ba <set_volume+0xbc>
    17b8:	55 c0       	rjmp	.+170    	; 0x1864 <set_volume+0x166>
    17ba:	8c 89       	ldd	r24, Y+20	; 0x14
    17bc:	9d 89       	ldd	r25, Y+21	; 0x15
    17be:	87 30       	cpi	r24, 0x07	; 7
    17c0:	91 05       	cpc	r25, r1
    17c2:	09 f4       	brne	.+2      	; 0x17c6 <set_volume+0xc8>
    17c4:	54 c0       	rjmp	.+168    	; 0x186e <set_volume+0x170>
    17c6:	84 c0       	rjmp	.+264    	; 0x18d0 <set_volume+0x1d2>
    17c8:	2c 89       	ldd	r18, Y+20	; 0x14
    17ca:	3d 89       	ldd	r19, Y+21	; 0x15
    17cc:	2c 30       	cpi	r18, 0x0C	; 12
    17ce:	31 05       	cpc	r19, r1
    17d0:	09 f4       	brne	.+2      	; 0x17d4 <set_volume+0xd6>
    17d2:	66 c0       	rjmp	.+204    	; 0x18a0 <set_volume+0x1a2>
    17d4:	8c 89       	ldd	r24, Y+20	; 0x14
    17d6:	9d 89       	ldd	r25, Y+21	; 0x15
    17d8:	8d 30       	cpi	r24, 0x0D	; 13
    17da:	91 05       	cpc	r25, r1
    17dc:	6c f4       	brge	.+26     	; 0x17f8 <set_volume+0xfa>
    17de:	2c 89       	ldd	r18, Y+20	; 0x14
    17e0:	3d 89       	ldd	r19, Y+21	; 0x15
    17e2:	2a 30       	cpi	r18, 0x0A	; 10
    17e4:	31 05       	cpc	r19, r1
    17e6:	09 f4       	brne	.+2      	; 0x17ea <set_volume+0xec>
    17e8:	51 c0       	rjmp	.+162    	; 0x188c <set_volume+0x18e>
    17ea:	8c 89       	ldd	r24, Y+20	; 0x14
    17ec:	9d 89       	ldd	r25, Y+21	; 0x15
    17ee:	8b 30       	cpi	r24, 0x0B	; 11
    17f0:	91 05       	cpc	r25, r1
    17f2:	0c f0       	brlt	.+2      	; 0x17f6 <set_volume+0xf8>
    17f4:	50 c0       	rjmp	.+160    	; 0x1896 <set_volume+0x198>
    17f6:	45 c0       	rjmp	.+138    	; 0x1882 <set_volume+0x184>
    17f8:	2c 89       	ldd	r18, Y+20	; 0x14
    17fa:	3d 89       	ldd	r19, Y+21	; 0x15
    17fc:	2e 30       	cpi	r18, 0x0E	; 14
    17fe:	31 05       	cpc	r19, r1
    1800:	09 f4       	brne	.+2      	; 0x1804 <set_volume+0x106>
    1802:	58 c0       	rjmp	.+176    	; 0x18b4 <set_volume+0x1b6>
    1804:	8c 89       	ldd	r24, Y+20	; 0x14
    1806:	9d 89       	ldd	r25, Y+21	; 0x15
    1808:	8e 30       	cpi	r24, 0x0E	; 14
    180a:	91 05       	cpc	r25, r1
    180c:	0c f4       	brge	.+2      	; 0x1810 <set_volume+0x112>
    180e:	4d c0       	rjmp	.+154    	; 0x18aa <set_volume+0x1ac>
    1810:	2c 89       	ldd	r18, Y+20	; 0x14
    1812:	3d 89       	ldd	r19, Y+21	; 0x15
    1814:	2f 30       	cpi	r18, 0x0F	; 15
    1816:	31 05       	cpc	r19, r1
    1818:	09 f4       	brne	.+2      	; 0x181c <set_volume+0x11e>
    181a:	51 c0       	rjmp	.+162    	; 0x18be <set_volume+0x1c0>
    181c:	8c 89       	ldd	r24, Y+20	; 0x14
    181e:	9d 89       	ldd	r25, Y+21	; 0x15
    1820:	80 31       	cpi	r24, 0x10	; 16
    1822:	91 05       	cpc	r25, r1
    1824:	09 f4       	brne	.+2      	; 0x1828 <set_volume+0x12a>
    1826:	50 c0       	rjmp	.+160    	; 0x18c8 <set_volume+0x1ca>
    1828:	53 c0       	rjmp	.+166    	; 0x18d0 <set_volume+0x1d2>
	{
		case 0 : 
			vol2 = 0x0;
    182a:	19 82       	std	Y+1, r1	; 0x01
			vol1 = 0xF;
    182c:	8f e0       	ldi	r24, 0x0F	; 15
    182e:	8a 83       	std	Y+2, r24	; 0x02
    1830:	52 c0       	rjmp	.+164    	; 0x18d6 <set_volume+0x1d8>
		break;
		case 1 : 
			vol2 = 0xC;
    1832:	8c e0       	ldi	r24, 0x0C	; 12
    1834:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0xF;
    1836:	8f e0       	ldi	r24, 0x0F	; 15
    1838:	8a 83       	std	Y+2, r24	; 0x02
    183a:	4d c0       	rjmp	.+154    	; 0x18d6 <set_volume+0x1d8>
		break;
		case 2 : 
			vol2 = 0xD;
    183c:	8d e0       	ldi	r24, 0x0D	; 13
    183e:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0xF;
    1840:	8f e0       	ldi	r24, 0x0F	; 15
    1842:	8a 83       	std	Y+2, r24	; 0x02
    1844:	48 c0       	rjmp	.+144    	; 0x18d6 <set_volume+0x1d8>
		break;
		case 3 : 
			vol2 = 0xE;
    1846:	8e e0       	ldi	r24, 0x0E	; 14
    1848:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0xF;
    184a:	8f e0       	ldi	r24, 0x0F	; 15
    184c:	8a 83       	std	Y+2, r24	; 0x02
    184e:	43 c0       	rjmp	.+134    	; 0x18d6 <set_volume+0x1d8>
		break;
		case 4 : 
			vol2 = 0xE;
    1850:	8e e0       	ldi	r24, 0x0E	; 14
    1852:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0xE;
    1854:	8e e0       	ldi	r24, 0x0E	; 14
    1856:	8a 83       	std	Y+2, r24	; 0x02
    1858:	3e c0       	rjmp	.+124    	; 0x18d6 <set_volume+0x1d8>
		break;
		case 5 : 
			vol2 = 0xF;
    185a:	8f e0       	ldi	r24, 0x0F	; 15
    185c:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0xE;
    185e:	8e e0       	ldi	r24, 0x0E	; 14
    1860:	8a 83       	std	Y+2, r24	; 0x02
    1862:	39 c0       	rjmp	.+114    	; 0x18d6 <set_volume+0x1d8>
		break;
		case 6 : 
			vol2 = 0xE;
    1864:	8e e0       	ldi	r24, 0x0E	; 14
    1866:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0xD;
    1868:	8d e0       	ldi	r24, 0x0D	; 13
    186a:	8a 83       	std	Y+2, r24	; 0x02
    186c:	34 c0       	rjmp	.+104    	; 0x18d6 <set_volume+0x1d8>
		break;
		case 7 : 
			vol2 = 0xF;
    186e:	8f e0       	ldi	r24, 0x0F	; 15
    1870:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0xD;
    1872:	8d e0       	ldi	r24, 0x0D	; 13
    1874:	8a 83       	std	Y+2, r24	; 0x02
    1876:	2f c0       	rjmp	.+94     	; 0x18d6 <set_volume+0x1d8>
		break;
		case 8 : 
			vol2 = 0xF;
    1878:	8f e0       	ldi	r24, 0x0F	; 15
    187a:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0xA;
    187c:	8a e0       	ldi	r24, 0x0A	; 10
    187e:	8a 83       	std	Y+2, r24	; 0x02
    1880:	2a c0       	rjmp	.+84     	; 0x18d6 <set_volume+0x1d8>
		break;
		case 9 : 
			vol2 = 0xF;
    1882:	8f e0       	ldi	r24, 0x0F	; 15
    1884:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0x9;
    1886:	89 e0       	ldi	r24, 0x09	; 9
    1888:	8a 83       	std	Y+2, r24	; 0x02
    188a:	25 c0       	rjmp	.+74     	; 0x18d6 <set_volume+0x1d8>
		break;
		case 10 : 
			vol2 = 0xE;
    188c:	8e e0       	ldi	r24, 0x0E	; 14
    188e:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0x6;
    1890:	86 e0       	ldi	r24, 0x06	; 6
    1892:	8a 83       	std	Y+2, r24	; 0x02
    1894:	20 c0       	rjmp	.+64     	; 0x18d6 <set_volume+0x1d8>
		break;
		case 11 : 
			vol2 = 0xF;
    1896:	8f e0       	ldi	r24, 0x0F	; 15
    1898:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0x6;
    189a:	86 e0       	ldi	r24, 0x06	; 6
    189c:	8a 83       	std	Y+2, r24	; 0x02
    189e:	1b c0       	rjmp	.+54     	; 0x18d6 <set_volume+0x1d8>
		break;
		case 12 : 
			vol2 = 0xF;
    18a0:	8f e0       	ldi	r24, 0x0F	; 15
    18a2:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0x5;
    18a4:	85 e0       	ldi	r24, 0x05	; 5
    18a6:	8a 83       	std	Y+2, r24	; 0x02
    18a8:	16 c0       	rjmp	.+44     	; 0x18d6 <set_volume+0x1d8>
		break;
		case 13 : 
			vol2 = 0xE;
    18aa:	8e e0       	ldi	r24, 0x0E	; 14
    18ac:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0x3;
    18ae:	83 e0       	ldi	r24, 0x03	; 3
    18b0:	8a 83       	std	Y+2, r24	; 0x02
    18b2:	11 c0       	rjmp	.+34     	; 0x18d6 <set_volume+0x1d8>
		break;
		case 14 : 
			vol2 = 0xF;
    18b4:	8f e0       	ldi	r24, 0x0F	; 15
    18b6:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0x2;
    18b8:	82 e0       	ldi	r24, 0x02	; 2
    18ba:	8a 83       	std	Y+2, r24	; 0x02
    18bc:	0c c0       	rjmp	.+24     	; 0x18d6 <set_volume+0x1d8>
		break;
		case 15 : 
			vol2 = 0xF;
    18be:	8f e0       	ldi	r24, 0x0F	; 15
    18c0:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0x1;
    18c2:	81 e0       	ldi	r24, 0x01	; 1
    18c4:	8a 83       	std	Y+2, r24	; 0x02
    18c6:	07 c0       	rjmp	.+14     	; 0x18d6 <set_volume+0x1d8>
		break;
		case 16 : 
			vol2 = 0xF;
    18c8:	8f e0       	ldi	r24, 0x0F	; 15
    18ca:	89 83       	std	Y+1, r24	; 0x01
			vol1 = 0x0;
    18cc:	1a 82       	std	Y+2, r1	; 0x02
    18ce:	03 c0       	rjmp	.+6      	; 0x18d6 <set_volume+0x1d8>
		break;
			
		default : 
		
			vol2 = 0x0;
    18d0:	19 82       	std	Y+1, r1	; 0x01
			vol1 = 0xF;
    18d2:	8f e0       	ldi	r24, 0x0F	; 15
    18d4:	8a 83       	std	Y+2, r24	; 0x02
			
		break;
	}
			

	register_values[03] &= (~0xF<<7);  // clear vol1 pos D10:7 in reg[03]
    18d6:	80 91 1d 02 	lds	r24, 0x021D
    18da:	90 91 1e 02 	lds	r25, 0x021E
    18de:	80 70       	andi	r24, 0x00	; 0
    18e0:	98 7f       	andi	r25, 0xF8	; 248
    18e2:	90 93 1e 02 	sts	0x021E, r25
    18e6:	80 93 1d 02 	sts	0x021D, r24
	register_values[03] |= (vol1<<7);  // insert new vol1 value in reg[03]
    18ea:	20 91 1d 02 	lds	r18, 0x021D
    18ee:	30 91 1e 02 	lds	r19, 0x021E
    18f2:	8a 81       	ldd	r24, Y+2	; 0x02
    18f4:	88 2f       	mov	r24, r24
    18f6:	90 e0       	ldi	r25, 0x00	; 0
    18f8:	96 95       	lsr	r25
    18fa:	98 2f       	mov	r25, r24
    18fc:	88 27       	eor	r24, r24
    18fe:	97 95       	ror	r25
    1900:	87 95       	ror	r24
    1902:	82 2b       	or	r24, r18
    1904:	93 2b       	or	r25, r19
    1906:	90 93 1e 02 	sts	0x021E, r25
    190a:	80 93 1d 02 	sts	0x021D, r24
		
	write_ar1000_word(3);
    190e:	83 e0       	ldi	r24, 0x03	; 3
    1910:	0e 94 15 0a 	call	0x142a	; 0x142a <write_ar1000_word>
	
	register_values[14] &= (~0xF<<12);  // clear vol2 pos D15:12 in reg[14]
    1914:	10 92 34 02 	sts	0x0234, r1
    1918:	10 92 33 02 	sts	0x0233, r1
	register_values[14] |= (vol2<<12);  // insert new vol2 value in reg[14]
    191c:	20 91 33 02 	lds	r18, 0x0233
    1920:	30 91 34 02 	lds	r19, 0x0234
    1924:	89 81       	ldd	r24, Y+1	; 0x01
    1926:	88 2f       	mov	r24, r24
    1928:	90 e0       	ldi	r25, 0x00	; 0
    192a:	98 2f       	mov	r25, r24
    192c:	88 27       	eor	r24, r24
    192e:	92 95       	swap	r25
    1930:	90 7f       	andi	r25, 0xF0	; 240
    1932:	82 2b       	or	r24, r18
    1934:	93 2b       	or	r25, r19
    1936:	90 93 34 02 	sts	0x0234, r25
    193a:	80 93 33 02 	sts	0x0233, r24
		
	write_ar1000_word(14);
    193e:	8e e0       	ldi	r24, 0x0E	; 14
    1940:	0e 94 15 0a 	call	0x142a	; 0x142a <write_ar1000_word>

		
}
    1944:	65 96       	adiw	r28, 0x15	; 21
    1946:	0f b6       	in	r0, 0x3f	; 63
    1948:	f8 94       	cli
    194a:	de bf       	out	0x3e, r29	; 62
    194c:	0f be       	out	0x3f, r0	; 63
    194e:	cd bf       	out	0x3d, r28	; 61
    1950:	cf 91       	pop	r28
    1952:	df 91       	pop	r29
    1954:	08 95       	ret

00001956 <printmenu>:




void printmenu(void)
{ 
    1956:	df 93       	push	r29
    1958:	cf 93       	push	r28
    195a:	cd b7       	in	r28, 0x3d	; 61
    195c:	de b7       	in	r29, 0x3e	; 62
	//Simply prints a menu
	
	printf("\n\n\n----------FM Tuner-----------");
    195e:	00 d0       	rcall	.+0      	; 0x1960 <printmenu+0xa>
    1960:	ed b7       	in	r30, 0x3d	; 61
    1962:	fe b7       	in	r31, 0x3e	; 62
    1964:	31 96       	adiw	r30, 0x01	; 1
    1966:	84 eb       	ldi	r24, 0xB4	; 180
    1968:	93 e0       	ldi	r25, 0x03	; 3
    196a:	91 83       	std	Z+1, r25	; 0x01
    196c:	80 83       	st	Z, r24
    196e:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1972:	0f 90       	pop	r0
    1974:	0f 90       	pop	r0
	  printf(  "\n------Configuration Menu-----\n");	
    1976:	85 ed       	ldi	r24, 0xD5	; 213
    1978:	93 e0       	ldi	r25, 0x03	; 3
    197a:	0e 94 ab 12 	call	0x2556	; 0x2556 <puts>
	    printf("\n1) Send array values 1-17");
    197e:	00 d0       	rcall	.+0      	; 0x1980 <printmenu+0x2a>
    1980:	ed b7       	in	r30, 0x3d	; 61
    1982:	fe b7       	in	r31, 0x3e	; 62
    1984:	31 96       	adiw	r30, 0x01	; 1
    1986:	84 ef       	ldi	r24, 0xF4	; 244
    1988:	93 e0       	ldi	r25, 0x03	; 3
    198a:	91 83       	std	Z+1, r25	; 0x01
    198c:	80 83       	st	Z, r24
    198e:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1992:	0f 90       	pop	r0
    1994:	0f 90       	pop	r0
	    printf("\n2) Read array values");
    1996:	00 d0       	rcall	.+0      	; 0x1998 <printmenu+0x42>
    1998:	ed b7       	in	r30, 0x3d	; 61
    199a:	fe b7       	in	r31, 0x3e	; 62
    199c:	31 96       	adiw	r30, 0x01	; 1
    199e:	8f e0       	ldi	r24, 0x0F	; 15
    19a0:	94 e0       	ldi	r25, 0x04	; 4
    19a2:	91 83       	std	Z+1, r25	; 0x01
    19a4:	80 83       	st	Z, r24
    19a6:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    19aa:	0f 90       	pop	r0
    19ac:	0f 90       	pop	r0
        printf("\n3) Set array value");	
    19ae:	00 d0       	rcall	.+0      	; 0x19b0 <printmenu+0x5a>
    19b0:	ed b7       	in	r30, 0x3d	; 61
    19b2:	fe b7       	in	r31, 0x3e	; 62
    19b4:	31 96       	adiw	r30, 0x01	; 1
    19b6:	85 e2       	ldi	r24, 0x25	; 37
    19b8:	94 e0       	ldi	r25, 0x04	; 4
    19ba:	91 83       	std	Z+1, r25	; 0x01
    19bc:	80 83       	st	Z, r24
    19be:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    19c2:	0f 90       	pop	r0
    19c4:	0f 90       	pop	r0
	  printf("\n\n4) Read All Register values");
    19c6:	00 d0       	rcall	.+0      	; 0x19c8 <printmenu+0x72>
    19c8:	ed b7       	in	r30, 0x3d	; 61
    19ca:	fe b7       	in	r31, 0x3e	; 62
    19cc:	31 96       	adiw	r30, 0x01	; 1
    19ce:	89 e3       	ldi	r24, 0x39	; 57
    19d0:	94 e0       	ldi	r25, 0x04	; 4
    19d2:	91 83       	std	Z+1, r25	; 0x01
    19d4:	80 83       	st	Z, r24
    19d6:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    19da:	0f 90       	pop	r0
    19dc:	0f 90       	pop	r0
	    printf("\n5) Seek Up");
    19de:	00 d0       	rcall	.+0      	; 0x19e0 <printmenu+0x8a>
    19e0:	ed b7       	in	r30, 0x3d	; 61
    19e2:	fe b7       	in	r31, 0x3e	; 62
    19e4:	31 96       	adiw	r30, 0x01	; 1
    19e6:	87 e5       	ldi	r24, 0x57	; 87
    19e8:	94 e0       	ldi	r25, 0x04	; 4
    19ea:	91 83       	std	Z+1, r25	; 0x01
    19ec:	80 83       	st	Z, r24
    19ee:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    19f2:	0f 90       	pop	r0
    19f4:	0f 90       	pop	r0
	    printf("\n6) Seek Down");		
    19f6:	00 d0       	rcall	.+0      	; 0x19f8 <printmenu+0xa2>
    19f8:	ed b7       	in	r30, 0x3d	; 61
    19fa:	fe b7       	in	r31, 0x3e	; 62
    19fc:	31 96       	adiw	r30, 0x01	; 1
    19fe:	83 e6       	ldi	r24, 0x63	; 99
    1a00:	94 e0       	ldi	r25, 0x04	; 4
    1a02:	91 83       	std	Z+1, r25	; 0x01
    1a04:	80 83       	st	Z, r24
    1a06:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1a0a:	0f 90       	pop	r0
    1a0c:	0f 90       	pop	r0
		printf("\n7) Send Calibration Values");
    1a0e:	00 d0       	rcall	.+0      	; 0x1a10 <printmenu+0xba>
    1a10:	ed b7       	in	r30, 0x3d	; 61
    1a12:	fe b7       	in	r31, 0x3e	; 62
    1a14:	31 96       	adiw	r30, 0x01	; 1
    1a16:	81 e7       	ldi	r24, 0x71	; 113
    1a18:	94 e0       	ldi	r25, 0x04	; 4
    1a1a:	91 83       	std	Z+1, r25	; 0x01
    1a1c:	80 83       	st	Z, r24
    1a1e:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1a22:	0f 90       	pop	r0
    1a24:	0f 90       	pop	r0
	    printf("\n8) Volume Up");
    1a26:	00 d0       	rcall	.+0      	; 0x1a28 <printmenu+0xd2>
    1a28:	ed b7       	in	r30, 0x3d	; 61
    1a2a:	fe b7       	in	r31, 0x3e	; 62
    1a2c:	31 96       	adiw	r30, 0x01	; 1
    1a2e:	8d e8       	ldi	r24, 0x8D	; 141
    1a30:	94 e0       	ldi	r25, 0x04	; 4
    1a32:	91 83       	std	Z+1, r25	; 0x01
    1a34:	80 83       	st	Z, r24
    1a36:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1a3a:	0f 90       	pop	r0
    1a3c:	0f 90       	pop	r0
	    printf("\n9) Volume Down");	
    1a3e:	00 d0       	rcall	.+0      	; 0x1a40 <printmenu+0xea>
    1a40:	ed b7       	in	r30, 0x3d	; 61
    1a42:	fe b7       	in	r31, 0x3e	; 62
    1a44:	31 96       	adiw	r30, 0x01	; 1
    1a46:	8b e9       	ldi	r24, 0x9B	; 155
    1a48:	94 e0       	ldi	r25, 0x04	; 4
    1a4a:	91 83       	std	Z+1, r25	; 0x01
    1a4c:	80 83       	st	Z, r24
    1a4e:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1a52:	0f 90       	pop	r0
    1a54:	0f 90       	pop	r0
	    printf("\nm) mute");
    1a56:	00 d0       	rcall	.+0      	; 0x1a58 <printmenu+0x102>
    1a58:	ed b7       	in	r30, 0x3d	; 61
    1a5a:	fe b7       	in	r31, 0x3e	; 62
    1a5c:	31 96       	adiw	r30, 0x01	; 1
    1a5e:	8b ea       	ldi	r24, 0xAB	; 171
    1a60:	94 e0       	ldi	r25, 0x04	; 4
    1a62:	91 83       	std	Z+1, r25	; 0x01
    1a64:	80 83       	st	Z, r24
    1a66:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1a6a:	0f 90       	pop	r0
    1a6c:	0f 90       	pop	r0
	    printf("\nu) unmute");			
    1a6e:	00 d0       	rcall	.+0      	; 0x1a70 <printmenu+0x11a>
    1a70:	ed b7       	in	r30, 0x3d	; 61
    1a72:	fe b7       	in	r31, 0x3e	; 62
    1a74:	31 96       	adiw	r30, 0x01	; 1
    1a76:	84 eb       	ldi	r24, 0xB4	; 180
    1a78:	94 e0       	ldi	r25, 0x04	; 4
    1a7a:	91 83       	std	Z+1, r25	; 0x01
    1a7c:	80 83       	st	Z, r24
    1a7e:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1a82:	0f 90       	pop	r0
    1a84:	0f 90       	pop	r0
}
    1a86:	cf 91       	pop	r28
    1a88:	df 91       	pop	r29
    1a8a:	08 95       	ret

00001a8c <set_array_value>:

	
void set_array_value(char option)
{
    1a8c:	df 93       	push	r29
    1a8e:	cf 93       	push	r28
    1a90:	cd b7       	in	r28, 0x3d	; 61
    1a92:	de b7       	in	r29, 0x3e	; 62
    1a94:	69 97       	sbiw	r28, 0x19	; 25
    1a96:	0f b6       	in	r0, 0x3f	; 63
    1a98:	f8 94       	cli
    1a9a:	de bf       	out	0x3e, r29	; 62
    1a9c:	0f be       	out	0x3f, r0	; 63
    1a9e:	cd bf       	out	0x3d, r28	; 61
    1aa0:	89 83       	std	Y+1, r24	; 0x01
	//This function changes the values in the array containing the default values for the ar1000
	//it does not change the values in the ar1000, you will need to use the "send array values"
	//function in order to send the new values to the ar1000	
	
	printf("\n\nArray Address (2 digit hex value): ");
    1aa2:	00 d0       	rcall	.+0      	; 0x1aa4 <set_array_value+0x18>
    1aa4:	ed b7       	in	r30, 0x3d	; 61
    1aa6:	fe b7       	in	r31, 0x3e	; 62
    1aa8:	31 96       	adiw	r30, 0x01	; 1
    1aaa:	8f eb       	ldi	r24, 0xBF	; 191
    1aac:	94 e0       	ldi	r25, 0x04	; 4
    1aae:	91 83       	std	Z+1, r25	; 0x01
    1ab0:	80 83       	st	Z, r24
    1ab2:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1ab6:	0f 90       	pop	r0
    1ab8:	0f 90       	pop	r0

	while( !(UCSR0A & (1<<RXC0)) );
    1aba:	e0 ec       	ldi	r30, 0xC0	; 192
    1abc:	f0 e0       	ldi	r31, 0x00	; 0
    1abe:	80 81       	ld	r24, Z
    1ac0:	88 23       	and	r24, r24
    1ac2:	dc f7       	brge	.-10     	; 0x1aba <set_array_value+0x2e>
	byte1 = UDR0;
    1ac4:	e6 ec       	ldi	r30, 0xC6	; 198
    1ac6:	f0 e0       	ldi	r31, 0x00	; 0
    1ac8:	80 81       	ld	r24, Z
    1aca:	80 93 bd 05 	sts	0x05BD, r24
	printf("%c", byte1);	
    1ace:	80 91 bd 05 	lds	r24, 0x05BD
    1ad2:	88 2f       	mov	r24, r24
    1ad4:	90 e0       	ldi	r25, 0x00	; 0
    1ad6:	0e 94 a4 12 	call	0x2548	; 0x2548 <putchar>
	while( !(UCSR0A & (1<<RXC0)) );
    1ada:	e0 ec       	ldi	r30, 0xC0	; 192
    1adc:	f0 e0       	ldi	r31, 0x00	; 0
    1ade:	80 81       	ld	r24, Z
    1ae0:	88 23       	and	r24, r24
    1ae2:	dc f7       	brge	.-10     	; 0x1ada <set_array_value+0x4e>
	byte2 = UDR0;
    1ae4:	e6 ec       	ldi	r30, 0xC6	; 198
    1ae6:	f0 e0       	ldi	r31, 0x00	; 0
    1ae8:	80 81       	ld	r24, Z
    1aea:	80 93 bc 05 	sts	0x05BC, r24
	printf("%c\n", byte2);
    1aee:	80 91 bc 05 	lds	r24, 0x05BC
    1af2:	28 2f       	mov	r18, r24
    1af4:	30 e0       	ldi	r19, 0x00	; 0
    1af6:	00 d0       	rcall	.+0      	; 0x1af8 <set_array_value+0x6c>
    1af8:	00 d0       	rcall	.+0      	; 0x1afa <set_array_value+0x6e>
    1afa:	ed b7       	in	r30, 0x3d	; 61
    1afc:	fe b7       	in	r31, 0x3e	; 62
    1afe:	31 96       	adiw	r30, 0x01	; 1
    1b00:	85 ee       	ldi	r24, 0xE5	; 229
    1b02:	94 e0       	ldi	r25, 0x04	; 4
    1b04:	91 83       	std	Z+1, r25	; 0x01
    1b06:	80 83       	st	Z, r24
    1b08:	33 83       	std	Z+3, r19	; 0x03
    1b0a:	22 83       	std	Z+2, r18	; 0x02
    1b0c:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1b10:	0f 90       	pop	r0
    1b12:	0f 90       	pop	r0
    1b14:	0f 90       	pop	r0
    1b16:	0f 90       	pop	r0
	
	if((byte1 <58 )& (byte1>47))
    1b18:	80 91 bd 05 	lds	r24, 0x05BD
    1b1c:	19 8e       	std	Y+25, r1	; 0x19
    1b1e:	8a 33       	cpi	r24, 0x3A	; 58
    1b20:	10 f4       	brcc	.+4      	; 0x1b26 <set_array_value+0x9a>
    1b22:	81 e0       	ldi	r24, 0x01	; 1
    1b24:	89 8f       	std	Y+25, r24	; 0x19
    1b26:	80 91 bd 05 	lds	r24, 0x05BD
    1b2a:	18 8e       	std	Y+24, r1	; 0x18
    1b2c:	80 33       	cpi	r24, 0x30	; 48
    1b2e:	10 f0       	brcs	.+4      	; 0x1b34 <set_array_value+0xa8>
    1b30:	91 e0       	ldi	r25, 0x01	; 1
    1b32:	98 8f       	std	Y+24, r25	; 0x18
    1b34:	89 8d       	ldd	r24, Y+25	; 0x19
    1b36:	98 8d       	ldd	r25, Y+24	; 0x18
    1b38:	89 23       	and	r24, r25
    1b3a:	88 23       	and	r24, r24
    1b3c:	39 f0       	breq	.+14     	; 0x1b4c <set_array_value+0xc0>
	{		
		byte = (byte1 - 48)<<4;		
    1b3e:	80 91 bd 05 	lds	r24, 0x05BD
    1b42:	80 53       	subi	r24, 0x30	; 48
    1b44:	82 95       	swap	r24
    1b46:	80 7f       	andi	r24, 0xF0	; 240
    1b48:	80 93 be 05 	sts	0x05BE, r24
	};
	
	if((byte1 <103 )& (byte1>96))
    1b4c:	80 91 bd 05 	lds	r24, 0x05BD
    1b50:	1f 8a       	std	Y+23, r1	; 0x17
    1b52:	87 36       	cpi	r24, 0x67	; 103
    1b54:	10 f4       	brcc	.+4      	; 0x1b5a <set_array_value+0xce>
    1b56:	81 e0       	ldi	r24, 0x01	; 1
    1b58:	8f 8b       	std	Y+23, r24	; 0x17
    1b5a:	80 91 bd 05 	lds	r24, 0x05BD
    1b5e:	1e 8a       	std	Y+22, r1	; 0x16
    1b60:	81 36       	cpi	r24, 0x61	; 97
    1b62:	10 f0       	brcs	.+4      	; 0x1b68 <set_array_value+0xdc>
    1b64:	91 e0       	ldi	r25, 0x01	; 1
    1b66:	9e 8b       	std	Y+22, r25	; 0x16
    1b68:	8f 89       	ldd	r24, Y+23	; 0x17
    1b6a:	9e 89       	ldd	r25, Y+22	; 0x16
    1b6c:	89 23       	and	r24, r25
    1b6e:	88 23       	and	r24, r24
    1b70:	61 f0       	breq	.+24     	; 0x1b8a <set_array_value+0xfe>
	{		
		byte1 = chartohex(byte1);
    1b72:	80 91 bd 05 	lds	r24, 0x05BD
    1b76:	0e 94 65 12 	call	0x24ca	; 0x24ca <chartohex>
    1b7a:	80 93 bd 05 	sts	0x05BD, r24
	    byte = (byte1)<<4;
    1b7e:	80 91 bd 05 	lds	r24, 0x05BD
    1b82:	82 95       	swap	r24
    1b84:	80 7f       	andi	r24, 0xF0	; 240
    1b86:	80 93 be 05 	sts	0x05BE, r24
	};
	
	if((byte2 <58) & (byte2>47))
    1b8a:	80 91 bc 05 	lds	r24, 0x05BC
    1b8e:	1d 8a       	std	Y+21, r1	; 0x15
    1b90:	8a 33       	cpi	r24, 0x3A	; 58
    1b92:	10 f4       	brcc	.+4      	; 0x1b98 <set_array_value+0x10c>
    1b94:	81 e0       	ldi	r24, 0x01	; 1
    1b96:	8d 8b       	std	Y+21, r24	; 0x15
    1b98:	80 91 bc 05 	lds	r24, 0x05BC
    1b9c:	1c 8a       	std	Y+20, r1	; 0x14
    1b9e:	80 33       	cpi	r24, 0x30	; 48
    1ba0:	10 f0       	brcs	.+4      	; 0x1ba6 <set_array_value+0x11a>
    1ba2:	91 e0       	ldi	r25, 0x01	; 1
    1ba4:	9c 8b       	std	Y+20, r25	; 0x14
    1ba6:	8d 89       	ldd	r24, Y+21	; 0x15
    1ba8:	9c 89       	ldd	r25, Y+20	; 0x14
    1baa:	89 23       	and	r24, r25
    1bac:	88 23       	and	r24, r24
    1bae:	49 f0       	breq	.+18     	; 0x1bc2 <set_array_value+0x136>
	{
		byte = ((byte2 - 48) | byte);
    1bb0:	80 91 bc 05 	lds	r24, 0x05BC
    1bb4:	80 53       	subi	r24, 0x30	; 48
    1bb6:	98 2f       	mov	r25, r24
    1bb8:	80 91 be 05 	lds	r24, 0x05BE
    1bbc:	89 2b       	or	r24, r25
    1bbe:	80 93 be 05 	sts	0x05BE, r24
	};
	
	if((byte2 <103 )& (byte2>96))
    1bc2:	80 91 bc 05 	lds	r24, 0x05BC
    1bc6:	1b 8a       	std	Y+19, r1	; 0x13
    1bc8:	87 36       	cpi	r24, 0x67	; 103
    1bca:	10 f4       	brcc	.+4      	; 0x1bd0 <set_array_value+0x144>
    1bcc:	81 e0       	ldi	r24, 0x01	; 1
    1bce:	8b 8b       	std	Y+19, r24	; 0x13
    1bd0:	80 91 bc 05 	lds	r24, 0x05BC
    1bd4:	1a 8a       	std	Y+18, r1	; 0x12
    1bd6:	81 36       	cpi	r24, 0x61	; 97
    1bd8:	10 f0       	brcs	.+4      	; 0x1bde <set_array_value+0x152>
    1bda:	91 e0       	ldi	r25, 0x01	; 1
    1bdc:	9a 8b       	std	Y+18, r25	; 0x12
    1bde:	8b 89       	ldd	r24, Y+19	; 0x13
    1be0:	9a 89       	ldd	r25, Y+18	; 0x12
    1be2:	89 23       	and	r24, r25
    1be4:	88 23       	and	r24, r24
    1be6:	69 f0       	breq	.+26     	; 0x1c02 <set_array_value+0x176>
	{
        byte2 = chartohex(byte2);
    1be8:	80 91 bc 05 	lds	r24, 0x05BC
    1bec:	0e 94 65 12 	call	0x24ca	; 0x24ca <chartohex>
    1bf0:	80 93 bc 05 	sts	0x05BC, r24
        byte = ((byte2) | byte);
    1bf4:	90 91 bc 05 	lds	r25, 0x05BC
    1bf8:	80 91 be 05 	lds	r24, 0x05BE
    1bfc:	89 2b       	or	r24, r25
    1bfe:	80 93 be 05 	sts	0x05BE, r24
	};
	printf("Array Address is: %x", byte);
    1c02:	80 91 be 05 	lds	r24, 0x05BE
    1c06:	28 2f       	mov	r18, r24
    1c08:	30 e0       	ldi	r19, 0x00	; 0
    1c0a:	00 d0       	rcall	.+0      	; 0x1c0c <set_array_value+0x180>
    1c0c:	00 d0       	rcall	.+0      	; 0x1c0e <set_array_value+0x182>
    1c0e:	ed b7       	in	r30, 0x3d	; 61
    1c10:	fe b7       	in	r31, 0x3e	; 62
    1c12:	31 96       	adiw	r30, 0x01	; 1
    1c14:	89 ee       	ldi	r24, 0xE9	; 233
    1c16:	94 e0       	ldi	r25, 0x04	; 4
    1c18:	91 83       	std	Z+1, r25	; 0x01
    1c1a:	80 83       	st	Z, r24
    1c1c:	33 83       	std	Z+3, r19	; 0x03
    1c1e:	22 83       	std	Z+2, r18	; 0x02
    1c20:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1c24:	0f 90       	pop	r0
    1c26:	0f 90       	pop	r0
    1c28:	0f 90       	pop	r0
    1c2a:	0f 90       	pop	r0
    
    
   	printf("\n\nArray value (4 digit hex value): ");
    1c2c:	00 d0       	rcall	.+0      	; 0x1c2e <set_array_value+0x1a2>
    1c2e:	ed b7       	in	r30, 0x3d	; 61
    1c30:	fe b7       	in	r31, 0x3e	; 62
    1c32:	31 96       	adiw	r30, 0x01	; 1
    1c34:	8e ef       	ldi	r24, 0xFE	; 254
    1c36:	94 e0       	ldi	r25, 0x04	; 4
    1c38:	91 83       	std	Z+1, r25	; 0x01
    1c3a:	80 83       	st	Z, r24
    1c3c:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1c40:	0f 90       	pop	r0
    1c42:	0f 90       	pop	r0

	while( !(UCSR0A & (1<<RXC0)) );
    1c44:	e0 ec       	ldi	r30, 0xC0	; 192
    1c46:	f0 e0       	ldi	r31, 0x00	; 0
    1c48:	80 81       	ld	r24, Z
    1c4a:	88 23       	and	r24, r24
    1c4c:	dc f7       	brge	.-10     	; 0x1c44 <set_array_value+0x1b8>
	value1 = UDR0;
    1c4e:	e6 ec       	ldi	r30, 0xC6	; 198
    1c50:	f0 e0       	ldi	r31, 0x00	; 0
    1c52:	80 81       	ld	r24, Z
    1c54:	88 2f       	mov	r24, r24
    1c56:	90 e0       	ldi	r25, 0x00	; 0
    1c58:	90 93 b5 05 	sts	0x05B5, r25
    1c5c:	80 93 b4 05 	sts	0x05B4, r24
	printf("%c", value1);
    1c60:	80 91 b4 05 	lds	r24, 0x05B4
    1c64:	90 91 b5 05 	lds	r25, 0x05B5
    1c68:	0e 94 a4 12 	call	0x2548	; 0x2548 <putchar>
	
	while( !(UCSR0A & (1<<RXC0)) );
    1c6c:	e0 ec       	ldi	r30, 0xC0	; 192
    1c6e:	f0 e0       	ldi	r31, 0x00	; 0
    1c70:	80 81       	ld	r24, Z
    1c72:	88 23       	and	r24, r24
    1c74:	dc f7       	brge	.-10     	; 0x1c6c <set_array_value+0x1e0>
	value2 = UDR0;
    1c76:	e6 ec       	ldi	r30, 0xC6	; 198
    1c78:	f0 e0       	ldi	r31, 0x00	; 0
    1c7a:	80 81       	ld	r24, Z
    1c7c:	88 2f       	mov	r24, r24
    1c7e:	90 e0       	ldi	r25, 0x00	; 0
    1c80:	90 93 b7 05 	sts	0x05B7, r25
    1c84:	80 93 b6 05 	sts	0x05B6, r24
	printf("%c", value2);
    1c88:	80 91 b6 05 	lds	r24, 0x05B6
    1c8c:	90 91 b7 05 	lds	r25, 0x05B7
    1c90:	0e 94 a4 12 	call	0x2548	; 0x2548 <putchar>
	
    while( !(UCSR0A & (1<<RXC0)) );
    1c94:	e0 ec       	ldi	r30, 0xC0	; 192
    1c96:	f0 e0       	ldi	r31, 0x00	; 0
    1c98:	80 81       	ld	r24, Z
    1c9a:	88 23       	and	r24, r24
    1c9c:	dc f7       	brge	.-10     	; 0x1c94 <set_array_value+0x208>
	value3 = UDR0;
    1c9e:	e6 ec       	ldi	r30, 0xC6	; 198
    1ca0:	f0 e0       	ldi	r31, 0x00	; 0
    1ca2:	80 81       	ld	r24, Z
    1ca4:	88 2f       	mov	r24, r24
    1ca6:	90 e0       	ldi	r25, 0x00	; 0
    1ca8:	90 93 b9 05 	sts	0x05B9, r25
    1cac:	80 93 b8 05 	sts	0x05B8, r24
	printf("%c", value3);
    1cb0:	80 91 b8 05 	lds	r24, 0x05B8
    1cb4:	90 91 b9 05 	lds	r25, 0x05B9
    1cb8:	0e 94 a4 12 	call	0x2548	; 0x2548 <putchar>
	
    while( !(UCSR0A & (1<<RXC0)) );
    1cbc:	e0 ec       	ldi	r30, 0xC0	; 192
    1cbe:	f0 e0       	ldi	r31, 0x00	; 0
    1cc0:	80 81       	ld	r24, Z
    1cc2:	88 23       	and	r24, r24
    1cc4:	dc f7       	brge	.-10     	; 0x1cbc <set_array_value+0x230>
	value4 = UDR0;
    1cc6:	e6 ec       	ldi	r30, 0xC6	; 198
    1cc8:	f0 e0       	ldi	r31, 0x00	; 0
    1cca:	80 81       	ld	r24, Z
    1ccc:	88 2f       	mov	r24, r24
    1cce:	90 e0       	ldi	r25, 0x00	; 0
    1cd0:	90 93 bb 05 	sts	0x05BB, r25
    1cd4:	80 93 ba 05 	sts	0x05BA, r24
	printf("%c\n", value4);
    1cd8:	20 91 ba 05 	lds	r18, 0x05BA
    1cdc:	30 91 bb 05 	lds	r19, 0x05BB
    1ce0:	00 d0       	rcall	.+0      	; 0x1ce2 <set_array_value+0x256>
    1ce2:	00 d0       	rcall	.+0      	; 0x1ce4 <set_array_value+0x258>
    1ce4:	ed b7       	in	r30, 0x3d	; 61
    1ce6:	fe b7       	in	r31, 0x3e	; 62
    1ce8:	31 96       	adiw	r30, 0x01	; 1
    1cea:	85 ee       	ldi	r24, 0xE5	; 229
    1cec:	94 e0       	ldi	r25, 0x04	; 4
    1cee:	91 83       	std	Z+1, r25	; 0x01
    1cf0:	80 83       	st	Z, r24
    1cf2:	33 83       	std	Z+3, r19	; 0x03
    1cf4:	22 83       	std	Z+2, r18	; 0x02
    1cf6:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1cfa:	0f 90       	pop	r0
    1cfc:	0f 90       	pop	r0
    1cfe:	0f 90       	pop	r0
    1d00:	0f 90       	pop	r0
    
    if((value1 <58 )& (value1>47))
    1d02:	80 91 b4 05 	lds	r24, 0x05B4
    1d06:	90 91 b5 05 	lds	r25, 0x05B5
    1d0a:	19 8a       	std	Y+17, r1	; 0x11
    1d0c:	8a 33       	cpi	r24, 0x3A	; 58
    1d0e:	91 05       	cpc	r25, r1
    1d10:	10 f4       	brcc	.+4      	; 0x1d16 <set_array_value+0x28a>
    1d12:	81 e0       	ldi	r24, 0x01	; 1
    1d14:	89 8b       	std	Y+17, r24	; 0x11
    1d16:	80 91 b4 05 	lds	r24, 0x05B4
    1d1a:	90 91 b5 05 	lds	r25, 0x05B5
    1d1e:	18 8a       	std	Y+16, r1	; 0x10
    1d20:	80 33       	cpi	r24, 0x30	; 48
    1d22:	91 05       	cpc	r25, r1
    1d24:	10 f0       	brcs	.+4      	; 0x1d2a <set_array_value+0x29e>
    1d26:	91 e0       	ldi	r25, 0x01	; 1
    1d28:	98 8b       	std	Y+16, r25	; 0x10
    1d2a:	89 89       	ldd	r24, Y+17	; 0x11
    1d2c:	98 89       	ldd	r25, Y+16	; 0x10
    1d2e:	89 23       	and	r24, r25
    1d30:	88 23       	and	r24, r24
    1d32:	11 f1       	breq	.+68     	; 0x1d78 <set_array_value+0x2ec>
	{		
		value = (value1 - 48)<<12;
    1d34:	80 91 b4 05 	lds	r24, 0x05B4
    1d38:	90 91 b5 05 	lds	r25, 0x05B5
    1d3c:	c0 97       	sbiw	r24, 0x30	; 48
    1d3e:	98 2f       	mov	r25, r24
    1d40:	88 27       	eor	r24, r24
    1d42:	92 95       	swap	r25
    1d44:	90 7f       	andi	r25, 0xF0	; 240
    1d46:	90 93 b3 05 	sts	0x05B3, r25
    1d4a:	80 93 b2 05 	sts	0x05B2, r24
		printf("%x\n", value);		
    1d4e:	20 91 b2 05 	lds	r18, 0x05B2
    1d52:	30 91 b3 05 	lds	r19, 0x05B3
    1d56:	00 d0       	rcall	.+0      	; 0x1d58 <set_array_value+0x2cc>
    1d58:	00 d0       	rcall	.+0      	; 0x1d5a <set_array_value+0x2ce>
    1d5a:	ed b7       	in	r30, 0x3d	; 61
    1d5c:	fe b7       	in	r31, 0x3e	; 62
    1d5e:	31 96       	adiw	r30, 0x01	; 1
    1d60:	82 e2       	ldi	r24, 0x22	; 34
    1d62:	95 e0       	ldi	r25, 0x05	; 5
    1d64:	91 83       	std	Z+1, r25	; 0x01
    1d66:	80 83       	st	Z, r24
    1d68:	33 83       	std	Z+3, r19	; 0x03
    1d6a:	22 83       	std	Z+2, r18	; 0x02
    1d6c:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1d70:	0f 90       	pop	r0
    1d72:	0f 90       	pop	r0
    1d74:	0f 90       	pop	r0
    1d76:	0f 90       	pop	r0
	}
	
	if((value1 <103 )& (value1>96))
    1d78:	80 91 b4 05 	lds	r24, 0x05B4
    1d7c:	90 91 b5 05 	lds	r25, 0x05B5
    1d80:	1f 86       	std	Y+15, r1	; 0x0f
    1d82:	87 36       	cpi	r24, 0x67	; 103
    1d84:	91 05       	cpc	r25, r1
    1d86:	10 f4       	brcc	.+4      	; 0x1d8c <set_array_value+0x300>
    1d88:	81 e0       	ldi	r24, 0x01	; 1
    1d8a:	8f 87       	std	Y+15, r24	; 0x0f
    1d8c:	80 91 b4 05 	lds	r24, 0x05B4
    1d90:	90 91 b5 05 	lds	r25, 0x05B5
    1d94:	1e 86       	std	Y+14, r1	; 0x0e
    1d96:	81 36       	cpi	r24, 0x61	; 97
    1d98:	91 05       	cpc	r25, r1
    1d9a:	10 f0       	brcs	.+4      	; 0x1da0 <set_array_value+0x314>
    1d9c:	91 e0       	ldi	r25, 0x01	; 1
    1d9e:	9e 87       	std	Y+14, r25	; 0x0e
    1da0:	8f 85       	ldd	r24, Y+15	; 0x0f
    1da2:	9e 85       	ldd	r25, Y+14	; 0x0e
    1da4:	89 23       	and	r24, r25
    1da6:	88 23       	and	r24, r24
    1da8:	69 f1       	breq	.+90     	; 0x1e04 <set_array_value+0x378>
	{		
		value1 = chartohex(value1);
    1daa:	80 91 b4 05 	lds	r24, 0x05B4
    1dae:	90 91 b5 05 	lds	r25, 0x05B5
    1db2:	0e 94 65 12 	call	0x24ca	; 0x24ca <chartohex>
    1db6:	88 2f       	mov	r24, r24
    1db8:	90 e0       	ldi	r25, 0x00	; 0
    1dba:	90 93 b5 05 	sts	0x05B5, r25
    1dbe:	80 93 b4 05 	sts	0x05B4, r24
	    value = (value1)<<12;
    1dc2:	80 91 b4 05 	lds	r24, 0x05B4
    1dc6:	90 91 b5 05 	lds	r25, 0x05B5
    1dca:	98 2f       	mov	r25, r24
    1dcc:	88 27       	eor	r24, r24
    1dce:	92 95       	swap	r25
    1dd0:	90 7f       	andi	r25, 0xF0	; 240
    1dd2:	90 93 b3 05 	sts	0x05B3, r25
    1dd6:	80 93 b2 05 	sts	0x05B2, r24
		printf("%x\n", value);
    1dda:	20 91 b2 05 	lds	r18, 0x05B2
    1dde:	30 91 b3 05 	lds	r19, 0x05B3
    1de2:	00 d0       	rcall	.+0      	; 0x1de4 <set_array_value+0x358>
    1de4:	00 d0       	rcall	.+0      	; 0x1de6 <set_array_value+0x35a>
    1de6:	ed b7       	in	r30, 0x3d	; 61
    1de8:	fe b7       	in	r31, 0x3e	; 62
    1dea:	31 96       	adiw	r30, 0x01	; 1
    1dec:	82 e2       	ldi	r24, 0x22	; 34
    1dee:	95 e0       	ldi	r25, 0x05	; 5
    1df0:	91 83       	std	Z+1, r25	; 0x01
    1df2:	80 83       	st	Z, r24
    1df4:	33 83       	std	Z+3, r19	; 0x03
    1df6:	22 83       	std	Z+2, r18	; 0x02
    1df8:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1dfc:	0f 90       	pop	r0
    1dfe:	0f 90       	pop	r0
    1e00:	0f 90       	pop	r0
    1e02:	0f 90       	pop	r0
	}
	
	if((value2 <58) & (value2>47))
    1e04:	80 91 b6 05 	lds	r24, 0x05B6
    1e08:	90 91 b7 05 	lds	r25, 0x05B7
    1e0c:	1d 86       	std	Y+13, r1	; 0x0d
    1e0e:	8a 33       	cpi	r24, 0x3A	; 58
    1e10:	91 05       	cpc	r25, r1
    1e12:	10 f4       	brcc	.+4      	; 0x1e18 <set_array_value+0x38c>
    1e14:	81 e0       	ldi	r24, 0x01	; 1
    1e16:	8d 87       	std	Y+13, r24	; 0x0d
    1e18:	80 91 b6 05 	lds	r24, 0x05B6
    1e1c:	90 91 b7 05 	lds	r25, 0x05B7
    1e20:	1c 86       	std	Y+12, r1	; 0x0c
    1e22:	80 33       	cpi	r24, 0x30	; 48
    1e24:	91 05       	cpc	r25, r1
    1e26:	10 f0       	brcs	.+4      	; 0x1e2c <set_array_value+0x3a0>
    1e28:	91 e0       	ldi	r25, 0x01	; 1
    1e2a:	9c 87       	std	Y+12, r25	; 0x0c
    1e2c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e2e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1e30:	89 23       	and	r24, r25
    1e32:	88 23       	and	r24, r24
    1e34:	31 f1       	breq	.+76     	; 0x1e82 <set_array_value+0x3f6>
	{
		value = (((value2 - 48)<<8) | value);
    1e36:	80 91 b6 05 	lds	r24, 0x05B6
    1e3a:	90 91 b7 05 	lds	r25, 0x05B7
    1e3e:	c0 97       	sbiw	r24, 0x30	; 48
    1e40:	38 2f       	mov	r19, r24
    1e42:	22 27       	eor	r18, r18
    1e44:	80 91 b2 05 	lds	r24, 0x05B2
    1e48:	90 91 b3 05 	lds	r25, 0x05B3
    1e4c:	82 2b       	or	r24, r18
    1e4e:	93 2b       	or	r25, r19
    1e50:	90 93 b3 05 	sts	0x05B3, r25
    1e54:	80 93 b2 05 	sts	0x05B2, r24
		printf("%x\n", value);
    1e58:	20 91 b2 05 	lds	r18, 0x05B2
    1e5c:	30 91 b3 05 	lds	r19, 0x05B3
    1e60:	00 d0       	rcall	.+0      	; 0x1e62 <set_array_value+0x3d6>
    1e62:	00 d0       	rcall	.+0      	; 0x1e64 <set_array_value+0x3d8>
    1e64:	ed b7       	in	r30, 0x3d	; 61
    1e66:	fe b7       	in	r31, 0x3e	; 62
    1e68:	31 96       	adiw	r30, 0x01	; 1
    1e6a:	82 e2       	ldi	r24, 0x22	; 34
    1e6c:	95 e0       	ldi	r25, 0x05	; 5
    1e6e:	91 83       	std	Z+1, r25	; 0x01
    1e70:	80 83       	st	Z, r24
    1e72:	33 83       	std	Z+3, r19	; 0x03
    1e74:	22 83       	std	Z+2, r18	; 0x02
    1e76:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1e7a:	0f 90       	pop	r0
    1e7c:	0f 90       	pop	r0
    1e7e:	0f 90       	pop	r0
    1e80:	0f 90       	pop	r0
	}
	
	if((value2 <103 )& (value2>96))
    1e82:	80 91 b6 05 	lds	r24, 0x05B6
    1e86:	90 91 b7 05 	lds	r25, 0x05B7
    1e8a:	1b 86       	std	Y+11, r1	; 0x0b
    1e8c:	87 36       	cpi	r24, 0x67	; 103
    1e8e:	91 05       	cpc	r25, r1
    1e90:	10 f4       	brcc	.+4      	; 0x1e96 <set_array_value+0x40a>
    1e92:	81 e0       	ldi	r24, 0x01	; 1
    1e94:	8b 87       	std	Y+11, r24	; 0x0b
    1e96:	80 91 b6 05 	lds	r24, 0x05B6
    1e9a:	90 91 b7 05 	lds	r25, 0x05B7
    1e9e:	1a 86       	std	Y+10, r1	; 0x0a
    1ea0:	81 36       	cpi	r24, 0x61	; 97
    1ea2:	91 05       	cpc	r25, r1
    1ea4:	10 f0       	brcs	.+4      	; 0x1eaa <set_array_value+0x41e>
    1ea6:	91 e0       	ldi	r25, 0x01	; 1
    1ea8:	9a 87       	std	Y+10, r25	; 0x0a
    1eaa:	8b 85       	ldd	r24, Y+11	; 0x0b
    1eac:	9a 85       	ldd	r25, Y+10	; 0x0a
    1eae:	89 23       	and	r24, r25
    1eb0:	88 23       	and	r24, r24
    1eb2:	89 f1       	breq	.+98     	; 0x1f16 <set_array_value+0x48a>
	{
        value2 = chartohex(value2);
    1eb4:	80 91 b6 05 	lds	r24, 0x05B6
    1eb8:	90 91 b7 05 	lds	r25, 0x05B7
    1ebc:	0e 94 65 12 	call	0x24ca	; 0x24ca <chartohex>
    1ec0:	88 2f       	mov	r24, r24
    1ec2:	90 e0       	ldi	r25, 0x00	; 0
    1ec4:	90 93 b7 05 	sts	0x05B7, r25
    1ec8:	80 93 b6 05 	sts	0x05B6, r24
        value = (((value2)<<8) | value);
    1ecc:	80 91 b6 05 	lds	r24, 0x05B6
    1ed0:	90 91 b7 05 	lds	r25, 0x05B7
    1ed4:	38 2f       	mov	r19, r24
    1ed6:	22 27       	eor	r18, r18
    1ed8:	80 91 b2 05 	lds	r24, 0x05B2
    1edc:	90 91 b3 05 	lds	r25, 0x05B3
    1ee0:	82 2b       	or	r24, r18
    1ee2:	93 2b       	or	r25, r19
    1ee4:	90 93 b3 05 	sts	0x05B3, r25
    1ee8:	80 93 b2 05 	sts	0x05B2, r24
		printf("%x\n", value);
    1eec:	20 91 b2 05 	lds	r18, 0x05B2
    1ef0:	30 91 b3 05 	lds	r19, 0x05B3
    1ef4:	00 d0       	rcall	.+0      	; 0x1ef6 <set_array_value+0x46a>
    1ef6:	00 d0       	rcall	.+0      	; 0x1ef8 <set_array_value+0x46c>
    1ef8:	ed b7       	in	r30, 0x3d	; 61
    1efa:	fe b7       	in	r31, 0x3e	; 62
    1efc:	31 96       	adiw	r30, 0x01	; 1
    1efe:	82 e2       	ldi	r24, 0x22	; 34
    1f00:	95 e0       	ldi	r25, 0x05	; 5
    1f02:	91 83       	std	Z+1, r25	; 0x01
    1f04:	80 83       	st	Z, r24
    1f06:	33 83       	std	Z+3, r19	; 0x03
    1f08:	22 83       	std	Z+2, r18	; 0x02
    1f0a:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1f0e:	0f 90       	pop	r0
    1f10:	0f 90       	pop	r0
    1f12:	0f 90       	pop	r0
    1f14:	0f 90       	pop	r0
	}
    
    if((value3 <58 )& (value3>47))
    1f16:	80 91 b8 05 	lds	r24, 0x05B8
    1f1a:	90 91 b9 05 	lds	r25, 0x05B9
    1f1e:	19 86       	std	Y+9, r1	; 0x09
    1f20:	8a 33       	cpi	r24, 0x3A	; 58
    1f22:	91 05       	cpc	r25, r1
    1f24:	10 f4       	brcc	.+4      	; 0x1f2a <set_array_value+0x49e>
    1f26:	81 e0       	ldi	r24, 0x01	; 1
    1f28:	89 87       	std	Y+9, r24	; 0x09
    1f2a:	80 91 b8 05 	lds	r24, 0x05B8
    1f2e:	90 91 b9 05 	lds	r25, 0x05B9
    1f32:	18 86       	std	Y+8, r1	; 0x08
    1f34:	80 33       	cpi	r24, 0x30	; 48
    1f36:	91 05       	cpc	r25, r1
    1f38:	10 f0       	brcs	.+4      	; 0x1f3e <set_array_value+0x4b2>
    1f3a:	91 e0       	ldi	r25, 0x01	; 1
    1f3c:	98 87       	std	Y+8, r25	; 0x08
    1f3e:	89 85       	ldd	r24, Y+9	; 0x09
    1f40:	98 85       	ldd	r25, Y+8	; 0x08
    1f42:	89 23       	and	r24, r25
    1f44:	88 23       	and	r24, r24
    1f46:	59 f1       	breq	.+86     	; 0x1f9e <set_array_value+0x512>
	{		
		value = (((value3 - 48)<<4) | value);	
    1f48:	80 91 b8 05 	lds	r24, 0x05B8
    1f4c:	90 91 b9 05 	lds	r25, 0x05B9
    1f50:	c0 97       	sbiw	r24, 0x30	; 48
    1f52:	9c 01       	movw	r18, r24
    1f54:	22 95       	swap	r18
    1f56:	32 95       	swap	r19
    1f58:	30 7f       	andi	r19, 0xF0	; 240
    1f5a:	32 27       	eor	r19, r18
    1f5c:	20 7f       	andi	r18, 0xF0	; 240
    1f5e:	32 27       	eor	r19, r18
    1f60:	80 91 b2 05 	lds	r24, 0x05B2
    1f64:	90 91 b3 05 	lds	r25, 0x05B3
    1f68:	82 2b       	or	r24, r18
    1f6a:	93 2b       	or	r25, r19
    1f6c:	90 93 b3 05 	sts	0x05B3, r25
    1f70:	80 93 b2 05 	sts	0x05B2, r24
		printf("%x\n", value);	
    1f74:	20 91 b2 05 	lds	r18, 0x05B2
    1f78:	30 91 b3 05 	lds	r19, 0x05B3
    1f7c:	00 d0       	rcall	.+0      	; 0x1f7e <set_array_value+0x4f2>
    1f7e:	00 d0       	rcall	.+0      	; 0x1f80 <set_array_value+0x4f4>
    1f80:	ed b7       	in	r30, 0x3d	; 61
    1f82:	fe b7       	in	r31, 0x3e	; 62
    1f84:	31 96       	adiw	r30, 0x01	; 1
    1f86:	82 e2       	ldi	r24, 0x22	; 34
    1f88:	95 e0       	ldi	r25, 0x05	; 5
    1f8a:	91 83       	std	Z+1, r25	; 0x01
    1f8c:	80 83       	st	Z, r24
    1f8e:	33 83       	std	Z+3, r19	; 0x03
    1f90:	22 83       	std	Z+2, r18	; 0x02
    1f92:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    1f96:	0f 90       	pop	r0
    1f98:	0f 90       	pop	r0
    1f9a:	0f 90       	pop	r0
    1f9c:	0f 90       	pop	r0
	}
	
	if((value3 <103 )& (value3>96))
    1f9e:	80 91 b8 05 	lds	r24, 0x05B8
    1fa2:	90 91 b9 05 	lds	r25, 0x05B9
    1fa6:	1f 82       	std	Y+7, r1	; 0x07
    1fa8:	87 36       	cpi	r24, 0x67	; 103
    1faa:	91 05       	cpc	r25, r1
    1fac:	10 f4       	brcc	.+4      	; 0x1fb2 <set_array_value+0x526>
    1fae:	81 e0       	ldi	r24, 0x01	; 1
    1fb0:	8f 83       	std	Y+7, r24	; 0x07
    1fb2:	80 91 b8 05 	lds	r24, 0x05B8
    1fb6:	90 91 b9 05 	lds	r25, 0x05B9
    1fba:	1e 82       	std	Y+6, r1	; 0x06
    1fbc:	81 36       	cpi	r24, 0x61	; 97
    1fbe:	91 05       	cpc	r25, r1
    1fc0:	10 f0       	brcs	.+4      	; 0x1fc6 <set_array_value+0x53a>
    1fc2:	91 e0       	ldi	r25, 0x01	; 1
    1fc4:	9e 83       	std	Y+6, r25	; 0x06
    1fc6:	8f 81       	ldd	r24, Y+7	; 0x07
    1fc8:	9e 81       	ldd	r25, Y+6	; 0x06
    1fca:	89 23       	and	r24, r25
    1fcc:	88 23       	and	r24, r24
    1fce:	b1 f1       	breq	.+108    	; 0x203c <set_array_value+0x5b0>
	{		
		value3 = chartohex(value3);
    1fd0:	80 91 b8 05 	lds	r24, 0x05B8
    1fd4:	90 91 b9 05 	lds	r25, 0x05B9
    1fd8:	0e 94 65 12 	call	0x24ca	; 0x24ca <chartohex>
    1fdc:	88 2f       	mov	r24, r24
    1fde:	90 e0       	ldi	r25, 0x00	; 0
    1fe0:	90 93 b9 05 	sts	0x05B9, r25
    1fe4:	80 93 b8 05 	sts	0x05B8, r24
	    value = (((value3 )<<4) | value);
    1fe8:	80 91 b8 05 	lds	r24, 0x05B8
    1fec:	90 91 b9 05 	lds	r25, 0x05B9
    1ff0:	9c 01       	movw	r18, r24
    1ff2:	22 95       	swap	r18
    1ff4:	32 95       	swap	r19
    1ff6:	30 7f       	andi	r19, 0xF0	; 240
    1ff8:	32 27       	eor	r19, r18
    1ffa:	20 7f       	andi	r18, 0xF0	; 240
    1ffc:	32 27       	eor	r19, r18
    1ffe:	80 91 b2 05 	lds	r24, 0x05B2
    2002:	90 91 b3 05 	lds	r25, 0x05B3
    2006:	82 2b       	or	r24, r18
    2008:	93 2b       	or	r25, r19
    200a:	90 93 b3 05 	sts	0x05B3, r25
    200e:	80 93 b2 05 	sts	0x05B2, r24
		printf("%x\n", value);
    2012:	20 91 b2 05 	lds	r18, 0x05B2
    2016:	30 91 b3 05 	lds	r19, 0x05B3
    201a:	00 d0       	rcall	.+0      	; 0x201c <set_array_value+0x590>
    201c:	00 d0       	rcall	.+0      	; 0x201e <set_array_value+0x592>
    201e:	ed b7       	in	r30, 0x3d	; 61
    2020:	fe b7       	in	r31, 0x3e	; 62
    2022:	31 96       	adiw	r30, 0x01	; 1
    2024:	82 e2       	ldi	r24, 0x22	; 34
    2026:	95 e0       	ldi	r25, 0x05	; 5
    2028:	91 83       	std	Z+1, r25	; 0x01
    202a:	80 83       	st	Z, r24
    202c:	33 83       	std	Z+3, r19	; 0x03
    202e:	22 83       	std	Z+2, r18	; 0x02
    2030:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    2034:	0f 90       	pop	r0
    2036:	0f 90       	pop	r0
    2038:	0f 90       	pop	r0
    203a:	0f 90       	pop	r0
	}
	
	if((value4 <58) & (value4>47))
    203c:	80 91 ba 05 	lds	r24, 0x05BA
    2040:	90 91 bb 05 	lds	r25, 0x05BB
    2044:	1d 82       	std	Y+5, r1	; 0x05
    2046:	8a 33       	cpi	r24, 0x3A	; 58
    2048:	91 05       	cpc	r25, r1
    204a:	10 f4       	brcc	.+4      	; 0x2050 <set_array_value+0x5c4>
    204c:	81 e0       	ldi	r24, 0x01	; 1
    204e:	8d 83       	std	Y+5, r24	; 0x05
    2050:	80 91 ba 05 	lds	r24, 0x05BA
    2054:	90 91 bb 05 	lds	r25, 0x05BB
    2058:	1c 82       	std	Y+4, r1	; 0x04
    205a:	80 33       	cpi	r24, 0x30	; 48
    205c:	91 05       	cpc	r25, r1
    205e:	10 f0       	brcs	.+4      	; 0x2064 <set_array_value+0x5d8>
    2060:	91 e0       	ldi	r25, 0x01	; 1
    2062:	9c 83       	std	Y+4, r25	; 0x04
    2064:	8d 81       	ldd	r24, Y+5	; 0x05
    2066:	9c 81       	ldd	r25, Y+4	; 0x04
    2068:	89 23       	and	r24, r25
    206a:	88 23       	and	r24, r24
    206c:	31 f1       	breq	.+76     	; 0x20ba <set_array_value+0x62e>
	{
		value = ((value4 - 48) | value);
    206e:	80 91 ba 05 	lds	r24, 0x05BA
    2072:	90 91 bb 05 	lds	r25, 0x05BB
    2076:	9c 01       	movw	r18, r24
    2078:	20 53       	subi	r18, 0x30	; 48
    207a:	30 40       	sbci	r19, 0x00	; 0
    207c:	80 91 b2 05 	lds	r24, 0x05B2
    2080:	90 91 b3 05 	lds	r25, 0x05B3
    2084:	82 2b       	or	r24, r18
    2086:	93 2b       	or	r25, r19
    2088:	90 93 b3 05 	sts	0x05B3, r25
    208c:	80 93 b2 05 	sts	0x05B2, r24
		printf("%x\n", value);
    2090:	20 91 b2 05 	lds	r18, 0x05B2
    2094:	30 91 b3 05 	lds	r19, 0x05B3
    2098:	00 d0       	rcall	.+0      	; 0x209a <set_array_value+0x60e>
    209a:	00 d0       	rcall	.+0      	; 0x209c <set_array_value+0x610>
    209c:	ed b7       	in	r30, 0x3d	; 61
    209e:	fe b7       	in	r31, 0x3e	; 62
    20a0:	31 96       	adiw	r30, 0x01	; 1
    20a2:	82 e2       	ldi	r24, 0x22	; 34
    20a4:	95 e0       	ldi	r25, 0x05	; 5
    20a6:	91 83       	std	Z+1, r25	; 0x01
    20a8:	80 83       	st	Z, r24
    20aa:	33 83       	std	Z+3, r19	; 0x03
    20ac:	22 83       	std	Z+2, r18	; 0x02
    20ae:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    20b2:	0f 90       	pop	r0
    20b4:	0f 90       	pop	r0
    20b6:	0f 90       	pop	r0
    20b8:	0f 90       	pop	r0
	}
	
	if((value4 <103 )& (value4>96))
    20ba:	80 91 ba 05 	lds	r24, 0x05BA
    20be:	90 91 bb 05 	lds	r25, 0x05BB
    20c2:	1b 82       	std	Y+3, r1	; 0x03
    20c4:	87 36       	cpi	r24, 0x67	; 103
    20c6:	91 05       	cpc	r25, r1
    20c8:	10 f4       	brcc	.+4      	; 0x20ce <set_array_value+0x642>
    20ca:	81 e0       	ldi	r24, 0x01	; 1
    20cc:	8b 83       	std	Y+3, r24	; 0x03
    20ce:	80 91 ba 05 	lds	r24, 0x05BA
    20d2:	90 91 bb 05 	lds	r25, 0x05BB
    20d6:	1a 82       	std	Y+2, r1	; 0x02
    20d8:	81 36       	cpi	r24, 0x61	; 97
    20da:	91 05       	cpc	r25, r1
    20dc:	10 f0       	brcs	.+4      	; 0x20e2 <set_array_value+0x656>
    20de:	91 e0       	ldi	r25, 0x01	; 1
    20e0:	9a 83       	std	Y+2, r25	; 0x02
    20e2:	8b 81       	ldd	r24, Y+3	; 0x03
    20e4:	9a 81       	ldd	r25, Y+2	; 0x02
    20e6:	89 23       	and	r24, r25
    20e8:	88 23       	and	r24, r24
    20ea:	79 f1       	breq	.+94     	; 0x214a <set_array_value+0x6be>
	{
        value4 = chartohex(value4);
    20ec:	80 91 ba 05 	lds	r24, 0x05BA
    20f0:	90 91 bb 05 	lds	r25, 0x05BB
    20f4:	0e 94 65 12 	call	0x24ca	; 0x24ca <chartohex>
    20f8:	88 2f       	mov	r24, r24
    20fa:	90 e0       	ldi	r25, 0x00	; 0
    20fc:	90 93 bb 05 	sts	0x05BB, r25
    2100:	80 93 ba 05 	sts	0x05BA, r24
        value = ((value4) | value);
    2104:	20 91 ba 05 	lds	r18, 0x05BA
    2108:	30 91 bb 05 	lds	r19, 0x05BB
    210c:	80 91 b2 05 	lds	r24, 0x05B2
    2110:	90 91 b3 05 	lds	r25, 0x05B3
    2114:	82 2b       	or	r24, r18
    2116:	93 2b       	or	r25, r19
    2118:	90 93 b3 05 	sts	0x05B3, r25
    211c:	80 93 b2 05 	sts	0x05B2, r24
		printf("%x\n", value);
    2120:	20 91 b2 05 	lds	r18, 0x05B2
    2124:	30 91 b3 05 	lds	r19, 0x05B3
    2128:	00 d0       	rcall	.+0      	; 0x212a <set_array_value+0x69e>
    212a:	00 d0       	rcall	.+0      	; 0x212c <set_array_value+0x6a0>
    212c:	ed b7       	in	r30, 0x3d	; 61
    212e:	fe b7       	in	r31, 0x3e	; 62
    2130:	31 96       	adiw	r30, 0x01	; 1
    2132:	82 e2       	ldi	r24, 0x22	; 34
    2134:	95 e0       	ldi	r25, 0x05	; 5
    2136:	91 83       	std	Z+1, r25	; 0x01
    2138:	80 83       	st	Z, r24
    213a:	33 83       	std	Z+3, r19	; 0x03
    213c:	22 83       	std	Z+2, r18	; 0x02
    213e:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    2142:	0f 90       	pop	r0
    2144:	0f 90       	pop	r0
    2146:	0f 90       	pop	r0
    2148:	0f 90       	pop	r0
	}
    
    printf("Array value is: %x", value);
    214a:	20 91 b2 05 	lds	r18, 0x05B2
    214e:	30 91 b3 05 	lds	r19, 0x05B3
    2152:	00 d0       	rcall	.+0      	; 0x2154 <set_array_value+0x6c8>
    2154:	00 d0       	rcall	.+0      	; 0x2156 <set_array_value+0x6ca>
    2156:	ed b7       	in	r30, 0x3d	; 61
    2158:	fe b7       	in	r31, 0x3e	; 62
    215a:	31 96       	adiw	r30, 0x01	; 1
    215c:	86 e2       	ldi	r24, 0x26	; 38
    215e:	95 e0       	ldi	r25, 0x05	; 5
    2160:	91 83       	std	Z+1, r25	; 0x01
    2162:	80 83       	st	Z, r24
    2164:	33 83       	std	Z+3, r19	; 0x03
    2166:	22 83       	std	Z+2, r18	; 0x02
    2168:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    216c:	0f 90       	pop	r0
    216e:	0f 90       	pop	r0
    2170:	0f 90       	pop	r0
    2172:	0f 90       	pop	r0
    
    
    register_values[byte] = value;
    2174:	80 91 be 05 	lds	r24, 0x05BE
    2178:	88 2f       	mov	r24, r24
    217a:	90 e0       	ldi	r25, 0x00	; 0
    217c:	20 91 b2 05 	lds	r18, 0x05B2
    2180:	30 91 b3 05 	lds	r19, 0x05B3
    2184:	88 0f       	add	r24, r24
    2186:	99 1f       	adc	r25, r25
    2188:	fc 01       	movw	r30, r24
    218a:	e9 5e       	subi	r30, 0xE9	; 233
    218c:	fd 4f       	sbci	r31, 0xFD	; 253
    218e:	31 83       	std	Z+1, r19	; 0x01
    2190:	20 83       	st	Z, r18
	
}
    2192:	69 96       	adiw	r28, 0x19	; 25
    2194:	0f b6       	in	r0, 0x3f	; 63
    2196:	f8 94       	cli
    2198:	de bf       	out	0x3e, r29	; 62
    219a:	0f be       	out	0x3f, r0	; 63
    219c:	cd bf       	out	0x3d, r28	; 61
    219e:	cf 91       	pop	r28
    21a0:	df 91       	pop	r29
    21a2:	08 95       	ret

000021a4 <print_array>:
	



void print_array(void)
{
    21a4:	df 93       	push	r29
    21a6:	cf 93       	push	r28
    21a8:	00 d0       	rcall	.+0      	; 0x21aa <print_array+0x6>
    21aa:	cd b7       	in	r28, 0x3d	; 61
    21ac:	de b7       	in	r29, 0x3e	; 62
	//prints the values of the array that is used to control the radio
	printf("\n");
    21ae:	8a e0       	ldi	r24, 0x0A	; 10
    21b0:	90 e0       	ldi	r25, 0x00	; 0
    21b2:	0e 94 a4 12 	call	0x2548	; 0x2548 <putchar>
	for(int i=0; i<18; i++)
    21b6:	1a 82       	std	Y+2, r1	; 0x02
    21b8:	19 82       	std	Y+1, r1	; 0x01
    21ba:	32 c0       	rjmp	.+100    	; 0x2220 <print_array+0x7c>
	{
		printf("\nArray position %x", i);
    21bc:	00 d0       	rcall	.+0      	; 0x21be <print_array+0x1a>
    21be:	00 d0       	rcall	.+0      	; 0x21c0 <print_array+0x1c>
    21c0:	ed b7       	in	r30, 0x3d	; 61
    21c2:	fe b7       	in	r31, 0x3e	; 62
    21c4:	31 96       	adiw	r30, 0x01	; 1
    21c6:	89 e3       	ldi	r24, 0x39	; 57
    21c8:	95 e0       	ldi	r25, 0x05	; 5
    21ca:	91 83       	std	Z+1, r25	; 0x01
    21cc:	80 83       	st	Z, r24
    21ce:	89 81       	ldd	r24, Y+1	; 0x01
    21d0:	9a 81       	ldd	r25, Y+2	; 0x02
    21d2:	93 83       	std	Z+3, r25	; 0x03
    21d4:	82 83       	std	Z+2, r24	; 0x02
    21d6:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    21da:	0f 90       	pop	r0
    21dc:	0f 90       	pop	r0
    21de:	0f 90       	pop	r0
    21e0:	0f 90       	pop	r0
		printf("\tArray value: %x", register_values[i]);
    21e2:	89 81       	ldd	r24, Y+1	; 0x01
    21e4:	9a 81       	ldd	r25, Y+2	; 0x02
    21e6:	88 0f       	add	r24, r24
    21e8:	99 1f       	adc	r25, r25
    21ea:	fc 01       	movw	r30, r24
    21ec:	e9 5e       	subi	r30, 0xE9	; 233
    21ee:	fd 4f       	sbci	r31, 0xFD	; 253
    21f0:	20 81       	ld	r18, Z
    21f2:	31 81       	ldd	r19, Z+1	; 0x01
    21f4:	00 d0       	rcall	.+0      	; 0x21f6 <print_array+0x52>
    21f6:	00 d0       	rcall	.+0      	; 0x21f8 <print_array+0x54>
    21f8:	ed b7       	in	r30, 0x3d	; 61
    21fa:	fe b7       	in	r31, 0x3e	; 62
    21fc:	31 96       	adiw	r30, 0x01	; 1
    21fe:	8c e4       	ldi	r24, 0x4C	; 76
    2200:	95 e0       	ldi	r25, 0x05	; 5
    2202:	91 83       	std	Z+1, r25	; 0x01
    2204:	80 83       	st	Z, r24
    2206:	33 83       	std	Z+3, r19	; 0x03
    2208:	22 83       	std	Z+2, r18	; 0x02
    220a:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    220e:	0f 90       	pop	r0
    2210:	0f 90       	pop	r0
    2212:	0f 90       	pop	r0
    2214:	0f 90       	pop	r0

void print_array(void)
{
	//prints the values of the array that is used to control the radio
	printf("\n");
	for(int i=0; i<18; i++)
    2216:	89 81       	ldd	r24, Y+1	; 0x01
    2218:	9a 81       	ldd	r25, Y+2	; 0x02
    221a:	01 96       	adiw	r24, 0x01	; 1
    221c:	9a 83       	std	Y+2, r25	; 0x02
    221e:	89 83       	std	Y+1, r24	; 0x01
    2220:	89 81       	ldd	r24, Y+1	; 0x01
    2222:	9a 81       	ldd	r25, Y+2	; 0x02
    2224:	82 31       	cpi	r24, 0x12	; 18
    2226:	91 05       	cpc	r25, r1
    2228:	4c f2       	brlt	.-110    	; 0x21bc <print_array+0x18>
	{
		printf("\nArray position %x", i);
		printf("\tArray value: %x", register_values[i]);
	}
}
    222a:	0f 90       	pop	r0
    222c:	0f 90       	pop	r0
    222e:	cf 91       	pop	r28
    2230:	df 91       	pop	r29
    2232:	08 95       	ret

00002234 <ar1000readall>:


void ar1000readall(void)
{
    2234:	df 93       	push	r29
    2236:	cf 93       	push	r28
    2238:	00 d0       	rcall	.+0      	; 0x223a <ar1000readall+0x6>
    223a:	00 d0       	rcall	.+0      	; 0x223c <ar1000readall+0x8>
    223c:	cd b7       	in	r28, 0x3d	; 61
    223e:	de b7       	in	r29, 0x3e	; 62
	//reads all of the register values, and prints them
	WORD value;
	for(int x=0x0; x < 0x1d; x++)
    2240:	1a 82       	std	Y+2, r1	; 0x02
    2242:	19 82       	std	Y+1, r1	; 0x01
    2244:	30 c0       	rjmp	.+96     	; 0x22a6 <ar1000readall+0x72>
	{
		value = ar1000read(x);
    2246:	89 81       	ldd	r24, Y+1	; 0x01
    2248:	0e 94 63 11 	call	0x22c6	; 0x22c6 <ar1000read>
    224c:	9c 83       	std	Y+4, r25	; 0x04
    224e:	8b 83       	std	Y+3, r24	; 0x03
		//delay_us(10);
		printf("%x", x);
    2250:	00 d0       	rcall	.+0      	; 0x2252 <ar1000readall+0x1e>
    2252:	00 d0       	rcall	.+0      	; 0x2254 <ar1000readall+0x20>
    2254:	ed b7       	in	r30, 0x3d	; 61
    2256:	fe b7       	in	r31, 0x3e	; 62
    2258:	31 96       	adiw	r30, 0x01	; 1
    225a:	8d e5       	ldi	r24, 0x5D	; 93
    225c:	95 e0       	ldi	r25, 0x05	; 5
    225e:	91 83       	std	Z+1, r25	; 0x01
    2260:	80 83       	st	Z, r24
    2262:	89 81       	ldd	r24, Y+1	; 0x01
    2264:	9a 81       	ldd	r25, Y+2	; 0x02
    2266:	93 83       	std	Z+3, r25	; 0x03
    2268:	82 83       	std	Z+2, r24	; 0x02
    226a:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    226e:	0f 90       	pop	r0
    2270:	0f 90       	pop	r0
    2272:	0f 90       	pop	r0
    2274:	0f 90       	pop	r0
		printf("\tregvalue is: %x\n", value);
    2276:	00 d0       	rcall	.+0      	; 0x2278 <ar1000readall+0x44>
    2278:	00 d0       	rcall	.+0      	; 0x227a <ar1000readall+0x46>
    227a:	ed b7       	in	r30, 0x3d	; 61
    227c:	fe b7       	in	r31, 0x3e	; 62
    227e:	31 96       	adiw	r30, 0x01	; 1
    2280:	80 e6       	ldi	r24, 0x60	; 96
    2282:	95 e0       	ldi	r25, 0x05	; 5
    2284:	91 83       	std	Z+1, r25	; 0x01
    2286:	80 83       	st	Z, r24
    2288:	8b 81       	ldd	r24, Y+3	; 0x03
    228a:	9c 81       	ldd	r25, Y+4	; 0x04
    228c:	93 83       	std	Z+3, r25	; 0x03
    228e:	82 83       	std	Z+2, r24	; 0x02
    2290:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    2294:	0f 90       	pop	r0
    2296:	0f 90       	pop	r0
    2298:	0f 90       	pop	r0
    229a:	0f 90       	pop	r0

void ar1000readall(void)
{
	//reads all of the register values, and prints them
	WORD value;
	for(int x=0x0; x < 0x1d; x++)
    229c:	89 81       	ldd	r24, Y+1	; 0x01
    229e:	9a 81       	ldd	r25, Y+2	; 0x02
    22a0:	01 96       	adiw	r24, 0x01	; 1
    22a2:	9a 83       	std	Y+2, r25	; 0x02
    22a4:	89 83       	std	Y+1, r24	; 0x01
    22a6:	89 81       	ldd	r24, Y+1	; 0x01
    22a8:	9a 81       	ldd	r25, Y+2	; 0x02
    22aa:	8d 31       	cpi	r24, 0x1D	; 29
    22ac:	91 05       	cpc	r25, r1
    22ae:	5c f2       	brlt	.-106    	; 0x2246 <ar1000readall+0x12>
		//delay_us(10);
		printf("%x", x);
		printf("\tregvalue is: %x\n", value);
	}
	
	delay_us(10);
    22b0:	8a e0       	ldi	r24, 0x0A	; 10
    22b2:	90 e0       	ldi	r25, 0x00	; 0
    22b4:	0e 94 2a 12 	call	0x2454	; 0x2454 <delay_us>
}
    22b8:	0f 90       	pop	r0
    22ba:	0f 90       	pop	r0
    22bc:	0f 90       	pop	r0
    22be:	0f 90       	pop	r0
    22c0:	cf 91       	pop	r28
    22c2:	df 91       	pop	r29
    22c4:	08 95       	ret

000022c6 <ar1000read>:

uint16_t ar1000read(uint8_t address)
{
    22c6:	df 93       	push	r29
    22c8:	cf 93       	push	r28
    22ca:	0f 92       	push	r0
    22cc:	cd b7       	in	r28, 0x3d	; 61
    22ce:	de b7       	in	r29, 0x3e	; 62
    22d0:	89 83       	std	Y+1, r24	; 0x01
	return (read_i2c_word(TUNER, address));
    22d2:	80 e2       	ldi	r24, 0x20	; 32
    22d4:	69 81       	ldd	r22, Y+1	; 0x01
    22d6:	0e 94 6d 05 	call	0xada	; 0xada <read_i2c_word>
}
    22da:	0f 90       	pop	r0
    22dc:	cf 91       	pop	r28
    22de:	df 91       	pop	r29
    22e0:	08 95       	ret

000022e2 <send_all_regs>:
	


void send_all_regs(uint16_t values[])
{
    22e2:	df 93       	push	r29
    22e4:	cf 93       	push	r28
    22e6:	00 d0       	rcall	.+0      	; 0x22e8 <send_all_regs+0x6>
    22e8:	00 d0       	rcall	.+0      	; 0x22ea <send_all_regs+0x8>
    22ea:	cd b7       	in	r28, 0x3d	; 61
    22ec:	de b7       	in	r29, 0x3e	; 62
    22ee:	9c 83       	std	Y+4, r25	; 0x04
    22f0:	8b 83       	std	Y+3, r24	; 0x03
	// This code writes the array values to the ar1000, it is used to calibrate the ar1000
	// on power up and it can send the modified array values needed for the seeking tuning etc
	
	printf("\nSending regs 1 to 17..."); 
    22f2:	00 d0       	rcall	.+0      	; 0x22f4 <send_all_regs+0x12>
    22f4:	ed b7       	in	r30, 0x3d	; 61
    22f6:	fe b7       	in	r31, 0x3e	; 62
    22f8:	31 96       	adiw	r30, 0x01	; 1
    22fa:	82 e7       	ldi	r24, 0x72	; 114
    22fc:	95 e0       	ldi	r25, 0x05	; 5
    22fe:	91 83       	std	Z+1, r25	; 0x01
    2300:	80 83       	st	Z, r24
    2302:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    2306:	0f 90       	pop	r0
    2308:	0f 90       	pop	r0
	for(int i=1; i<18; i++)
    230a:	81 e0       	ldi	r24, 0x01	; 1
    230c:	90 e0       	ldi	r25, 0x00	; 0
    230e:	9a 83       	std	Y+2, r25	; 0x02
    2310:	89 83       	std	Y+1, r24	; 0x01
    2312:	13 c0       	rjmp	.+38     	; 0x233a <send_all_regs+0x58>
	{
		write_i2c_data(TUNER, (BYTE) i, 2, (BYTE *) (values+i));
    2314:	49 81       	ldd	r20, Y+1	; 0x01
    2316:	2b 81       	ldd	r18, Y+3	; 0x03
    2318:	3c 81       	ldd	r19, Y+4	; 0x04
    231a:	89 81       	ldd	r24, Y+1	; 0x01
    231c:	9a 81       	ldd	r25, Y+2	; 0x02
    231e:	88 0f       	add	r24, r24
    2320:	99 1f       	adc	r25, r25
    2322:	28 0f       	add	r18, r24
    2324:	39 1f       	adc	r19, r25
    2326:	80 e2       	ldi	r24, 0x20	; 32
    2328:	64 2f       	mov	r22, r20
    232a:	42 e0       	ldi	r20, 0x02	; 2
    232c:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <write_i2c_data>
{
	// This code writes the array values to the ar1000, it is used to calibrate the ar1000
	// on power up and it can send the modified array values needed for the seeking tuning etc
	
	printf("\nSending regs 1 to 17..."); 
	for(int i=1; i<18; i++)
    2330:	89 81       	ldd	r24, Y+1	; 0x01
    2332:	9a 81       	ldd	r25, Y+2	; 0x02
    2334:	01 96       	adiw	r24, 0x01	; 1
    2336:	9a 83       	std	Y+2, r25	; 0x02
    2338:	89 83       	std	Y+1, r24	; 0x01
    233a:	89 81       	ldd	r24, Y+1	; 0x01
    233c:	9a 81       	ldd	r25, Y+2	; 0x02
    233e:	82 31       	cpi	r24, 0x12	; 18
    2340:	91 05       	cpc	r25, r1
    2342:	44 f3       	brlt	.-48     	; 0x2314 <send_all_regs+0x32>
	{
		write_i2c_data(TUNER, (BYTE) i, 2, (BYTE *) (values+i));
	}
	printf(" Done!"); 	
    2344:	00 d0       	rcall	.+0      	; 0x2346 <send_all_regs+0x64>
    2346:	ed b7       	in	r30, 0x3d	; 61
    2348:	fe b7       	in	r31, 0x3e	; 62
    234a:	31 96       	adiw	r30, 0x01	; 1
    234c:	8b e8       	ldi	r24, 0x8B	; 139
    234e:	95 e0       	ldi	r25, 0x05	; 5
    2350:	91 83       	std	Z+1, r25	; 0x01
    2352:	80 83       	st	Z, r24
    2354:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    2358:	0f 90       	pop	r0
    235a:	0f 90       	pop	r0
}	
    235c:	0f 90       	pop	r0
    235e:	0f 90       	pop	r0
    2360:	0f 90       	pop	r0
    2362:	0f 90       	pop	r0
    2364:	cf 91       	pop	r28
    2366:	df 91       	pop	r29
    2368:	08 95       	ret

0000236a <ar1000calibration>:
	

void ar1000calibration(uint16_t values[])
{
    236a:	df 93       	push	r29
    236c:	cf 93       	push	r28
    236e:	00 d0       	rcall	.+0      	; 0x2370 <ar1000calibration+0x6>
    2370:	00 d0       	rcall	.+0      	; 0x2372 <ar1000calibration+0x8>
    2372:	cd b7       	in	r28, 0x3d	; 61
    2374:	de b7       	in	r29, 0x3e	; 62
    2376:	9c 83       	std	Y+4, r25	; 0x04
    2378:	8b 83       	std	Y+3, r24	; 0x03
	// This code writes the array values to the ar1000, it is used to calibrate the ar1000
	// on power up and it can send the modified array values needed for the seeking tuning etc
	
	printf("\nSending calibration data."); 
    237a:	00 d0       	rcall	.+0      	; 0x237c <ar1000calibration+0x12>
    237c:	ed b7       	in	r30, 0x3d	; 61
    237e:	fe b7       	in	r31, 0x3e	; 62
    2380:	31 96       	adiw	r30, 0x01	; 1
    2382:	82 e9       	ldi	r24, 0x92	; 146
    2384:	95 e0       	ldi	r25, 0x05	; 5
    2386:	91 83       	std	Z+1, r25	; 0x01
    2388:	80 83       	st	Z, r24
    238a:	0e 94 8f 12 	call	0x251e	; 0x251e <printf>
    238e:	0f 90       	pop	r0
    2390:	0f 90       	pop	r0
	for(int i=1; i<18; i++)
    2392:	81 e0       	ldi	r24, 0x01	; 1
    2394:	90 e0       	ldi	r25, 0x00	; 0
    2396:	9a 83       	std	Y+2, r25	; 0x02
    2398:	89 83       	std	Y+1, r24	; 0x01
    239a:	13 c0       	rjmp	.+38     	; 0x23c2 <ar1000calibration+0x58>
	{
		write_i2c_data(TUNER, (BYTE) i, 2, (BYTE *) (values+i));
    239c:	49 81       	ldd	r20, Y+1	; 0x01
    239e:	2b 81       	ldd	r18, Y+3	; 0x03
    23a0:	3c 81       	ldd	r19, Y+4	; 0x04
    23a2:	89 81       	ldd	r24, Y+1	; 0x01
    23a4:	9a 81       	ldd	r25, Y+2	; 0x02
    23a6:	88 0f       	add	r24, r24
    23a8:	99 1f       	adc	r25, r25
    23aa:	28 0f       	add	r18, r24
    23ac:	39 1f       	adc	r19, r25
    23ae:	80 e2       	ldi	r24, 0x20	; 32
    23b0:	64 2f       	mov	r22, r20
    23b2:	42 e0       	ldi	r20, 0x02	; 2
    23b4:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <write_i2c_data>
{
	// This code writes the array values to the ar1000, it is used to calibrate the ar1000
	// on power up and it can send the modified array values needed for the seeking tuning etc
	
	printf("\nSending calibration data."); 
	for(int i=1; i<18; i++)
    23b8:	89 81       	ldd	r24, Y+1	; 0x01
    23ba:	9a 81       	ldd	r25, Y+2	; 0x02
    23bc:	01 96       	adiw	r24, 0x01	; 1
    23be:	9a 83       	std	Y+2, r25	; 0x02
    23c0:	89 83       	std	Y+1, r24	; 0x01
    23c2:	89 81       	ldd	r24, Y+1	; 0x01
    23c4:	9a 81       	ldd	r25, Y+2	; 0x02
    23c6:	82 31       	cpi	r24, 0x12	; 18
    23c8:	91 05       	cpc	r25, r1
    23ca:	44 f3       	brlt	.-48     	; 0x239c <ar1000calibration+0x32>
	{
		write_i2c_data(TUNER, (BYTE) i, 2, (BYTE *) (values+i));
	}
	
	//printf("\nAll calibration values written except R0...");
	write_i2c_data(TUNER, 0, 2, (BYTE *) (values)); // write Reg 0 last
    23cc:	2b 81       	ldd	r18, Y+3	; 0x03
    23ce:	3c 81       	ldd	r19, Y+4	; 0x04
    23d0:	80 e2       	ldi	r24, 0x20	; 32
    23d2:	60 e0       	ldi	r22, 0x00	; 0
    23d4:	42 e0       	ldi	r20, 0x02	; 2
    23d6:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <write_i2c_data>
	//printf("\nR0 written.");
	}
    23da:	0f 90       	pop	r0
    23dc:	0f 90       	pop	r0
    23de:	0f 90       	pop	r0
    23e0:	0f 90       	pop	r0
    23e2:	cf 91       	pop	r28
    23e4:	df 91       	pop	r29
    23e6:	08 95       	ret

000023e8 <uart_putchar>:


int uart_putchar(char c, FILE *stream)
{
    23e8:	df 93       	push	r29
    23ea:	cf 93       	push	r28
    23ec:	00 d0       	rcall	.+0      	; 0x23ee <uart_putchar+0x6>
    23ee:	0f 92       	push	r0
    23f0:	cd b7       	in	r28, 0x3d	; 61
    23f2:	de b7       	in	r29, 0x3e	; 62
    23f4:	89 83       	std	Y+1, r24	; 0x01
    23f6:	7b 83       	std	Y+3, r23	; 0x03
    23f8:	6a 83       	std	Y+2, r22	; 0x02
    if (c == '\n') uart_putchar('\r', stream);
    23fa:	89 81       	ldd	r24, Y+1	; 0x01
    23fc:	8a 30       	cpi	r24, 0x0A	; 10
    23fe:	31 f4       	brne	.+12     	; 0x240c <uart_putchar+0x24>
    2400:	2a 81       	ldd	r18, Y+2	; 0x02
    2402:	3b 81       	ldd	r19, Y+3	; 0x03
    2404:	8d e0       	ldi	r24, 0x0D	; 13
    2406:	b9 01       	movw	r22, r18
    2408:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <uart_putchar>
  
    loop_until_bit_is_set(UCSR0A, UDRE0);
    240c:	e0 ec       	ldi	r30, 0xC0	; 192
    240e:	f0 e0       	ldi	r31, 0x00	; 0
    2410:	80 81       	ld	r24, Z
    2412:	88 2f       	mov	r24, r24
    2414:	90 e0       	ldi	r25, 0x00	; 0
    2416:	80 72       	andi	r24, 0x20	; 32
    2418:	90 70       	andi	r25, 0x00	; 0
    241a:	00 97       	sbiw	r24, 0x00	; 0
    241c:	b9 f3       	breq	.-18     	; 0x240c <uart_putchar+0x24>
    UDR0 = c;
    241e:	e6 ec       	ldi	r30, 0xC6	; 198
    2420:	f0 e0       	ldi	r31, 0x00	; 0
    2422:	89 81       	ldd	r24, Y+1	; 0x01
    2424:	80 83       	st	Z, r24
    
    return 0;
    2426:	80 e0       	ldi	r24, 0x00	; 0
    2428:	90 e0       	ldi	r25, 0x00	; 0
}
    242a:	0f 90       	pop	r0
    242c:	0f 90       	pop	r0
    242e:	0f 90       	pop	r0
    2430:	cf 91       	pop	r28
    2432:	df 91       	pop	r29
    2434:	08 95       	ret

00002436 <uart_getchar>:

uint8_t uart_getchar(void)
{
    2436:	df 93       	push	r29
    2438:	cf 93       	push	r28
    243a:	cd b7       	in	r28, 0x3d	; 61
    243c:	de b7       	in	r29, 0x3e	; 62
    while( !(UCSR0A & (1<<RXC0)) );
    243e:	e0 ec       	ldi	r30, 0xC0	; 192
    2440:	f0 e0       	ldi	r31, 0x00	; 0
    2442:	80 81       	ld	r24, Z
    2444:	88 23       	and	r24, r24
    2446:	dc f7       	brge	.-10     	; 0x243e <uart_getchar+0x8>
    return(UDR0);
    2448:	e6 ec       	ldi	r30, 0xC6	; 198
    244a:	f0 e0       	ldi	r31, 0x00	; 0
    244c:	80 81       	ld	r24, Z
}
    244e:	cf 91       	pop	r28
    2450:	df 91       	pop	r29
    2452:	08 95       	ret

00002454 <delay_us>:
//General short delays
//general short delays
//Uses internal timer do a fairly accurate 1us
//Because we are using 16MHz and a prescalar of 8 on Timer0, we have to double x
void delay_us(uint16_t x)
{
    2454:	df 93       	push	r29
    2456:	cf 93       	push	r28
    2458:	00 d0       	rcall	.+0      	; 0x245a <delay_us+0x6>
    245a:	cd b7       	in	r28, 0x3d	; 61
    245c:	de b7       	in	r29, 0x3e	; 62
    245e:	9a 83       	std	Y+2, r25	; 0x02
    2460:	89 83       	std	Y+1, r24	; 0x01
    2462:	16 c0       	rjmp	.+44     	; 0x2490 <delay_us+0x3c>
	while(x > 256)
	{
		TIFR0 = (1<<TOV0); //Clear any interrupt flags on Timer0
    2464:	e5 e3       	ldi	r30, 0x35	; 53
    2466:	f0 e0       	ldi	r31, 0x00	; 0
    2468:	81 e0       	ldi	r24, 0x01	; 1
    246a:	80 83       	st	Z, r24
		TCNT0 = 0; //Preload Timer0 for 256 clicks. Should be 1us per click
    246c:	e6 e4       	ldi	r30, 0x46	; 70
    246e:	f0 e0       	ldi	r31, 0x00	; 0
    2470:	10 82       	st	Z, r1
		while( (TIFR0 & (1<<TOV0)) == 0);
    2472:	e5 e3       	ldi	r30, 0x35	; 53
    2474:	f0 e0       	ldi	r31, 0x00	; 0
    2476:	80 81       	ld	r24, Z
    2478:	88 2f       	mov	r24, r24
    247a:	90 e0       	ldi	r25, 0x00	; 0
    247c:	81 70       	andi	r24, 0x01	; 1
    247e:	90 70       	andi	r25, 0x00	; 0
    2480:	00 97       	sbiw	r24, 0x00	; 0
    2482:	b9 f3       	breq	.-18     	; 0x2472 <delay_us+0x1e>
		
		x -= 256;
    2484:	89 81       	ldd	r24, Y+1	; 0x01
    2486:	9a 81       	ldd	r25, Y+2	; 0x02
    2488:	80 50       	subi	r24, 0x00	; 0
    248a:	91 40       	sbci	r25, 0x01	; 1
    248c:	9a 83       	std	Y+2, r25	; 0x02
    248e:	89 83       	std	Y+1, r24	; 0x01
//general short delays
//Uses internal timer do a fairly accurate 1us
//Because we are using 16MHz and a prescalar of 8 on Timer0, we have to double x
void delay_us(uint16_t x)
{
	while(x > 256)
    2490:	89 81       	ldd	r24, Y+1	; 0x01
    2492:	9a 81       	ldd	r25, Y+2	; 0x02
    2494:	21 e0       	ldi	r18, 0x01	; 1
    2496:	81 30       	cpi	r24, 0x01	; 1
    2498:	92 07       	cpc	r25, r18
    249a:	20 f7       	brcc	.-56     	; 0x2464 <delay_us+0x10>
		while( (TIFR0 & (1<<TOV0)) == 0);
		
		x -= 256;
	}

	TIFR0 = (1<<TOV0); //Clear any interrupt flags on Timer0
    249c:	e5 e3       	ldi	r30, 0x35	; 53
    249e:	f0 e0       	ldi	r31, 0x00	; 0
    24a0:	81 e0       	ldi	r24, 0x01	; 1
    24a2:	80 83       	st	Z, r24
	TCNT0 = 256 - x; //256 - 125 = 131 : Preload Timer0 for x clicks. Should be 1us per click
    24a4:	e6 e4       	ldi	r30, 0x46	; 70
    24a6:	f0 e0       	ldi	r31, 0x00	; 0
    24a8:	89 81       	ldd	r24, Y+1	; 0x01
    24aa:	81 95       	neg	r24
    24ac:	80 83       	st	Z, r24
	while( (TIFR0 & (1<<TOV0)) == 0);
    24ae:	e5 e3       	ldi	r30, 0x35	; 53
    24b0:	f0 e0       	ldi	r31, 0x00	; 0
    24b2:	80 81       	ld	r24, Z
    24b4:	88 2f       	mov	r24, r24
    24b6:	90 e0       	ldi	r25, 0x00	; 0
    24b8:	81 70       	andi	r24, 0x01	; 1
    24ba:	90 70       	andi	r25, 0x00	; 0
    24bc:	00 97       	sbiw	r24, 0x00	; 0
    24be:	b9 f3       	breq	.-18     	; 0x24ae <delay_us+0x5a>
}
    24c0:	0f 90       	pop	r0
    24c2:	0f 90       	pop	r0
    24c4:	cf 91       	pop	r28
    24c6:	df 91       	pop	r29
    24c8:	08 95       	ret

000024ca <chartohex>:



uint8_t chartohex(uint8_t hexvalue)
{
    24ca:	df 93       	push	r29
    24cc:	cf 93       	push	r28
    24ce:	00 d0       	rcall	.+0      	; 0x24d0 <chartohex+0x6>
    24d0:	cd b7       	in	r28, 0x3d	; 61
    24d2:	de b7       	in	r29, 0x3e	; 62
    24d4:	8a 83       	std	Y+2, r24	; 0x02
	//Uses the ASCII table to change chars to hex values
	
	uint8_t truevalue;
	
	if(hexvalue == 97)
    24d6:	8a 81       	ldd	r24, Y+2	; 0x02
    24d8:	81 36       	cpi	r24, 0x61	; 97
    24da:	11 f4       	brne	.+4      	; 0x24e0 <chartohex+0x16>
	{
		truevalue = 0x0a;
    24dc:	8a e0       	ldi	r24, 0x0A	; 10
    24de:	89 83       	std	Y+1, r24	; 0x01
	};
		
	if(hexvalue == 98)
    24e0:	8a 81       	ldd	r24, Y+2	; 0x02
    24e2:	82 36       	cpi	r24, 0x62	; 98
    24e4:	11 f4       	brne	.+4      	; 0x24ea <chartohex+0x20>
	{
		truevalue = 0x0b;
    24e6:	8b e0       	ldi	r24, 0x0B	; 11
    24e8:	89 83       	std	Y+1, r24	; 0x01
	};
			
	if(hexvalue == 99)
    24ea:	8a 81       	ldd	r24, Y+2	; 0x02
    24ec:	83 36       	cpi	r24, 0x63	; 99
    24ee:	11 f4       	brne	.+4      	; 0x24f4 <chartohex+0x2a>
	{
		truevalue = 0x0c;
    24f0:	8c e0       	ldi	r24, 0x0C	; 12
    24f2:	89 83       	std	Y+1, r24	; 0x01
	};
		
	if(hexvalue == 100)
    24f4:	8a 81       	ldd	r24, Y+2	; 0x02
    24f6:	84 36       	cpi	r24, 0x64	; 100
    24f8:	11 f4       	brne	.+4      	; 0x24fe <chartohex+0x34>
	{
		truevalue = 0x0d;
    24fa:	8d e0       	ldi	r24, 0x0D	; 13
    24fc:	89 83       	std	Y+1, r24	; 0x01
	};
			
	if(hexvalue == 101)
    24fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2500:	85 36       	cpi	r24, 0x65	; 101
    2502:	11 f4       	brne	.+4      	; 0x2508 <chartohex+0x3e>
	{
		truevalue = 0x0e;
    2504:	8e e0       	ldi	r24, 0x0E	; 14
    2506:	89 83       	std	Y+1, r24	; 0x01
	};
			
	if(hexvalue == 102)
    2508:	8a 81       	ldd	r24, Y+2	; 0x02
    250a:	86 36       	cpi	r24, 0x66	; 102
    250c:	11 f4       	brne	.+4      	; 0x2512 <chartohex+0x48>
	{
		truevalue = 0x0f;
    250e:	8f e0       	ldi	r24, 0x0F	; 15
    2510:	89 83       	std	Y+1, r24	; 0x01
	};
	
	//printf("True value is %x\n", truevalue);
	return(truevalue);
    2512:	89 81       	ldd	r24, Y+1	; 0x01
}	
    2514:	0f 90       	pop	r0
    2516:	0f 90       	pop	r0
    2518:	cf 91       	pop	r28
    251a:	df 91       	pop	r29
    251c:	08 95       	ret

0000251e <printf>:
    251e:	a0 e0       	ldi	r26, 0x00	; 0
    2520:	b0 e0       	ldi	r27, 0x00	; 0
    2522:	e5 e9       	ldi	r30, 0x95	; 149
    2524:	f2 e1       	ldi	r31, 0x12	; 18
    2526:	0c 94 a5 15 	jmp	0x2b4a	; 0x2b4a <__prologue_saves__+0x20>
    252a:	fe 01       	movw	r30, r28
    252c:	35 96       	adiw	r30, 0x05	; 5
    252e:	61 91       	ld	r22, Z+
    2530:	71 91       	ld	r23, Z+
    2532:	80 91 c1 05 	lds	r24, 0x05C1
    2536:	90 91 c2 05 	lds	r25, 0x05C2
    253a:	af 01       	movw	r20, r30
    253c:	0e 94 04 13 	call	0x2608	; 0x2608 <vfprintf>
    2540:	20 96       	adiw	r28, 0x00	; 0
    2542:	e2 e0       	ldi	r30, 0x02	; 2
    2544:	0c 94 c1 15 	jmp	0x2b82	; 0x2b82 <__epilogue_restores__+0x20>

00002548 <putchar>:
    2548:	60 91 c1 05 	lds	r22, 0x05C1
    254c:	70 91 c2 05 	lds	r23, 0x05C2
    2550:	0e 94 f7 14 	call	0x29ee	; 0x29ee <fputc>
    2554:	08 95       	ret

00002556 <puts>:
    2556:	0f 93       	push	r16
    2558:	1f 93       	push	r17
    255a:	cf 93       	push	r28
    255c:	df 93       	push	r29
    255e:	8c 01       	movw	r16, r24
    2560:	e0 91 c1 05 	lds	r30, 0x05C1
    2564:	f0 91 c2 05 	lds	r31, 0x05C2
    2568:	83 81       	ldd	r24, Z+3	; 0x03
    256a:	81 ff       	sbrs	r24, 1
    256c:	21 c0       	rjmp	.+66     	; 0x25b0 <puts+0x5a>
    256e:	c0 e0       	ldi	r28, 0x00	; 0
    2570:	d0 e0       	ldi	r29, 0x00	; 0
    2572:	0d c0       	rjmp	.+26     	; 0x258e <puts+0x38>
    2574:	e0 91 c1 05 	lds	r30, 0x05C1
    2578:	f0 91 c2 05 	lds	r31, 0x05C2
    257c:	20 85       	ldd	r18, Z+8	; 0x08
    257e:	31 85       	ldd	r19, Z+9	; 0x09
    2580:	bf 01       	movw	r22, r30
    2582:	f9 01       	movw	r30, r18
    2584:	09 95       	icall
    2586:	89 2b       	or	r24, r25
    2588:	11 f0       	breq	.+4      	; 0x258e <puts+0x38>
    258a:	cf ef       	ldi	r28, 0xFF	; 255
    258c:	df ef       	ldi	r29, 0xFF	; 255
    258e:	f8 01       	movw	r30, r16
    2590:	81 91       	ld	r24, Z+
    2592:	8f 01       	movw	r16, r30
    2594:	88 23       	and	r24, r24
    2596:	71 f7       	brne	.-36     	; 0x2574 <puts+0x1e>
    2598:	e0 91 c1 05 	lds	r30, 0x05C1
    259c:	f0 91 c2 05 	lds	r31, 0x05C2
    25a0:	20 85       	ldd	r18, Z+8	; 0x08
    25a2:	31 85       	ldd	r19, Z+9	; 0x09
    25a4:	8a e0       	ldi	r24, 0x0A	; 10
    25a6:	bf 01       	movw	r22, r30
    25a8:	f9 01       	movw	r30, r18
    25aa:	09 95       	icall
    25ac:	89 2b       	or	r24, r25
    25ae:	11 f0       	breq	.+4      	; 0x25b4 <puts+0x5e>
    25b0:	cf ef       	ldi	r28, 0xFF	; 255
    25b2:	df ef       	ldi	r29, 0xFF	; 255
    25b4:	ce 01       	movw	r24, r28
    25b6:	df 91       	pop	r29
    25b8:	cf 91       	pop	r28
    25ba:	1f 91       	pop	r17
    25bc:	0f 91       	pop	r16
    25be:	08 95       	ret

000025c0 <sprintf>:
    25c0:	ae e0       	ldi	r26, 0x0E	; 14
    25c2:	b0 e0       	ldi	r27, 0x00	; 0
    25c4:	e6 ee       	ldi	r30, 0xE6	; 230
    25c6:	f2 e1       	ldi	r31, 0x12	; 18
    25c8:	0c 94 a3 15 	jmp	0x2b46	; 0x2b46 <__prologue_saves__+0x1c>
    25cc:	0d 89       	ldd	r16, Y+21	; 0x15
    25ce:	1e 89       	ldd	r17, Y+22	; 0x16
    25d0:	86 e0       	ldi	r24, 0x06	; 6
    25d2:	8c 83       	std	Y+4, r24	; 0x04
    25d4:	1a 83       	std	Y+2, r17	; 0x02
    25d6:	09 83       	std	Y+1, r16	; 0x01
    25d8:	8f ef       	ldi	r24, 0xFF	; 255
    25da:	9f e7       	ldi	r25, 0x7F	; 127
    25dc:	9e 83       	std	Y+6, r25	; 0x06
    25de:	8d 83       	std	Y+5, r24	; 0x05
    25e0:	9e 01       	movw	r18, r28
    25e2:	27 5e       	subi	r18, 0xE7	; 231
    25e4:	3f 4f       	sbci	r19, 0xFF	; 255
    25e6:	ce 01       	movw	r24, r28
    25e8:	01 96       	adiw	r24, 0x01	; 1
    25ea:	6f 89       	ldd	r22, Y+23	; 0x17
    25ec:	78 8d       	ldd	r23, Y+24	; 0x18
    25ee:	a9 01       	movw	r20, r18
    25f0:	0e 94 04 13 	call	0x2608	; 0x2608 <vfprintf>
    25f4:	2f 81       	ldd	r18, Y+7	; 0x07
    25f6:	38 85       	ldd	r19, Y+8	; 0x08
    25f8:	02 0f       	add	r16, r18
    25fa:	13 1f       	adc	r17, r19
    25fc:	f8 01       	movw	r30, r16
    25fe:	10 82       	st	Z, r1
    2600:	2e 96       	adiw	r28, 0x0e	; 14
    2602:	e4 e0       	ldi	r30, 0x04	; 4
    2604:	0c 94 bf 15 	jmp	0x2b7e	; 0x2b7e <__epilogue_restores__+0x1c>

00002608 <vfprintf>:
    2608:	ab e0       	ldi	r26, 0x0B	; 11
    260a:	b0 e0       	ldi	r27, 0x00	; 0
    260c:	ea e0       	ldi	r30, 0x0A	; 10
    260e:	f3 e1       	ldi	r31, 0x13	; 19
    2610:	0c 94 95 15 	jmp	0x2b2a	; 0x2b2a <__prologue_saves__>
    2614:	3c 01       	movw	r6, r24
    2616:	2b 01       	movw	r4, r22
    2618:	5a 01       	movw	r10, r20
    261a:	fc 01       	movw	r30, r24
    261c:	17 82       	std	Z+7, r1	; 0x07
    261e:	16 82       	std	Z+6, r1	; 0x06
    2620:	83 81       	ldd	r24, Z+3	; 0x03
    2622:	81 fd       	sbrc	r24, 1
    2624:	03 c0       	rjmp	.+6      	; 0x262c <vfprintf+0x24>
    2626:	6f ef       	ldi	r22, 0xFF	; 255
    2628:	7f ef       	ldi	r23, 0xFF	; 255
    262a:	c6 c1       	rjmp	.+908    	; 0x29b8 <vfprintf+0x3b0>
    262c:	9a e0       	ldi	r25, 0x0A	; 10
    262e:	89 2e       	mov	r8, r25
    2630:	1e 01       	movw	r2, r28
    2632:	08 94       	sec
    2634:	21 1c       	adc	r2, r1
    2636:	31 1c       	adc	r3, r1
    2638:	f3 01       	movw	r30, r6
    263a:	23 81       	ldd	r18, Z+3	; 0x03
    263c:	f2 01       	movw	r30, r4
    263e:	23 fd       	sbrc	r18, 3
    2640:	85 91       	lpm	r24, Z+
    2642:	23 ff       	sbrs	r18, 3
    2644:	81 91       	ld	r24, Z+
    2646:	2f 01       	movw	r4, r30
    2648:	88 23       	and	r24, r24
    264a:	09 f4       	brne	.+2      	; 0x264e <vfprintf+0x46>
    264c:	b2 c1       	rjmp	.+868    	; 0x29b2 <vfprintf+0x3aa>
    264e:	85 32       	cpi	r24, 0x25	; 37
    2650:	39 f4       	brne	.+14     	; 0x2660 <vfprintf+0x58>
    2652:	23 fd       	sbrc	r18, 3
    2654:	85 91       	lpm	r24, Z+
    2656:	23 ff       	sbrs	r18, 3
    2658:	81 91       	ld	r24, Z+
    265a:	2f 01       	movw	r4, r30
    265c:	85 32       	cpi	r24, 0x25	; 37
    265e:	29 f4       	brne	.+10     	; 0x266a <vfprintf+0x62>
    2660:	90 e0       	ldi	r25, 0x00	; 0
    2662:	b3 01       	movw	r22, r6
    2664:	0e 94 f7 14 	call	0x29ee	; 0x29ee <fputc>
    2668:	e7 cf       	rjmp	.-50     	; 0x2638 <vfprintf+0x30>
    266a:	98 2f       	mov	r25, r24
    266c:	ff 24       	eor	r15, r15
    266e:	ee 24       	eor	r14, r14
    2670:	99 24       	eor	r9, r9
    2672:	ff e1       	ldi	r31, 0x1F	; 31
    2674:	ff 15       	cp	r31, r15
    2676:	d0 f0       	brcs	.+52     	; 0x26ac <vfprintf+0xa4>
    2678:	9b 32       	cpi	r25, 0x2B	; 43
    267a:	69 f0       	breq	.+26     	; 0x2696 <vfprintf+0x8e>
    267c:	9c 32       	cpi	r25, 0x2C	; 44
    267e:	28 f4       	brcc	.+10     	; 0x268a <vfprintf+0x82>
    2680:	90 32       	cpi	r25, 0x20	; 32
    2682:	59 f0       	breq	.+22     	; 0x269a <vfprintf+0x92>
    2684:	93 32       	cpi	r25, 0x23	; 35
    2686:	91 f4       	brne	.+36     	; 0x26ac <vfprintf+0xa4>
    2688:	0e c0       	rjmp	.+28     	; 0x26a6 <vfprintf+0x9e>
    268a:	9d 32       	cpi	r25, 0x2D	; 45
    268c:	49 f0       	breq	.+18     	; 0x26a0 <vfprintf+0x98>
    268e:	90 33       	cpi	r25, 0x30	; 48
    2690:	69 f4       	brne	.+26     	; 0x26ac <vfprintf+0xa4>
    2692:	41 e0       	ldi	r20, 0x01	; 1
    2694:	24 c0       	rjmp	.+72     	; 0x26de <vfprintf+0xd6>
    2696:	52 e0       	ldi	r21, 0x02	; 2
    2698:	f5 2a       	or	r15, r21
    269a:	84 e0       	ldi	r24, 0x04	; 4
    269c:	f8 2a       	or	r15, r24
    269e:	28 c0       	rjmp	.+80     	; 0x26f0 <vfprintf+0xe8>
    26a0:	98 e0       	ldi	r25, 0x08	; 8
    26a2:	f9 2a       	or	r15, r25
    26a4:	25 c0       	rjmp	.+74     	; 0x26f0 <vfprintf+0xe8>
    26a6:	e0 e1       	ldi	r30, 0x10	; 16
    26a8:	fe 2a       	or	r15, r30
    26aa:	22 c0       	rjmp	.+68     	; 0x26f0 <vfprintf+0xe8>
    26ac:	f7 fc       	sbrc	r15, 7
    26ae:	29 c0       	rjmp	.+82     	; 0x2702 <vfprintf+0xfa>
    26b0:	89 2f       	mov	r24, r25
    26b2:	80 53       	subi	r24, 0x30	; 48
    26b4:	8a 30       	cpi	r24, 0x0A	; 10
    26b6:	70 f4       	brcc	.+28     	; 0x26d4 <vfprintf+0xcc>
    26b8:	f6 fe       	sbrs	r15, 6
    26ba:	05 c0       	rjmp	.+10     	; 0x26c6 <vfprintf+0xbe>
    26bc:	98 9c       	mul	r9, r8
    26be:	90 2c       	mov	r9, r0
    26c0:	11 24       	eor	r1, r1
    26c2:	98 0e       	add	r9, r24
    26c4:	15 c0       	rjmp	.+42     	; 0x26f0 <vfprintf+0xe8>
    26c6:	e8 9c       	mul	r14, r8
    26c8:	e0 2c       	mov	r14, r0
    26ca:	11 24       	eor	r1, r1
    26cc:	e8 0e       	add	r14, r24
    26ce:	f0 e2       	ldi	r31, 0x20	; 32
    26d0:	ff 2a       	or	r15, r31
    26d2:	0e c0       	rjmp	.+28     	; 0x26f0 <vfprintf+0xe8>
    26d4:	9e 32       	cpi	r25, 0x2E	; 46
    26d6:	29 f4       	brne	.+10     	; 0x26e2 <vfprintf+0xda>
    26d8:	f6 fc       	sbrc	r15, 6
    26da:	6b c1       	rjmp	.+726    	; 0x29b2 <vfprintf+0x3aa>
    26dc:	40 e4       	ldi	r20, 0x40	; 64
    26de:	f4 2a       	or	r15, r20
    26e0:	07 c0       	rjmp	.+14     	; 0x26f0 <vfprintf+0xe8>
    26e2:	9c 36       	cpi	r25, 0x6C	; 108
    26e4:	19 f4       	brne	.+6      	; 0x26ec <vfprintf+0xe4>
    26e6:	50 e8       	ldi	r21, 0x80	; 128
    26e8:	f5 2a       	or	r15, r21
    26ea:	02 c0       	rjmp	.+4      	; 0x26f0 <vfprintf+0xe8>
    26ec:	98 36       	cpi	r25, 0x68	; 104
    26ee:	49 f4       	brne	.+18     	; 0x2702 <vfprintf+0xfa>
    26f0:	f2 01       	movw	r30, r4
    26f2:	23 fd       	sbrc	r18, 3
    26f4:	95 91       	lpm	r25, Z+
    26f6:	23 ff       	sbrs	r18, 3
    26f8:	91 91       	ld	r25, Z+
    26fa:	2f 01       	movw	r4, r30
    26fc:	99 23       	and	r25, r25
    26fe:	09 f0       	breq	.+2      	; 0x2702 <vfprintf+0xfa>
    2700:	b8 cf       	rjmp	.-144    	; 0x2672 <vfprintf+0x6a>
    2702:	89 2f       	mov	r24, r25
    2704:	85 54       	subi	r24, 0x45	; 69
    2706:	83 30       	cpi	r24, 0x03	; 3
    2708:	18 f0       	brcs	.+6      	; 0x2710 <vfprintf+0x108>
    270a:	80 52       	subi	r24, 0x20	; 32
    270c:	83 30       	cpi	r24, 0x03	; 3
    270e:	38 f4       	brcc	.+14     	; 0x271e <vfprintf+0x116>
    2710:	44 e0       	ldi	r20, 0x04	; 4
    2712:	50 e0       	ldi	r21, 0x00	; 0
    2714:	a4 0e       	add	r10, r20
    2716:	b5 1e       	adc	r11, r21
    2718:	5f e3       	ldi	r21, 0x3F	; 63
    271a:	59 83       	std	Y+1, r21	; 0x01
    271c:	0f c0       	rjmp	.+30     	; 0x273c <vfprintf+0x134>
    271e:	93 36       	cpi	r25, 0x63	; 99
    2720:	31 f0       	breq	.+12     	; 0x272e <vfprintf+0x126>
    2722:	93 37       	cpi	r25, 0x73	; 115
    2724:	79 f0       	breq	.+30     	; 0x2744 <vfprintf+0x13c>
    2726:	93 35       	cpi	r25, 0x53	; 83
    2728:	09 f0       	breq	.+2      	; 0x272c <vfprintf+0x124>
    272a:	56 c0       	rjmp	.+172    	; 0x27d8 <vfprintf+0x1d0>
    272c:	20 c0       	rjmp	.+64     	; 0x276e <vfprintf+0x166>
    272e:	f5 01       	movw	r30, r10
    2730:	80 81       	ld	r24, Z
    2732:	89 83       	std	Y+1, r24	; 0x01
    2734:	42 e0       	ldi	r20, 0x02	; 2
    2736:	50 e0       	ldi	r21, 0x00	; 0
    2738:	a4 0e       	add	r10, r20
    273a:	b5 1e       	adc	r11, r21
    273c:	61 01       	movw	r12, r2
    273e:	01 e0       	ldi	r16, 0x01	; 1
    2740:	10 e0       	ldi	r17, 0x00	; 0
    2742:	12 c0       	rjmp	.+36     	; 0x2768 <vfprintf+0x160>
    2744:	f5 01       	movw	r30, r10
    2746:	c0 80       	ld	r12, Z
    2748:	d1 80       	ldd	r13, Z+1	; 0x01
    274a:	f6 fc       	sbrc	r15, 6
    274c:	03 c0       	rjmp	.+6      	; 0x2754 <vfprintf+0x14c>
    274e:	6f ef       	ldi	r22, 0xFF	; 255
    2750:	7f ef       	ldi	r23, 0xFF	; 255
    2752:	02 c0       	rjmp	.+4      	; 0x2758 <vfprintf+0x150>
    2754:	69 2d       	mov	r22, r9
    2756:	70 e0       	ldi	r23, 0x00	; 0
    2758:	42 e0       	ldi	r20, 0x02	; 2
    275a:	50 e0       	ldi	r21, 0x00	; 0
    275c:	a4 0e       	add	r10, r20
    275e:	b5 1e       	adc	r11, r21
    2760:	c6 01       	movw	r24, r12
    2762:	0e 94 ec 14 	call	0x29d8	; 0x29d8 <strnlen>
    2766:	8c 01       	movw	r16, r24
    2768:	5f e7       	ldi	r21, 0x7F	; 127
    276a:	f5 22       	and	r15, r21
    276c:	14 c0       	rjmp	.+40     	; 0x2796 <vfprintf+0x18e>
    276e:	f5 01       	movw	r30, r10
    2770:	c0 80       	ld	r12, Z
    2772:	d1 80       	ldd	r13, Z+1	; 0x01
    2774:	f6 fc       	sbrc	r15, 6
    2776:	03 c0       	rjmp	.+6      	; 0x277e <vfprintf+0x176>
    2778:	6f ef       	ldi	r22, 0xFF	; 255
    277a:	7f ef       	ldi	r23, 0xFF	; 255
    277c:	02 c0       	rjmp	.+4      	; 0x2782 <vfprintf+0x17a>
    277e:	69 2d       	mov	r22, r9
    2780:	70 e0       	ldi	r23, 0x00	; 0
    2782:	42 e0       	ldi	r20, 0x02	; 2
    2784:	50 e0       	ldi	r21, 0x00	; 0
    2786:	a4 0e       	add	r10, r20
    2788:	b5 1e       	adc	r11, r21
    278a:	c6 01       	movw	r24, r12
    278c:	0e 94 e1 14 	call	0x29c2	; 0x29c2 <strnlen_P>
    2790:	8c 01       	movw	r16, r24
    2792:	50 e8       	ldi	r21, 0x80	; 128
    2794:	f5 2a       	or	r15, r21
    2796:	f3 fe       	sbrs	r15, 3
    2798:	07 c0       	rjmp	.+14     	; 0x27a8 <vfprintf+0x1a0>
    279a:	1a c0       	rjmp	.+52     	; 0x27d0 <vfprintf+0x1c8>
    279c:	80 e2       	ldi	r24, 0x20	; 32
    279e:	90 e0       	ldi	r25, 0x00	; 0
    27a0:	b3 01       	movw	r22, r6
    27a2:	0e 94 f7 14 	call	0x29ee	; 0x29ee <fputc>
    27a6:	ea 94       	dec	r14
    27a8:	8e 2d       	mov	r24, r14
    27aa:	90 e0       	ldi	r25, 0x00	; 0
    27ac:	08 17       	cp	r16, r24
    27ae:	19 07       	cpc	r17, r25
    27b0:	a8 f3       	brcs	.-22     	; 0x279c <vfprintf+0x194>
    27b2:	0e c0       	rjmp	.+28     	; 0x27d0 <vfprintf+0x1c8>
    27b4:	f6 01       	movw	r30, r12
    27b6:	f7 fc       	sbrc	r15, 7
    27b8:	85 91       	lpm	r24, Z+
    27ba:	f7 fe       	sbrs	r15, 7
    27bc:	81 91       	ld	r24, Z+
    27be:	6f 01       	movw	r12, r30
    27c0:	90 e0       	ldi	r25, 0x00	; 0
    27c2:	b3 01       	movw	r22, r6
    27c4:	0e 94 f7 14 	call	0x29ee	; 0x29ee <fputc>
    27c8:	e1 10       	cpse	r14, r1
    27ca:	ea 94       	dec	r14
    27cc:	01 50       	subi	r16, 0x01	; 1
    27ce:	10 40       	sbci	r17, 0x00	; 0
    27d0:	01 15       	cp	r16, r1
    27d2:	11 05       	cpc	r17, r1
    27d4:	79 f7       	brne	.-34     	; 0x27b4 <vfprintf+0x1ac>
    27d6:	ea c0       	rjmp	.+468    	; 0x29ac <vfprintf+0x3a4>
    27d8:	94 36       	cpi	r25, 0x64	; 100
    27da:	11 f0       	breq	.+4      	; 0x27e0 <vfprintf+0x1d8>
    27dc:	99 36       	cpi	r25, 0x69	; 105
    27de:	69 f5       	brne	.+90     	; 0x283a <vfprintf+0x232>
    27e0:	f7 fe       	sbrs	r15, 7
    27e2:	08 c0       	rjmp	.+16     	; 0x27f4 <vfprintf+0x1ec>
    27e4:	f5 01       	movw	r30, r10
    27e6:	20 81       	ld	r18, Z
    27e8:	31 81       	ldd	r19, Z+1	; 0x01
    27ea:	42 81       	ldd	r20, Z+2	; 0x02
    27ec:	53 81       	ldd	r21, Z+3	; 0x03
    27ee:	84 e0       	ldi	r24, 0x04	; 4
    27f0:	90 e0       	ldi	r25, 0x00	; 0
    27f2:	0a c0       	rjmp	.+20     	; 0x2808 <vfprintf+0x200>
    27f4:	f5 01       	movw	r30, r10
    27f6:	80 81       	ld	r24, Z
    27f8:	91 81       	ldd	r25, Z+1	; 0x01
    27fa:	9c 01       	movw	r18, r24
    27fc:	44 27       	eor	r20, r20
    27fe:	37 fd       	sbrc	r19, 7
    2800:	40 95       	com	r20
    2802:	54 2f       	mov	r21, r20
    2804:	82 e0       	ldi	r24, 0x02	; 2
    2806:	90 e0       	ldi	r25, 0x00	; 0
    2808:	a8 0e       	add	r10, r24
    280a:	b9 1e       	adc	r11, r25
    280c:	9f e6       	ldi	r25, 0x6F	; 111
    280e:	f9 22       	and	r15, r25
    2810:	57 ff       	sbrs	r21, 7
    2812:	09 c0       	rjmp	.+18     	; 0x2826 <vfprintf+0x21e>
    2814:	50 95       	com	r21
    2816:	40 95       	com	r20
    2818:	30 95       	com	r19
    281a:	21 95       	neg	r18
    281c:	3f 4f       	sbci	r19, 0xFF	; 255
    281e:	4f 4f       	sbci	r20, 0xFF	; 255
    2820:	5f 4f       	sbci	r21, 0xFF	; 255
    2822:	e0 e8       	ldi	r30, 0x80	; 128
    2824:	fe 2a       	or	r15, r30
    2826:	ca 01       	movw	r24, r20
    2828:	b9 01       	movw	r22, r18
    282a:	a1 01       	movw	r20, r2
    282c:	2a e0       	ldi	r18, 0x0A	; 10
    282e:	30 e0       	ldi	r19, 0x00	; 0
    2830:	0e 94 23 15 	call	0x2a46	; 0x2a46 <__ultoa_invert>
    2834:	d8 2e       	mov	r13, r24
    2836:	d2 18       	sub	r13, r2
    2838:	40 c0       	rjmp	.+128    	; 0x28ba <vfprintf+0x2b2>
    283a:	95 37       	cpi	r25, 0x75	; 117
    283c:	29 f4       	brne	.+10     	; 0x2848 <vfprintf+0x240>
    283e:	1f 2d       	mov	r17, r15
    2840:	1f 7e       	andi	r17, 0xEF	; 239
    2842:	2a e0       	ldi	r18, 0x0A	; 10
    2844:	30 e0       	ldi	r19, 0x00	; 0
    2846:	1d c0       	rjmp	.+58     	; 0x2882 <vfprintf+0x27a>
    2848:	1f 2d       	mov	r17, r15
    284a:	19 7f       	andi	r17, 0xF9	; 249
    284c:	9f 36       	cpi	r25, 0x6F	; 111
    284e:	61 f0       	breq	.+24     	; 0x2868 <vfprintf+0x260>
    2850:	90 37       	cpi	r25, 0x70	; 112
    2852:	20 f4       	brcc	.+8      	; 0x285c <vfprintf+0x254>
    2854:	98 35       	cpi	r25, 0x58	; 88
    2856:	09 f0       	breq	.+2      	; 0x285a <vfprintf+0x252>
    2858:	ac c0       	rjmp	.+344    	; 0x29b2 <vfprintf+0x3aa>
    285a:	0f c0       	rjmp	.+30     	; 0x287a <vfprintf+0x272>
    285c:	90 37       	cpi	r25, 0x70	; 112
    285e:	39 f0       	breq	.+14     	; 0x286e <vfprintf+0x266>
    2860:	98 37       	cpi	r25, 0x78	; 120
    2862:	09 f0       	breq	.+2      	; 0x2866 <vfprintf+0x25e>
    2864:	a6 c0       	rjmp	.+332    	; 0x29b2 <vfprintf+0x3aa>
    2866:	04 c0       	rjmp	.+8      	; 0x2870 <vfprintf+0x268>
    2868:	28 e0       	ldi	r18, 0x08	; 8
    286a:	30 e0       	ldi	r19, 0x00	; 0
    286c:	0a c0       	rjmp	.+20     	; 0x2882 <vfprintf+0x27a>
    286e:	10 61       	ori	r17, 0x10	; 16
    2870:	14 fd       	sbrc	r17, 4
    2872:	14 60       	ori	r17, 0x04	; 4
    2874:	20 e1       	ldi	r18, 0x10	; 16
    2876:	30 e0       	ldi	r19, 0x00	; 0
    2878:	04 c0       	rjmp	.+8      	; 0x2882 <vfprintf+0x27a>
    287a:	14 fd       	sbrc	r17, 4
    287c:	16 60       	ori	r17, 0x06	; 6
    287e:	20 e1       	ldi	r18, 0x10	; 16
    2880:	32 e0       	ldi	r19, 0x02	; 2
    2882:	17 ff       	sbrs	r17, 7
    2884:	08 c0       	rjmp	.+16     	; 0x2896 <vfprintf+0x28e>
    2886:	f5 01       	movw	r30, r10
    2888:	60 81       	ld	r22, Z
    288a:	71 81       	ldd	r23, Z+1	; 0x01
    288c:	82 81       	ldd	r24, Z+2	; 0x02
    288e:	93 81       	ldd	r25, Z+3	; 0x03
    2890:	44 e0       	ldi	r20, 0x04	; 4
    2892:	50 e0       	ldi	r21, 0x00	; 0
    2894:	08 c0       	rjmp	.+16     	; 0x28a6 <vfprintf+0x29e>
    2896:	f5 01       	movw	r30, r10
    2898:	80 81       	ld	r24, Z
    289a:	91 81       	ldd	r25, Z+1	; 0x01
    289c:	bc 01       	movw	r22, r24
    289e:	80 e0       	ldi	r24, 0x00	; 0
    28a0:	90 e0       	ldi	r25, 0x00	; 0
    28a2:	42 e0       	ldi	r20, 0x02	; 2
    28a4:	50 e0       	ldi	r21, 0x00	; 0
    28a6:	a4 0e       	add	r10, r20
    28a8:	b5 1e       	adc	r11, r21
    28aa:	a1 01       	movw	r20, r2
    28ac:	0e 94 23 15 	call	0x2a46	; 0x2a46 <__ultoa_invert>
    28b0:	d8 2e       	mov	r13, r24
    28b2:	d2 18       	sub	r13, r2
    28b4:	8f e7       	ldi	r24, 0x7F	; 127
    28b6:	f8 2e       	mov	r15, r24
    28b8:	f1 22       	and	r15, r17
    28ba:	f6 fe       	sbrs	r15, 6
    28bc:	0b c0       	rjmp	.+22     	; 0x28d4 <vfprintf+0x2cc>
    28be:	5e ef       	ldi	r21, 0xFE	; 254
    28c0:	f5 22       	and	r15, r21
    28c2:	d9 14       	cp	r13, r9
    28c4:	38 f4       	brcc	.+14     	; 0x28d4 <vfprintf+0x2cc>
    28c6:	f4 fe       	sbrs	r15, 4
    28c8:	07 c0       	rjmp	.+14     	; 0x28d8 <vfprintf+0x2d0>
    28ca:	f2 fc       	sbrc	r15, 2
    28cc:	05 c0       	rjmp	.+10     	; 0x28d8 <vfprintf+0x2d0>
    28ce:	8f ee       	ldi	r24, 0xEF	; 239
    28d0:	f8 22       	and	r15, r24
    28d2:	02 c0       	rjmp	.+4      	; 0x28d8 <vfprintf+0x2d0>
    28d4:	1d 2d       	mov	r17, r13
    28d6:	01 c0       	rjmp	.+2      	; 0x28da <vfprintf+0x2d2>
    28d8:	19 2d       	mov	r17, r9
    28da:	f4 fe       	sbrs	r15, 4
    28dc:	0d c0       	rjmp	.+26     	; 0x28f8 <vfprintf+0x2f0>
    28de:	fe 01       	movw	r30, r28
    28e0:	ed 0d       	add	r30, r13
    28e2:	f1 1d       	adc	r31, r1
    28e4:	80 81       	ld	r24, Z
    28e6:	80 33       	cpi	r24, 0x30	; 48
    28e8:	19 f4       	brne	.+6      	; 0x28f0 <vfprintf+0x2e8>
    28ea:	99 ee       	ldi	r25, 0xE9	; 233
    28ec:	f9 22       	and	r15, r25
    28ee:	08 c0       	rjmp	.+16     	; 0x2900 <vfprintf+0x2f8>
    28f0:	1f 5f       	subi	r17, 0xFF	; 255
    28f2:	f2 fe       	sbrs	r15, 2
    28f4:	05 c0       	rjmp	.+10     	; 0x2900 <vfprintf+0x2f8>
    28f6:	03 c0       	rjmp	.+6      	; 0x28fe <vfprintf+0x2f6>
    28f8:	8f 2d       	mov	r24, r15
    28fa:	86 78       	andi	r24, 0x86	; 134
    28fc:	09 f0       	breq	.+2      	; 0x2900 <vfprintf+0x2f8>
    28fe:	1f 5f       	subi	r17, 0xFF	; 255
    2900:	0f 2d       	mov	r16, r15
    2902:	f3 fc       	sbrc	r15, 3
    2904:	14 c0       	rjmp	.+40     	; 0x292e <vfprintf+0x326>
    2906:	f0 fe       	sbrs	r15, 0
    2908:	0f c0       	rjmp	.+30     	; 0x2928 <vfprintf+0x320>
    290a:	1e 15       	cp	r17, r14
    290c:	10 f0       	brcs	.+4      	; 0x2912 <vfprintf+0x30a>
    290e:	9d 2c       	mov	r9, r13
    2910:	0b c0       	rjmp	.+22     	; 0x2928 <vfprintf+0x320>
    2912:	9d 2c       	mov	r9, r13
    2914:	9e 0c       	add	r9, r14
    2916:	91 1a       	sub	r9, r17
    2918:	1e 2d       	mov	r17, r14
    291a:	06 c0       	rjmp	.+12     	; 0x2928 <vfprintf+0x320>
    291c:	80 e2       	ldi	r24, 0x20	; 32
    291e:	90 e0       	ldi	r25, 0x00	; 0
    2920:	b3 01       	movw	r22, r6
    2922:	0e 94 f7 14 	call	0x29ee	; 0x29ee <fputc>
    2926:	1f 5f       	subi	r17, 0xFF	; 255
    2928:	1e 15       	cp	r17, r14
    292a:	c0 f3       	brcs	.-16     	; 0x291c <vfprintf+0x314>
    292c:	04 c0       	rjmp	.+8      	; 0x2936 <vfprintf+0x32e>
    292e:	1e 15       	cp	r17, r14
    2930:	10 f4       	brcc	.+4      	; 0x2936 <vfprintf+0x32e>
    2932:	e1 1a       	sub	r14, r17
    2934:	01 c0       	rjmp	.+2      	; 0x2938 <vfprintf+0x330>
    2936:	ee 24       	eor	r14, r14
    2938:	04 ff       	sbrs	r16, 4
    293a:	0f c0       	rjmp	.+30     	; 0x295a <vfprintf+0x352>
    293c:	80 e3       	ldi	r24, 0x30	; 48
    293e:	90 e0       	ldi	r25, 0x00	; 0
    2940:	b3 01       	movw	r22, r6
    2942:	0e 94 f7 14 	call	0x29ee	; 0x29ee <fputc>
    2946:	02 ff       	sbrs	r16, 2
    2948:	1d c0       	rjmp	.+58     	; 0x2984 <vfprintf+0x37c>
    294a:	01 fd       	sbrc	r16, 1
    294c:	03 c0       	rjmp	.+6      	; 0x2954 <vfprintf+0x34c>
    294e:	88 e7       	ldi	r24, 0x78	; 120
    2950:	90 e0       	ldi	r25, 0x00	; 0
    2952:	0e c0       	rjmp	.+28     	; 0x2970 <vfprintf+0x368>
    2954:	88 e5       	ldi	r24, 0x58	; 88
    2956:	90 e0       	ldi	r25, 0x00	; 0
    2958:	0b c0       	rjmp	.+22     	; 0x2970 <vfprintf+0x368>
    295a:	80 2f       	mov	r24, r16
    295c:	86 78       	andi	r24, 0x86	; 134
    295e:	91 f0       	breq	.+36     	; 0x2984 <vfprintf+0x37c>
    2960:	01 ff       	sbrs	r16, 1
    2962:	02 c0       	rjmp	.+4      	; 0x2968 <vfprintf+0x360>
    2964:	8b e2       	ldi	r24, 0x2B	; 43
    2966:	01 c0       	rjmp	.+2      	; 0x296a <vfprintf+0x362>
    2968:	80 e2       	ldi	r24, 0x20	; 32
    296a:	f7 fc       	sbrc	r15, 7
    296c:	8d e2       	ldi	r24, 0x2D	; 45
    296e:	90 e0       	ldi	r25, 0x00	; 0
    2970:	b3 01       	movw	r22, r6
    2972:	0e 94 f7 14 	call	0x29ee	; 0x29ee <fputc>
    2976:	06 c0       	rjmp	.+12     	; 0x2984 <vfprintf+0x37c>
    2978:	80 e3       	ldi	r24, 0x30	; 48
    297a:	90 e0       	ldi	r25, 0x00	; 0
    297c:	b3 01       	movw	r22, r6
    297e:	0e 94 f7 14 	call	0x29ee	; 0x29ee <fputc>
    2982:	9a 94       	dec	r9
    2984:	d9 14       	cp	r13, r9
    2986:	c0 f3       	brcs	.-16     	; 0x2978 <vfprintf+0x370>
    2988:	da 94       	dec	r13
    298a:	f1 01       	movw	r30, r2
    298c:	ed 0d       	add	r30, r13
    298e:	f1 1d       	adc	r31, r1
    2990:	80 81       	ld	r24, Z
    2992:	90 e0       	ldi	r25, 0x00	; 0
    2994:	b3 01       	movw	r22, r6
    2996:	0e 94 f7 14 	call	0x29ee	; 0x29ee <fputc>
    299a:	dd 20       	and	r13, r13
    299c:	a9 f7       	brne	.-22     	; 0x2988 <vfprintf+0x380>
    299e:	06 c0       	rjmp	.+12     	; 0x29ac <vfprintf+0x3a4>
    29a0:	80 e2       	ldi	r24, 0x20	; 32
    29a2:	90 e0       	ldi	r25, 0x00	; 0
    29a4:	b3 01       	movw	r22, r6
    29a6:	0e 94 f7 14 	call	0x29ee	; 0x29ee <fputc>
    29aa:	ea 94       	dec	r14
    29ac:	ee 20       	and	r14, r14
    29ae:	c1 f7       	brne	.-16     	; 0x29a0 <vfprintf+0x398>
    29b0:	43 ce       	rjmp	.-890    	; 0x2638 <vfprintf+0x30>
    29b2:	f3 01       	movw	r30, r6
    29b4:	66 81       	ldd	r22, Z+6	; 0x06
    29b6:	77 81       	ldd	r23, Z+7	; 0x07
    29b8:	cb 01       	movw	r24, r22
    29ba:	2b 96       	adiw	r28, 0x0b	; 11
    29bc:	e2 e1       	ldi	r30, 0x12	; 18
    29be:	0c 94 b1 15 	jmp	0x2b62	; 0x2b62 <__epilogue_restores__>

000029c2 <strnlen_P>:
    29c2:	fc 01       	movw	r30, r24
    29c4:	05 90       	lpm	r0, Z+
    29c6:	61 50       	subi	r22, 0x01	; 1
    29c8:	70 40       	sbci	r23, 0x00	; 0
    29ca:	01 10       	cpse	r0, r1
    29cc:	d8 f7       	brcc	.-10     	; 0x29c4 <strnlen_P+0x2>
    29ce:	80 95       	com	r24
    29d0:	90 95       	com	r25
    29d2:	8e 0f       	add	r24, r30
    29d4:	9f 1f       	adc	r25, r31
    29d6:	08 95       	ret

000029d8 <strnlen>:
    29d8:	fc 01       	movw	r30, r24
    29da:	61 50       	subi	r22, 0x01	; 1
    29dc:	70 40       	sbci	r23, 0x00	; 0
    29de:	01 90       	ld	r0, Z+
    29e0:	01 10       	cpse	r0, r1
    29e2:	d8 f7       	brcc	.-10     	; 0x29da <strnlen+0x2>
    29e4:	80 95       	com	r24
    29e6:	90 95       	com	r25
    29e8:	8e 0f       	add	r24, r30
    29ea:	9f 1f       	adc	r25, r31
    29ec:	08 95       	ret

000029ee <fputc>:
    29ee:	0f 93       	push	r16
    29f0:	1f 93       	push	r17
    29f2:	cf 93       	push	r28
    29f4:	df 93       	push	r29
    29f6:	8c 01       	movw	r16, r24
    29f8:	eb 01       	movw	r28, r22
    29fa:	8b 81       	ldd	r24, Y+3	; 0x03
    29fc:	81 ff       	sbrs	r24, 1
    29fe:	1b c0       	rjmp	.+54     	; 0x2a36 <fputc+0x48>
    2a00:	82 ff       	sbrs	r24, 2
    2a02:	0d c0       	rjmp	.+26     	; 0x2a1e <fputc+0x30>
    2a04:	2e 81       	ldd	r18, Y+6	; 0x06
    2a06:	3f 81       	ldd	r19, Y+7	; 0x07
    2a08:	8c 81       	ldd	r24, Y+4	; 0x04
    2a0a:	9d 81       	ldd	r25, Y+5	; 0x05
    2a0c:	28 17       	cp	r18, r24
    2a0e:	39 07       	cpc	r19, r25
    2a10:	64 f4       	brge	.+24     	; 0x2a2a <fputc+0x3c>
    2a12:	e8 81       	ld	r30, Y
    2a14:	f9 81       	ldd	r31, Y+1	; 0x01
    2a16:	01 93       	st	Z+, r16
    2a18:	f9 83       	std	Y+1, r31	; 0x01
    2a1a:	e8 83       	st	Y, r30
    2a1c:	06 c0       	rjmp	.+12     	; 0x2a2a <fputc+0x3c>
    2a1e:	e8 85       	ldd	r30, Y+8	; 0x08
    2a20:	f9 85       	ldd	r31, Y+9	; 0x09
    2a22:	80 2f       	mov	r24, r16
    2a24:	09 95       	icall
    2a26:	89 2b       	or	r24, r25
    2a28:	31 f4       	brne	.+12     	; 0x2a36 <fputc+0x48>
    2a2a:	8e 81       	ldd	r24, Y+6	; 0x06
    2a2c:	9f 81       	ldd	r25, Y+7	; 0x07
    2a2e:	01 96       	adiw	r24, 0x01	; 1
    2a30:	9f 83       	std	Y+7, r25	; 0x07
    2a32:	8e 83       	std	Y+6, r24	; 0x06
    2a34:	02 c0       	rjmp	.+4      	; 0x2a3a <fputc+0x4c>
    2a36:	0f ef       	ldi	r16, 0xFF	; 255
    2a38:	1f ef       	ldi	r17, 0xFF	; 255
    2a3a:	c8 01       	movw	r24, r16
    2a3c:	df 91       	pop	r29
    2a3e:	cf 91       	pop	r28
    2a40:	1f 91       	pop	r17
    2a42:	0f 91       	pop	r16
    2a44:	08 95       	ret

00002a46 <__ultoa_invert>:
    2a46:	fa 01       	movw	r30, r20
    2a48:	aa 27       	eor	r26, r26
    2a4a:	28 30       	cpi	r18, 0x08	; 8
    2a4c:	51 f1       	breq	.+84     	; 0x2aa2 <__ultoa_invert+0x5c>
    2a4e:	20 31       	cpi	r18, 0x10	; 16
    2a50:	81 f1       	breq	.+96     	; 0x2ab2 <__ultoa_invert+0x6c>
    2a52:	e8 94       	clt
    2a54:	6f 93       	push	r22
    2a56:	6e 7f       	andi	r22, 0xFE	; 254
    2a58:	6e 5f       	subi	r22, 0xFE	; 254
    2a5a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a5c:	8f 4f       	sbci	r24, 0xFF	; 255
    2a5e:	9f 4f       	sbci	r25, 0xFF	; 255
    2a60:	af 4f       	sbci	r26, 0xFF	; 255
    2a62:	b1 e0       	ldi	r27, 0x01	; 1
    2a64:	3e d0       	rcall	.+124    	; 0x2ae2 <__ultoa_invert+0x9c>
    2a66:	b4 e0       	ldi	r27, 0x04	; 4
    2a68:	3c d0       	rcall	.+120    	; 0x2ae2 <__ultoa_invert+0x9c>
    2a6a:	67 0f       	add	r22, r23
    2a6c:	78 1f       	adc	r23, r24
    2a6e:	89 1f       	adc	r24, r25
    2a70:	9a 1f       	adc	r25, r26
    2a72:	a1 1d       	adc	r26, r1
    2a74:	68 0f       	add	r22, r24
    2a76:	79 1f       	adc	r23, r25
    2a78:	8a 1f       	adc	r24, r26
    2a7a:	91 1d       	adc	r25, r1
    2a7c:	a1 1d       	adc	r26, r1
    2a7e:	6a 0f       	add	r22, r26
    2a80:	71 1d       	adc	r23, r1
    2a82:	81 1d       	adc	r24, r1
    2a84:	91 1d       	adc	r25, r1
    2a86:	a1 1d       	adc	r26, r1
    2a88:	20 d0       	rcall	.+64     	; 0x2aca <__ultoa_invert+0x84>
    2a8a:	09 f4       	brne	.+2      	; 0x2a8e <__ultoa_invert+0x48>
    2a8c:	68 94       	set
    2a8e:	3f 91       	pop	r19
    2a90:	2a e0       	ldi	r18, 0x0A	; 10
    2a92:	26 9f       	mul	r18, r22
    2a94:	11 24       	eor	r1, r1
    2a96:	30 19       	sub	r19, r0
    2a98:	30 5d       	subi	r19, 0xD0	; 208
    2a9a:	31 93       	st	Z+, r19
    2a9c:	de f6       	brtc	.-74     	; 0x2a54 <__ultoa_invert+0xe>
    2a9e:	cf 01       	movw	r24, r30
    2aa0:	08 95       	ret
    2aa2:	46 2f       	mov	r20, r22
    2aa4:	47 70       	andi	r20, 0x07	; 7
    2aa6:	40 5d       	subi	r20, 0xD0	; 208
    2aa8:	41 93       	st	Z+, r20
    2aaa:	b3 e0       	ldi	r27, 0x03	; 3
    2aac:	0f d0       	rcall	.+30     	; 0x2acc <__ultoa_invert+0x86>
    2aae:	c9 f7       	brne	.-14     	; 0x2aa2 <__ultoa_invert+0x5c>
    2ab0:	f6 cf       	rjmp	.-20     	; 0x2a9e <__ultoa_invert+0x58>
    2ab2:	46 2f       	mov	r20, r22
    2ab4:	4f 70       	andi	r20, 0x0F	; 15
    2ab6:	40 5d       	subi	r20, 0xD0	; 208
    2ab8:	4a 33       	cpi	r20, 0x3A	; 58
    2aba:	18 f0       	brcs	.+6      	; 0x2ac2 <__ultoa_invert+0x7c>
    2abc:	49 5d       	subi	r20, 0xD9	; 217
    2abe:	31 fd       	sbrc	r19, 1
    2ac0:	40 52       	subi	r20, 0x20	; 32
    2ac2:	41 93       	st	Z+, r20
    2ac4:	02 d0       	rcall	.+4      	; 0x2aca <__ultoa_invert+0x84>
    2ac6:	a9 f7       	brne	.-22     	; 0x2ab2 <__ultoa_invert+0x6c>
    2ac8:	ea cf       	rjmp	.-44     	; 0x2a9e <__ultoa_invert+0x58>
    2aca:	b4 e0       	ldi	r27, 0x04	; 4
    2acc:	a6 95       	lsr	r26
    2ace:	97 95       	ror	r25
    2ad0:	87 95       	ror	r24
    2ad2:	77 95       	ror	r23
    2ad4:	67 95       	ror	r22
    2ad6:	ba 95       	dec	r27
    2ad8:	c9 f7       	brne	.-14     	; 0x2acc <__ultoa_invert+0x86>
    2ada:	00 97       	sbiw	r24, 0x00	; 0
    2adc:	61 05       	cpc	r22, r1
    2ade:	71 05       	cpc	r23, r1
    2ae0:	08 95       	ret
    2ae2:	9b 01       	movw	r18, r22
    2ae4:	ac 01       	movw	r20, r24
    2ae6:	0a 2e       	mov	r0, r26
    2ae8:	06 94       	lsr	r0
    2aea:	57 95       	ror	r21
    2aec:	47 95       	ror	r20
    2aee:	37 95       	ror	r19
    2af0:	27 95       	ror	r18
    2af2:	ba 95       	dec	r27
    2af4:	c9 f7       	brne	.-14     	; 0x2ae8 <__ultoa_invert+0xa2>
    2af6:	62 0f       	add	r22, r18
    2af8:	73 1f       	adc	r23, r19
    2afa:	84 1f       	adc	r24, r20
    2afc:	95 1f       	adc	r25, r21
    2afe:	a0 1d       	adc	r26, r0
    2b00:	08 95       	ret

00002b02 <__udivmodhi4>:
    2b02:	aa 1b       	sub	r26, r26
    2b04:	bb 1b       	sub	r27, r27
    2b06:	51 e1       	ldi	r21, 0x11	; 17
    2b08:	07 c0       	rjmp	.+14     	; 0x2b18 <__udivmodhi4_ep>

00002b0a <__udivmodhi4_loop>:
    2b0a:	aa 1f       	adc	r26, r26
    2b0c:	bb 1f       	adc	r27, r27
    2b0e:	a6 17       	cp	r26, r22
    2b10:	b7 07       	cpc	r27, r23
    2b12:	10 f0       	brcs	.+4      	; 0x2b18 <__udivmodhi4_ep>
    2b14:	a6 1b       	sub	r26, r22
    2b16:	b7 0b       	sbc	r27, r23

00002b18 <__udivmodhi4_ep>:
    2b18:	88 1f       	adc	r24, r24
    2b1a:	99 1f       	adc	r25, r25
    2b1c:	5a 95       	dec	r21
    2b1e:	a9 f7       	brne	.-22     	; 0x2b0a <__udivmodhi4_loop>
    2b20:	80 95       	com	r24
    2b22:	90 95       	com	r25
    2b24:	bc 01       	movw	r22, r24
    2b26:	cd 01       	movw	r24, r26
    2b28:	08 95       	ret

00002b2a <__prologue_saves__>:
    2b2a:	2f 92       	push	r2
    2b2c:	3f 92       	push	r3
    2b2e:	4f 92       	push	r4
    2b30:	5f 92       	push	r5
    2b32:	6f 92       	push	r6
    2b34:	7f 92       	push	r7
    2b36:	8f 92       	push	r8
    2b38:	9f 92       	push	r9
    2b3a:	af 92       	push	r10
    2b3c:	bf 92       	push	r11
    2b3e:	cf 92       	push	r12
    2b40:	df 92       	push	r13
    2b42:	ef 92       	push	r14
    2b44:	ff 92       	push	r15
    2b46:	0f 93       	push	r16
    2b48:	1f 93       	push	r17
    2b4a:	cf 93       	push	r28
    2b4c:	df 93       	push	r29
    2b4e:	cd b7       	in	r28, 0x3d	; 61
    2b50:	de b7       	in	r29, 0x3e	; 62
    2b52:	ca 1b       	sub	r28, r26
    2b54:	db 0b       	sbc	r29, r27
    2b56:	0f b6       	in	r0, 0x3f	; 63
    2b58:	f8 94       	cli
    2b5a:	de bf       	out	0x3e, r29	; 62
    2b5c:	0f be       	out	0x3f, r0	; 63
    2b5e:	cd bf       	out	0x3d, r28	; 61
    2b60:	09 94       	ijmp

00002b62 <__epilogue_restores__>:
    2b62:	2a 88       	ldd	r2, Y+18	; 0x12
    2b64:	39 88       	ldd	r3, Y+17	; 0x11
    2b66:	48 88       	ldd	r4, Y+16	; 0x10
    2b68:	5f 84       	ldd	r5, Y+15	; 0x0f
    2b6a:	6e 84       	ldd	r6, Y+14	; 0x0e
    2b6c:	7d 84       	ldd	r7, Y+13	; 0x0d
    2b6e:	8c 84       	ldd	r8, Y+12	; 0x0c
    2b70:	9b 84       	ldd	r9, Y+11	; 0x0b
    2b72:	aa 84       	ldd	r10, Y+10	; 0x0a
    2b74:	b9 84       	ldd	r11, Y+9	; 0x09
    2b76:	c8 84       	ldd	r12, Y+8	; 0x08
    2b78:	df 80       	ldd	r13, Y+7	; 0x07
    2b7a:	ee 80       	ldd	r14, Y+6	; 0x06
    2b7c:	fd 80       	ldd	r15, Y+5	; 0x05
    2b7e:	0c 81       	ldd	r16, Y+4	; 0x04
    2b80:	1b 81       	ldd	r17, Y+3	; 0x03
    2b82:	aa 81       	ldd	r26, Y+2	; 0x02
    2b84:	b9 81       	ldd	r27, Y+1	; 0x01
    2b86:	ce 0f       	add	r28, r30
    2b88:	d1 1d       	adc	r29, r1
    2b8a:	0f b6       	in	r0, 0x3f	; 63
    2b8c:	f8 94       	cli
    2b8e:	de bf       	out	0x3e, r29	; 62
    2b90:	0f be       	out	0x3f, r0	; 63
    2b92:	cd bf       	out	0x3d, r28	; 61
    2b94:	ed 01       	movw	r28, r26
    2b96:	08 95       	ret

00002b98 <_exit>:
    2b98:	f8 94       	cli

00002b9a <__stop_program>:
    2b9a:	ff cf       	rjmp	.-2      	; 0x2b9a <__stop_program>
