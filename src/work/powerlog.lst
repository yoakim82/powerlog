   1               		.file	"powerlog.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 104               	.global	delay_us
 106               	delay_us:
   1:powerlog.c    **** //#define __AVR_ATmega644P__
   2:powerlog.c    **** 
   3:powerlog.c    **** #define BAUD_0 4800		
   4:powerlog.c    **** #define BAUD_RATE_0 F_CPU/16/BAUD_0-1
   5:powerlog.c    **** 
   6:powerlog.c    **** #define BAUD_1 115200		
   7:powerlog.c    **** #define BAUD_RATE_1 F_CPU/16/BAUD_1-1
   8:powerlog.c    **** 
   9:powerlog.c    **** 
  10:powerlog.c    **** #define TIMER_CYCLE_US 1000000/(F_CPU/1024)
  11:powerlog.c    **** 
  12:powerlog.c    **** // F_CPU is set to 1 000 000 Hz (in makefile)
  13:powerlog.c    **** 
  14:powerlog.c    **** #include <stdlib.h>
  15:powerlog.c    **** #include <avr/io.h>
  16:powerlog.c    **** #include <util/delay.h>
  17:powerlog.c    **** #include <avr/pgmspace.h>
  18:powerlog.c    **** #include <inttypes.h>
  19:powerlog.c    **** #include <avr/interrupt.h>
  20:powerlog.c    **** #include <stdio.h>
  21:powerlog.c    **** 
  22:powerlog.c    **** #include "uart.h"
  23:powerlog.c    **** #include "powerlog.h"
  24:powerlog.c    **** #include "globals.h"
  25:powerlog.c    **** #include "rfm22.h"
  26:powerlog.c    **** #include "hdlc.h"
  27:powerlog.c    **** 
  28:powerlog.c    **** #include "adc.h"
  29:powerlog.c    ****  
  30:powerlog.c    **** 
  31:powerlog.c    **** 
  32:powerlog.c    **** 
  33:powerlog.c    **** 
  34:powerlog.c    **** /* WDR() compiles to an assembler instruction. Watch Dog reset */
  35:powerlog.c    **** #define WDR()  __asm__ __volatile__ ("wdr" ::)
  36:powerlog.c    **** 
  37:powerlog.c    **** 
  38:powerlog.c    **** 
  39:powerlog.c    **** 
  40:powerlog.c    **** /*volatile BYTE var = 0x00; 
  41:powerlog.c    **** volatile BYTE button_detect = 0x00;
  42:powerlog.c    **** volatile BYTE button_detect_3 = 0x00;
  43:powerlog.c    **** 
  44:powerlog.c    **** volatile BYTE timer_tick_detect = 0;
  45:powerlog.c    **** */
  46:powerlog.c    **** 
  47:powerlog.c    **** static FILE mystdout = FDEV_SETUP_STREAM(uart_putchar, NULL, _FDEV_SETUP_WRITE);
  48:powerlog.c    **** 
  49:powerlog.c    **** 
  50:powerlog.c    **** 
  51:powerlog.c    **** //General short delays
  52:powerlog.c    **** //general short delays
  53:powerlog.c    **** //Uses internal timer do a fairly accurate 1us
  54:powerlog.c    **** //Because we are using 16MHz and a prescaler of 8 on Timer0, we have to double x
  55:powerlog.c    **** void delay_us(uint16_t x)
  56:powerlog.c    **** {
 107               	LM0-.LFBB1
 108               	.LM0:
 109               	.LFBB1:
 110 0000 AF92      		push r10
 111 0002 BF92      		push r11
 112 0004 CF92      		push r12
 113 0006 DF92      		push r13
 114 0008 EF92      		push r14
 115 000a FF92      		push r15
 116 000c 0F93      		push r16
 117 000e 1F93      		push r17
 118               	/* prologue: function */
 119               	/* frame size = 0 */
  57:powerlog.c    **** 	
  58:powerlog.c    **** 	_delay_us(x);
 120               	58,.LM1-.LFBB1
 121               	.LM1:
 122 0010 A0E0      		ldi r26,lo8(0)
 123 0012 B0E0      		ldi r27,hi8(0)
 124 0014 BC01      		movw r22,r24
 125 0016 CD01      		movw r24,r26
 126 0018 0E94 0000 		call __floatunsisf
 127 001c 5B01      		movw r10,r22
 128 001e 6C01      		movw r12,r24
 129               	.LBB24:
 130               	.LBB25:
 132               	.Ltext1:
   1:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    All rights reserved.
   5:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
   6:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
   9:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  12:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****      distribution.
  16:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  17:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  21:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  33:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** /* $Id: delay.h,v 1.5.2.1 2009/02/25 10:14:03 joerg_wunsch Exp $ */
  34:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  35:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  38:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** #include <inttypes.h>
  39:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  40:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  41:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** /** \file */
  42:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  43:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     \code
  44:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  45:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  46:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     #include <util/delay.h>
  47:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     \endcode
  48:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  49:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  50:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  51:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  52:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     used.
  53:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  54:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  55:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  56:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  57:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  58:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  59:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  60:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  61:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  62:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  63:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  64:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  65:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  66:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  67:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  68:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  69:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  70:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     routines linked into the application.
  71:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  72:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  73:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  74:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  75:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  76:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** */
  77:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  78:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  79:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  80:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  81:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** #endif
  82:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  83:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** #ifndef F_CPU
  84:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  85:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  86:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  87:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** #endif
  88:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  89:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  90:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  91:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** #endif
  92:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  93:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** /**
  94:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    \ingroup util_delay
  95:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  96:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
  97:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
  98:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
  99:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 100:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
 101:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 102:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
 103:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 104:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 105:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 106:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 107:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 108:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****  */
 109:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** void
 110:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** _delay_ms(double __ms)
 111:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** {
 112:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	uint16_t __ticks;
 113:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 4e3) * __ms;
 114:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 115:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 		__ticks = 1;
 116:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 117:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	{
 118:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 119:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 120:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 		while(__ticks)
 121:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 		{
 122:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 			// wait 1/10 ms
 123:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 124:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 			__ticks --;
 125:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 		}
 126:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 		return;
 127:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	}
 128:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	else
 129:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 130:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 131:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** }
 132:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
 133:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** /**
 134:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    \ingroup util_delay
 135:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
 136:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 137:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
 138:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 139:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 140:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
 141:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 142:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 
 143:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 144:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 145:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****    will not be informed about this case.
 146:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h ****  */
 147:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** void
 148:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** _delay_us(double __us)
 149:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** {
 150:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	uint8_t __ticks;
 151:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 3e6) * __us;
 133               	151,.LM2-.LFBB1
 134               	.LM2:
 135 0020 2BEA      		ldi r18,lo8(0x3eaaaaab)
 136 0022 3AEA      		ldi r19,hi8(0x3eaaaaab)
 137 0024 4AEA      		ldi r20,hlo8(0x3eaaaaab)
 138 0026 5EE3      		ldi r21,hhi8(0x3eaaaaab)
 139 0028 0E94 0000 		call __mulsf3
 140 002c 7B01      		movw r14,r22
 141 002e 8C01      		movw r16,r24
 152:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 142               	8,0,152,.LM3-.LFBB1
 143               	.LM3:
 144 0030 20E0      		ldi r18,lo8(0x3f800000)
 145 0032 30E0      		ldi r19,hi8(0x3f800000)
 146 0034 40E8      		ldi r20,hlo8(0x3f800000)
 147 0036 5FE3      		ldi r21,hhi8(0x3f800000)
 148 0038 0E94 0000 		call __ltsf2
 149 003c 8823      		tst r24
 150 003e 04F4      		brge .L21
 151 0040 61E0      		ldi r22,lo8(1)
 152 0042 00C0      		rjmp .L4
 153               	.L21:
 153:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 		__ticks = 1;
 154:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	else if (__tmp > 255)
 154               	,154,.LM4-.LFBB1
 155               	.LM4:
 156 0044 C801      		movw r24,r16
 157 0046 B701      		movw r22,r14
 158 0048 20E0      		ldi r18,lo8(0x437f0000)
 159 004a 30E0      		ldi r19,hi8(0x437f0000)
 160 004c 4FE7      		ldi r20,hlo8(0x437f0000)
 161 004e 53E4      		ldi r21,hhi8(0x437f0000)
 162 0050 0E94 0000 		call __gtsf2
 163 0054 1816      		cp __zero_reg__,r24
 164 0056 04F0      		brlt .+2
 165 0058 00C0      		rjmp .L22
 155:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	{
 156:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 		_delay_ms(__us / 1000.0);
 166               	,156,.LM5-.LFBB1
 167               	.LM5:
 168 005a C601      		movw r24,r12
 169 005c B501      		movw r22,r10
 170 005e 20E0      		ldi r18,lo8(0x447a0000)
 171 0060 30E0      		ldi r19,hi8(0x447a0000)
 172 0062 4AE7      		ldi r20,hlo8(0x447a0000)
 173 0064 54E4      		ldi r21,hhi8(0x447a0000)
 174 0066 0E94 0000 		call __divsf3
 175 006a 5B01      		movw r10,r22
 176 006c 6C01      		movw r12,r24
 177               	.LBB26:
 178               	.LBB27:
 180               	.LM6:
 181 006e 20E0      		ldi r18,lo8(0x437a0000)
 182 0070 30E0      		ldi r19,hi8(0x437a0000)
 183 0072 4AE7      		ldi r20,hlo8(0x437a0000)
 184 0074 53E4      		ldi r21,hhi8(0x437a0000)
 185 0076 0E94 0000 		call __mulsf3
 186 007a 7B01      		movw r14,r22
 187 007c 8C01      		movw r16,r24
 189               	.LM7:
 190 007e 20E0      		ldi r18,lo8(0x3f800000)
 191 0080 30E0      		ldi r19,hi8(0x3f800000)
 192 0082 40E8      		ldi r20,hlo8(0x3f800000)
 193 0084 5FE3      		ldi r21,hhi8(0x3f800000)
 194 0086 0E94 0000 		call __ltsf2
 195 008a 8823      		tst r24
 196 008c 04F4      		brge .L23
 197 008e 61E0      		ldi r22,lo8(1)
 198 0090 70E0      		ldi r23,hi8(1)
 199 0092 00C0      		rjmp .L9
 200               	.L23:
 202               	.LM8:
 203 0094 C801      		movw r24,r16
 204 0096 B701      		movw r22,r14
 205 0098 20E0      		ldi r18,lo8(0x477fff00)
 206 009a 3FEF      		ldi r19,hi8(0x477fff00)
 207 009c 4FE7      		ldi r20,hlo8(0x477fff00)
 208 009e 57E4      		ldi r21,hhi8(0x477fff00)
 209 00a0 0E94 0000 		call __gtsf2
 210 00a4 1816      		cp __zero_reg__,r24
 211 00a6 04F4      		brge .L24
 213               	.LM9:
 214 00a8 C601      		movw r24,r12
 215 00aa B501      		movw r22,r10
 216 00ac 20E0      		ldi r18,lo8(0x41200000)
 217 00ae 30E0      		ldi r19,hi8(0x41200000)
 218 00b0 40E2      		ldi r20,hlo8(0x41200000)
 219 00b2 51E4      		ldi r21,hhi8(0x41200000)
 220 00b4 0E94 0000 		call __mulsf3
 221 00b8 0E94 0000 		call __fixunssfsi
 222 00bc CB01      		movw r24,r22
 224               	.LM10:
 225 00be 672B      		or r22,r23
 226 00c0 01F0      		breq .L14
 227               	.LBB28:
 228               	.LBB29:
 230               	.Ltext2:
   1:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
   5:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
   8:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  11:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      distribution.
  15:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  16:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  20:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  32:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  34:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  37:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  39:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /** \file */
  40:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     \code
  42:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     \endcode
  44:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  45:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  53:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  60:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  62:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** */
  63:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  64:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #endif
  68:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  69:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  71:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     register.
  76:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  77:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     can be achieved.
  79:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** */
  80:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** void
  81:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** {
  83:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 	);
  89:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** }
  90:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  91:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  93:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     counter register pair.
  98:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  99:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****  */
 102:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** void
 103:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** {
 105:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 231               	8(25)
 232               	.L19:
 233 00c2 29E1      		movw r30,r18
 234 00c4 30E0      	/* #APP */
 235               	 ;  105 "c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h" 1
 236 00c6 F901      		1: sbiw r30,1
 237               		brne 1b
 238               	 ;  0 "" 2
 239 00c8 3197      	/* #NOAPP */
 240 00ca 01F4      	.LBE29:
 241               	.LBE28:
 243               	.Ltext3:
 245               	.LM12:
 246               		sbiw r24,1
 248               	.LM13:
 249 00cc 0197      		brne .L19
 250               		rjmp .L14
 251               	.L24:
 253 00d0 00C0      	.LM14:
 254               		movw r24,r16
 255               		movw r22,r14
 256               		call __fixunssfsi
 257 00d2 C801      	.L9:
 258 00d4 B701      	.LBB30:
 259 00d6 0E94 0000 	.LBB31:
 261               	.Ltext4:
 263               	.LM15:
 264               		movw r24,r22
 265               	/* #APP */
 266               	 ;  105 "c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h" 1
 267 00da CB01      		1: sbiw r24,1
 268               		brne 1b
 269               	 ;  0 "" 2
 270 00dc 0197      	/* #NOAPP */
 271 00de 01F4      		rjmp .L14
 272               	.L22:
 273               	.LBE31:
 274 00e0 00C0      	.LBE30:
 275               	.LBE27:
 276               	.LBE26:
 278               	.Ltext5:
 280               	.LM16:
 281               		movw r24,r16
 157:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 		return;
 158:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	}
 159:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 	else
 160:c:/winavr-20100110/lib/gcc/../../avr/include/util/delay.h **** 		__ticks = (uint8_t)__tmp;
 282               	3:
 284 00e2 C801      	.Ltext6:
 286 00e6 0E94 0000 	.LM17:
 287               	/* #APP */
 288               	 ;  83 "c:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h" 1
 289               		1: dec r22
 290               		brne 1b
 291               	 ;  0 "" 2
 292               	/* #NOAPP */
 293               	.L14:
 294               	/* epilogue start */
 295               	.LBE33:
 296 00ea 6A95      	.LBE32:
 297 00ec 01F4      	.LBE25:
 298               	.LBE24:
 300               	.Ltext7:
 302               	.LM18:
 303               		pop r17
 304               		pop r16
 305               		pop r15
 306               		pop r14
 307               		pop r13
  59:powerlog.c    **** 	//while(x > 256)
  60:powerlog.c    **** 	//{
  61:powerlog.c    **** 	//	TIFR0 = (1<<TOV0); //Clear any interrupt flags on Timer0
  62:powerlog.c    **** 	//	TCNT0 = 0; //Preload Timer0 for 256 clicks. Should be 1us per click
  63:powerlog.c    **** 	//	while( (TIFR0 & (1<<TOV0)) == 0);
  64:powerlog.c    **** 	//	
  65:powerlog.c    **** 	//	x -= 256;
  66:powerlog.c    **** 	//}
  67:powerlog.c    **** 
  68:powerlog.c    **** 	//TIFR0 = (1<<TOV0); //Clear any interrupt flags on Timer0
  69:powerlog.c    **** 	//TCNT0 = 256 - x; //256 - 125 = 131 : Preload Timer0 for x clicks. Should be 1us per click
  70:powerlog.c    **** 	//while( (TIFR0 & (1<<TOV0)) == 0);
  71:powerlog.c    **** }
 308               	
 309               		ret
 328               	.Lscope1:
 330               	.global	delay_ms
 332               	delay_ms:
 334               	.LM19:
 335               	.LFBB2:
 336               		push r28
 337               		push r29
 338               	/* prologue: function */
 339               	/* frame size = 0 */
 340               	.LBB34:
  72:powerlog.c    **** 
  73:powerlog.c    **** 
  74:powerlog.c    **** void delay_ms(uint16_t x)
  75:powerlog.c    **** {
 342               	eg__,r28
 343               		cpc __zero_reg__,r29
 344               		brge .L28
 345 0100 CF93      	.L29:
 347               	.LM21:
 348               		ldi r24,lo8(1000)
 349               		ldi r25,hi8(1000)
  76:powerlog.c    **** 	
  77:powerlog.c    **** 	for (int i = x; i > 0; i--)
 350               	lay_us
 352 0104 EC01      	.LM22:
 353 0106 1C16      		sbiw r28,1
 354 0108 1D06      		cp __zero_reg__,r28
 355 010a 04F4      		cpc __zero_reg__,r29
 356               		brlt .L29
  78:powerlog.c    **** 		delay_us(1000);
 357               	* epilogue start */
 358               	.LBE34:
 360 010e 93E0      	.LM23:
 361 0110 0E94 0000 		pop r29
 362               		pop r28
 363               		ret
 365 0116 1C16      	.Lscope2:
 367 011a 04F0      	.global	__vector_3
 369               	__vector_3:
  79:powerlog.c    **** 	//while(x > 256)
  80:powerlog.c    **** 	//{
  81:powerlog.c    **** 	//	TIFR0 = (1<<TOV0); //Clear any interrupt flags on Timer0
  82:powerlog.c    **** 	//	TCNT0 = 0; //Preload Timer0 for 256 clicks. Should be 1us per click
  83:powerlog.c    **** 	//	while( (TIFR0 & (1<<TOV0)) == 0);
  84:powerlog.c    **** 	//	
  85:powerlog.c    **** 	//	x -= 256;
  86:powerlog.c    **** 	//}
  87:powerlog.c    **** 
  88:powerlog.c    **** 	//TIFR0 = (1<<TOV0); //Clear any interrupt flags on Timer0
  89:powerlog.c    **** 	//TCNT0 = 256 - x; //256 - 125 = 131 : Preload Timer0 for x clicks. Should be 1us per click
  90:powerlog.c    **** 	//while( (TIFR0 & (1<<TOV0)) == 0);
  91:powerlog.c    **** }
 371               	
 372               		push __zero_reg__
 373 011c DF91      		push r0
 374 011e CF91      		in r0,__SREG__
 375 0120 0895      		push r0
 376               		clr __zero_reg__
 377               		push r18
 378               		push r19
 379               		push r20
 380               		push r21
 381               		push r22
  92:powerlog.c    **** 
  93:powerlog.c    **** 
  94:powerlog.c    **** 
  95:powerlog.c    **** /* **************************************************************
  96:powerlog.c    **** *
  97:powerlog.c    **** * Name			: ioinit
  98:powerlog.c    **** *
  99:powerlog.c    **** * Function		: Setup the hardware
 100:powerlog.c    **** *
 101:powerlog.c    **** * Parameters	: void
 102:powerlog.c    **** *
 103:powerlog.c    **** * Returns		: void
 104:powerlog.c    **** *
 105:powerlog.c    **** * Checked		:
 106:powerlog.c    **** *
 107:powerlog.c    **** * Requirements	:
 108:powerlog.c    **** *
 109:powerlog.c    **** ***************************************************************** */
 110:powerlog.c    **** 
 111:powerlog.c    **** unsigned char ioinit(void)
 112:powerlog.c    **** {
 113:powerlog.c    ****   	/********************************************************/
 114:powerlog.c    **** 	/* PORTA : 	ADC7 configured as input		 			*/
 115:powerlog.c    **** 	/********************************************************/
 116:powerlog.c    **** 	DDRA = 0x7F; //0111 1111
 117:powerlog.c    **** 
 118:powerlog.c    **** 	// note: Display uses pins 6:0 on this port (outputs).
 119:powerlog.c    **** 	//       pin ADC7 is for converting Vref (input)
 120:powerlog.c    **** 	
 121:powerlog.c    **** 	/********************************************************/
 122:powerlog.c    **** 	/* Disable pullup resistors on PORTA 					*/
 123:powerlog.c    **** 	/********************************************************/
 124:powerlog.c    **** 	PORTA = 0x00 | (1<<CS); // CS_N low (inactive)	
 125:powerlog.c    **** 	
 126:powerlog.c    **** 	/********************************************************/
 127:powerlog.c    **** 	/* PORTB : 	0=GPIO0, input					 			*/
 128:powerlog.c    **** 	/*			1=GPIO1, input						 		*/
 129:powerlog.c    **** 	/*			2=INT2, sensor_n, input						*/
 130:powerlog.c    **** 	/*			3=GPIO2, F_OSC, default input 				*/
 131:powerlog.c    **** 	/*			4=one_wire_data, input	 					*/
 132:powerlog.c    **** 	/*			5=MOSI, output								*/
 133:powerlog.c    **** 	/*			6=MISO, input		 						*/
 134:powerlog.c    **** 	/*			7=SCLK, output		 						*/
 135:powerlog.c    **** 	/********************************************************/
 136:powerlog.c    **** 	DDRB = 0b10100000; // HIGH = output...			
 137:powerlog.c    **** 	
 138:powerlog.c    **** 	/********************************************************/
 139:powerlog.c    **** 	/* Disable pullup resistors on PORTB 					*/
 140:powerlog.c    **** 	/********************************************************/
 141:powerlog.c    **** 	PORTB = 0x00;	 
 142:powerlog.c    **** 	
 143:powerlog.c    **** 	/********************************************************/
 144:powerlog.c    **** 	/* PORTC : 	0=Not in use								*/
 145:powerlog.c    **** 	/*			1=Not in use								*/
 146:powerlog.c    **** 	/*			2=Not in use								*/
 147:powerlog.c    **** 	/*			3=Not in use								*/
 148:powerlog.c    **** 	/*			4=Not in use								*/
 149:powerlog.c    **** 	/*			5=not in use, input							*/
 150:powerlog.c    **** 	/*			6=not in use, input							*/
 151:powerlog.c    **** 	/*			7=not in use, input							*/
 152:powerlog.c    **** 	/********************************************************/
 153:powerlog.c    **** 	DDRC = 0x00;				
 154:powerlog.c    **** 	
 155:powerlog.c    **** 	/********************************************************/
 156:powerlog.c    **** 	/* Disable pullup resistors on PORTC 					*/
 157:powerlog.c    **** 	/********************************************************/
 158:powerlog.c    **** 	PORTC = 0x00;	
 159:powerlog.c    **** 
 160:powerlog.c    **** 
 161:powerlog.c    **** 	/********************************************************/
 162:powerlog.c    **** 	/* PORTD : 	0=UART_RXD default input 					*/
 163:powerlog.c    **** 	/*		 	1=UART_TXD default output 					*/
 164:powerlog.c    **** 	/*			2=INT0 input 								*/
 165:powerlog.c    **** 	/*			3=unused input 								*/
 166:powerlog.c    **** 	/*			4=IRQ_N, input								*/
 167:powerlog.c    **** 	/*			5=TXANT, output								*/
 168:powerlog.c    **** 	/*			6=RXANT, output								*/
 169:powerlog.c    **** 	/*			7=unused input								*/
 170:powerlog.c    **** 	/********************************************************/
 171:powerlog.c    **** 	DDRD = 0b01100010;
 172:powerlog.c    **** 	
 173:powerlog.c    **** 	/********************************************************/
 174:powerlog.c    **** 	/* Configure pullup resistors on PORTD 					*/
 175:powerlog.c    **** 	/* UART_RXD inactive									*/
 176:powerlog.c    **** 	/* UART_TXD inactive 									*/
 177:powerlog.c    **** 	/* Remaining [7:2] inactive								*/
 178:powerlog.c    **** 	/********************************************************/
 179:powerlog.c    **** 	PORTD = 0x00;	
 180:powerlog.c    **** 
 181:powerlog.c    **** 	/********************************************************/
 182:powerlog.c    **** 	/* Configure external IRQ inputs						*/
 183:powerlog.c    **** 	/********************************************************/
 184:powerlog.c    **** 	
 185:powerlog.c    **** 	// disable interrupt on INT2
 186:powerlog.c    **** 	EIMSK = 0;
 187:powerlog.c    **** 	
 188:powerlog.c    **** 	// select falling edge for interrupt on INT2
 189:powerlog.c    **** 	EICRA = (10<<ISC20); // (00<<ÍSC20); // low level interrupt on INT2
 190:powerlog.c    **** 
 191:powerlog.c    **** 	
 192:powerlog.c    **** 	// clear interrupt flags
 193:powerlog.c    **** 	EIFR = (1<<INTF2) | (1<<INTF1) | (1<<INTF0);
 194:powerlog.c    **** 	
 195:powerlog.c    **** 	// enable external interrupt on INT2 only
 196:powerlog.c    **** 	EIMSK = (1<<INT2);
 197:powerlog.c    **** 	
 198:powerlog.c    **** 	
 199:powerlog.c    **** 	/********************************************************/
 200:powerlog.c    **** 	/* Configure external pin change interrupts (PCINT)		*/
 201:powerlog.c    **** 	
 202:powerlog.c    **** 	PCMSK3 = 0;
 203:powerlog.c    **** 	PCMSK2 = 0;
 204:powerlog.c    **** 	PCMSK1 = 0;
 205:powerlog.c    **** 	PCMSK0 = 0;
 206:powerlog.c    **** 	
 207:powerlog.c    **** 	PCICR = 0;
 208:powerlog.c    **** 	
 209:powerlog.c    **** 	
 210:powerlog.c    **** 	
 211:powerlog.c    **** 	/********************************************************/
 212:powerlog.c    **** 	/* Configure and enable timer :							*/
 213:powerlog.c    **** 	/* System clock Prescaler is set to OSC / 8             */
 214:powerlog.c    **** 	/* Timer Prescaler CLK/1024	=> 976,5625 Hz @ 1 MHz CLK	*/
 215:powerlog.c    **** 	/* Normal mode 											*/
 216:powerlog.c    **** 	/********************************************************/
 217:powerlog.c    **** 	TCCR1A = 0x00;														  
 218:powerlog.c    **** 	//TCCR1B = 7<<CS10; // Tin clock source
 219:powerlog.c    **** 	TCCR1B = 5<<CS10; // clkIO / 1024 clock source
 220:powerlog.c    **** 										
 221:powerlog.c    **** 	OCR1A = 0;    												 
 222:powerlog.c    **** 	//DDRB = 1<<DDRB | 1<<PB1 | 1<<PB4 | 1<<PB5;   			
 223:powerlog.c    **** 	//TIMSK1 = 1<<TOIE1;	
 224:powerlog.c    **** 
 225:powerlog.c    **** 	//Init timer 0 for delay_us timing
 226:powerlog.c    **** 	//8,000,000 / 8 = 1,000,000
 227:powerlog.c    ****     //TCCR0B = (1<<CS01); //Set Prescaler to 8. CS01=1
 228:powerlog.c    **** 
 229:powerlog.c    **** 
 230:powerlog.c    **** 	PRR = 0;
 231:powerlog.c    **** 
 232:powerlog.c    **** 
 233:powerlog.c    **** 										 
 234:powerlog.c    **** 
 235:powerlog.c    **** 	/********************************************************/
 236:powerlog.c    **** 	/* Init UART  											*/	
 237:powerlog.c    **** 	/********************************************************/
 238:powerlog.c    **** 	stdout = &mystdout; //Required for printf init
 239:powerlog.c    **** 	
 240:powerlog.c    **** 	uart_init(BAUD_RATE_0); // set up printf uart for 9600 bps
 241:powerlog.c    **** 	
 242:powerlog.c    **** 	//uart1_init(BAUD_RATE_1); // set up hdlc uart for 115200 bps
 243:powerlog.c    **** 
 244:powerlog.c    **** 
 245:powerlog.c    **** 	/********************************************************/
 246:powerlog.c    **** 	/* Init ADC  											*/	
 247:powerlog.c    **** 	/********************************************************/
 248:powerlog.c    **** 
 249:powerlog.c    **** 	adc_init();
 250:powerlog.c    **** 	
 251:powerlog.c    **** 	
 252:powerlog.c    **** 	/********************************************************/
 253:powerlog.c    **** 	/* enable interrupts :  clear the global interupt mask	*/
 254:powerlog.c    **** 	/********************************************************/	
 255:powerlog.c    ****     sei ();    			 
 256:powerlog.c    **** 	
 257:powerlog.c    **** 	return(TRUE);
 258:powerlog.c    **** }
 259:powerlog.c    **** 
 260:powerlog.c    **** 
 261:powerlog.c    **** 
 262:powerlog.c    **** 
 263:powerlog.c    **** 
 264:powerlog.c    **** /* ****************************************************************
 265:powerlog.c    **** *
 266:powerlog.c    **** * Name			: SIG_OVERFLOW1
 267:powerlog.c    **** *
 268:powerlog.c    **** * Function		: Timer_1 owerflow Interupt routine
 269:powerlog.c    **** *
 270:powerlog.c    **** * Parameters	: void
 271:powerlog.c    **** *
 272:powerlog.c    **** * Returns		: void
 273:powerlog.c    **** *
 274:powerlog.c    **** * Modify		: Global: IRQ_done
 275:powerlog.c    **** *
 276:powerlog.c    **** * Checked		:
 277:powerlog.c    **** *
 278:powerlog.c    **** * Requirements	:
 279:powerlog.c    **** * Description	: Reads the contrast and brightness controls and write to OLED
 280:powerlog.c    **** *				  and DA - converter trough i2C bus.
 281:powerlog.c    **** *
 282:powerlog.c    **** ***************************************************************** */
 283:powerlog.c    **** SIGNAL(SIG_OVERFLOW1)
 284:powerlog.c    **** {
 285:powerlog.c    **** 	cli();						/* disable interrupts, no interupt during I2C bus transfer */
 286:powerlog.c    **** 
 287:powerlog.c    **** 	timer_of++;
 288:powerlog.c    **** 	TCNT1 = 0;
 289:powerlog.c    **** 	printf("Timer overflow number %i\n\r", timer_of);
 290:powerlog.c    **** 
 291:powerlog.c    **** 	sei();						/* enable interrupts */
 292:powerlog.c    **** }
 293:powerlog.c    **** 
 294:powerlog.c    **** /* ****************************************************************
 295:powerlog.c    **** *
 296:powerlog.c    **** * Name			: SIG_INTERUPT0
 297:powerlog.c    **** *
 298:powerlog.c    **** * Function		: Extern interupt on PORTD[2]
 299:powerlog.c    **** *
 300:powerlog.c    **** * Parameters	: void
 301:powerlog.c    **** *
 302:powerlog.c    **** * Returns		: void
 303:powerlog.c    **** *
 304:powerlog.c    **** * Checked		:
 305:powerlog.c    **** *
 306:powerlog.c    **** * Requirements	:
 307:powerlog.c    **** * Description	: IR Sensor input (active low about 1,6 ms)
 308:powerlog.c    **** *
 309:powerlog.c    **** ***************************************************************** */
 310:powerlog.c    **** ISR(SIG_INTERRUPT2)
 311:powerlog.c    **** {
 382               		push r24
 383               		push r25
 384               		push r26
 385 0122 1F92      		push r27
 386 0124 0F92      		push r30
 387 0126 0FB6      		push r31
 388 0128 0F92      	/* prologue: Signal */
 389 012a 1124      	/* frame size = 0 */
 391 012e 3F93      	.LM25:
 392 0130 4F93      	/* #APP */
 393 0132 5F93      	 ;  316 "powerlog.c" 1
 394 0134 6F93      		cli
 395 0136 7F93      	 ;  0 "" 2
 397 013a 9F93      	.LM26:
 398 013c AF93      	/* #NOAPP */
 399 013e BF93      		ldi r30,lo8(132)
 400 0140 EF93      		ldi r31,hi8(132)
 401 0142 FF93      		ld r22,Z
 402               		ldd r23,Z+1
 312:powerlog.c    **** 	uint16_t cycles;
 313:powerlog.c    **** 	//uint32_t time_us;
 314:powerlog.c    **** 	uint16_t time_ms;
 315:powerlog.c    **** 	
 316:powerlog.c    **** 	cli();						// disable interrupts, no interrupt during sensor active input
 404               	_reg__
 405               		st Z,__zero_reg__
 407               	.LM28:
 408 0144 F894      		ldi r24,lo8(0)
 409               		ldi r25,hi8(0)
 317:powerlog.c    **** 	
 318:powerlog.c    **** 	
 319:powerlog.c    **** 	
 320:powerlog.c    **** 	cycles = TCNT1;
 410               	__floatunsisf
 411               		ldi r18,lo8(0x3f83126f)
 412               		ldi r19,hi8(0x3f83126f)
 413 0146 E4E8      		ldi r20,hlo8(0x3f83126f)
 414 0148 F0E0      		ldi r21,hhi8(0x3f83126f)
 415 014a 6081      		call __mulsf3
 416 014c 7181      		call __fixunssfsi
 321:powerlog.c    **** 	TCNT1 = 0; 		// reset timer counter
 417               		68,0,324,.LM29-.LFBB3
 418               	.LM29:
 419 014e 1182      		lds r18,accPulseTime
 420 0150 1082      		lds r19,(accPulseTime)+1
 322:powerlog.c    **** 
 323:powerlog.c    **** 	//time_us = cycles * TIMER_CYCLE_US;
 421               	 r18,r22
 422               		adc r19,r23
 423 0152 80E0      		sts (accPulseTime)+1,r19
 424 0154 90E0      		sts accPulseTime,r18
 426 015a 2FE6      	.LM30:
 427 015c 32E1      		movw r18,r22
 428 015e 43E8      		ldi r20,lo8(0)
 429 0160 5FE3      		ldi r21,hi8(0)
 430 0162 0E94 0000 		ldi r22,lo8(3600000)
 431 0166 0E94 0000 		ldi r23,hi8(3600000)
 324:powerlog.c    **** 
 432               	o8(3600000)
 433               		ldi r25,hhi8(3600000)
 434 016a 2091 0000 		call __divmodsi4
 435 016e 3091 0000 		sts (power)+1,r19
 436 0172 260F      		sts power,r18
 438 0176 3093 0000 	.LM31:
 439 017a 2093 0000 		lds r24,pulse
 325:powerlog.c    **** 
 440               	,(pulse)+1
 441               		adiw r24,1
 442 017e 9B01      		sts (pulse)+1,r25
 443 0180 40E0      		sts pulse,r24
 445 0184 60E8      	.LM32:
 446 0186 7EEE      	/* #APP */
 447 0188 86E3      	 ;  332 "powerlog.c" 1
 448 018a 90E0      		sei
 449 018c 0E94 0000 	 ;  0 "" 2
 450 0190 3093 0000 	/* epilogue start */
 326:powerlog.c    **** 
 327:powerlog.c    **** 	time_ms = (uint16_t) (cycles * (TIMER_CYCLE_US / 1000.0));
 452               	OAPP */
 453               		pop r31
 454 0198 8091 0000 		pop r30
 455 019c 9091 0000 		pop r27
 456 01a0 0196      		pop r26
 457 01a2 9093 0000 		pop r25
 458 01a6 8093 0000 		pop r24
 328:powerlog.c    **** 
 329:powerlog.c    **** 	accPulseTime += time_ms;
 330:powerlog.c    **** 	power = (uint16_t) (3600000 / time_ms);
 331:powerlog.c    **** 
 332:powerlog.c    **** 	pulse++;
 459               	3
 460               		pop r22
 461               		pop r21
 462               		pop r20
 463 01aa 7894      		pop r19
 464               		pop r18
 465               		pop r0
 333:powerlog.c    **** 
 466               	SREG__,r0
 467               		pop r0
 468               		pop __zero_reg__
 469 01ac FF91      		reti
 475 01b8 7F91      	.Lscope3:
 477 01bc 5F91      	.global	__vector_2
 479 01c0 3F91      	__vector_2:
 481 01c4 0F90      	.LM34:
 482 01c6 0FBE      	.LFBB4:
 483 01c8 0F90      		push __zero_reg__
 484 01ca 1F90      		push r0
 485 01cc 1895      		in r0,__SREG__
 486               		push r0
 487               		clr __zero_reg__
 488               	/* prologue: Signal */
 489               	/* frame size = 0 */
 491               	.LM35:
 492               	/* #APP */
 493               	 ;  337 "powerlog.c" 1
 494               		cli
 495               	 ;  0 "" 2
 334:powerlog.c    **** 
 335:powerlog.c    **** 	//printf("Puls nr %i @ Tid: %u cykler = %u ms = %u W\n\r", pulse, cycles, time_ms, power);
 336:powerlog.c    **** 	
 496               	.LM36:
 497               	 ;  341 "powerlog.c" 1
 498               		sei
 499 01ce 1F92      	 ;  0 "" 2
 500 01d0 0F92      	/* epilogue start */
 502 01d4 0F92      	.LM37:
 503 01d6 1124      	/* #NOAPP */
 504               		pop r0
 505               		out __SREG__,r0
 337:powerlog.c    **** 
 506               	op __zero_reg__
 507               		reti
 509               	.Lscope4:
 511               	.global	__vector_1
 338:powerlog.c    **** 
 339:powerlog.c    **** 	//sprintf(txData, "%i,%u;", pulse, power);
 340:powerlog.c    **** 
 341:powerlog.c    **** 	sei();									/* enable interrupts */
 512               		__vector_1, @function
 513               	__vector_1:
 515 01da 7894      	.LM38:
 516               	.LFBB5:
 517               		push __zero_reg__
 342:powerlog.c    **** 
 518               	r0
 519               		in r0,__SREG__
 520               		push r0
 521 01dc 0F90      		clr __zero_reg__
 522 01de 0FBE      	/* prologue: Signal */
 523 01e0 0F90      	/* frame size = 0 */
 525 01e4 1895      	.LM39:
 526               	/* #APP */
 527               	 ;  347 "powerlog.c" 1
 528               		cli
 529               	 ;  0 "" 2
 531               	.LM40:
 343:powerlog.c    **** 
 344:powerlog.c    **** }
 345:powerlog.c    **** 
 346:powerlog.c    **** SIGNAL(SIG_INTERRUPT1)
 532               	log.c" 1
 533               		sei
 534               	 ;  0 "" 2
 535 01e6 1F92      	/* epilogue start */
 537 01ea 0FB6      	.LM41:
 538 01ec 0F92      	/* #NOAPP */
 539 01ee 1124      		pop r0
 540               		out __SREG__,r0
 541               		pop r0
 347:powerlog.c    **** 
 542               	o_reg__
 543               		reti
 545               	.Lscope5:
 547               	.global	__vector_7
 348:powerlog.c    **** 
 349:powerlog.c    **** {
 350:powerlog.c    **** 	cli();									/* disable interrupts, no interrupt during I2C bus transfer */
 548               		__vector_7, @function
 549               	__vector_7:
 551 01f2 7894      	.LM42:
 552               	.LFBB6:
 553               		push __zero_reg__
 351:powerlog.c    **** 
 554               	r0
 555               		in r0,__SREG__
 556               		push r0
 557 01f4 0F90      		clr __zero_reg__
 558 01f6 0FBE      	/* prologue: Signal */
 559 01f8 0F90      	/* frame size = 0 */
 561 01fc 1895      	.LM43:
 562               	/* #APP */
 563               	 ;  356 "powerlog.c" 1
 564               		cli
 565               	 ;  0 "" 2
 567               	.LM44:
 352:powerlog.c    **** 
 353:powerlog.c    **** 
 354:powerlog.c    **** 	
 355:powerlog.c    **** 
 568               	log.c" 1
 569               		sei
 570               	 ;  0 "" 2
 571 01fe 1F92      	/* epilogue start */
 573 0202 0FB6      	.LM45:
 574 0204 0F92      	/* #NOAPP */
 575 0206 1124      		pop r0
 576               		out __SREG__,r0
 577               		pop r0
 356:powerlog.c    **** 
 578               	o_reg__
 579               		reti
 581               	.Lscope6:
 357:powerlog.c    **** 
 358:powerlog.c    **** 	sei();									/* enable interrupts */
 359:powerlog.c    **** }
 360:powerlog.c    **** 
 584               	l	parseMsg
 586               	parseMsg:
 588               	.LM46:
 589               	.LFBB7:
 361:powerlog.c    **** 
 590               	r29
 591               		push r28
 592               		in r28,__SP_L__
 593 020c 0F90      		in r29,__SP_H__
 594 020e 0FBE      		sbiw r28,7
 595 0210 0F90      		in __tmp_reg__,__SREG__
 596 0212 1F90      		cli
 597 0214 1895      		out __SP_H__,r29
 598               		out __SREG__,__tmp_reg__
 599               		out __SP_L__,r28
 600               	/* prologue: function */
 601               	/* frame size = 7 */
 603               	.LM47:
 604               		ldi r24,lo8(1)
 362:powerlog.c    **** 
 363:powerlog.c    **** 
 364:powerlog.c    **** ISR (SIG_INTERRUPT0)
 365:powerlog.c    **** {
 366:powerlog.c    **** 	cli();									/* disable interrupts, no interrupt during I2C bus transfer */
 367:powerlog.c    **** 
 368:powerlog.c    **** 
 369:powerlog.c    **** 	sei();									/* enable interrupts */
 605               	rt */
 606               		adiw r28,7
 607               		in __tmp_reg__,__SREG__
 608 0216 DF93      		cli
 609 0218 CF93      		out __SP_H__,r29
 610 021a CDB7      		out __SREG__,__tmp_reg__
 611 021c DEB7      		out __SP_L__,r28
 612 021e 2797      		pop r28
 613 0220 0FB6      		pop r29
 614 0222 F894      		ret
 616 0226 0FBE      	.Lscope7:
 617 0228 CDBF      		.data
 618               	.LC0:
 619               		.string	"Timer overflow number %i\n\r"
 370:powerlog.c    **** 
 371:powerlog.c    **** }
 372:powerlog.c    **** 
 373:powerlog.c    **** 
 374:powerlog.c    **** ISR (SIG_PIN_CHANGE3)
 375:powerlog.c    **** {
 376:powerlog.c    **** 	cli();									/* disable interrupts, no interrupt during I2C bus transfer */
 377:powerlog.c    **** 
 378:powerlog.c    **** 	
 379:powerlog.c    **** 
 380:powerlog.c    **** 	sei();									/* enable interrupts */
 381:powerlog.c    **** }
 382:powerlog.c    **** 
 383:powerlog.c    **** 
 384:powerlog.c    **** 
 385:powerlog.c    **** 
 386:powerlog.c    **** 
 387:powerlog.c    **** 
 388:powerlog.c    **** unsigned char parseMsg(msgType msg)
 389:powerlog.c    **** {
 390:powerlog.c    **** /*
 391:powerlog.c    **** 	msgType txMsg;
 392:powerlog.c    **** 
 393:powerlog.c    **** 	uint16_t temp;
 394:powerlog.c    **** 	
 395:powerlog.c    **** 	txMsg.devAddr = 0;
 396:powerlog.c    **** 	txMsg.command = msg.command;
 397:powerlog.c    **** 	txMsg.size = 0;
 398:powerlog.c    **** 	txMsg.chksum = 0;
 399:powerlog.c    **** 	txMsg.data_ptr = &txData[0];
 400:powerlog.c    **** 
 401:powerlog.c    **** 	
 402:powerlog.c    **** 	
 403:powerlog.c    **** 	if (msg.devAddr != MYADDRESS)
 404:powerlog.c    **** 		return 0;
 405:powerlog.c    **** 	else
 406:powerlog.c    **** 	{
 407:powerlog.c    **** 		switch (msg.command)
 408:powerlog.c    **** 		{
 409:powerlog.c    **** 			case READ_POWER :
 410:powerlog.c    **** 				
 411:powerlog.c    **** 				temp = power;
 412:powerlog.c    **** 				
 413:powerlog.c    **** 				txMsg.size = 2;
 414:powerlog.c    **** 				txData[0] = (uint8_t) (temp >> 8);		// msb
 415:powerlog.c    **** 				txData[1] = (uint8_t) (temp & 0xFF);	// lsb
 416:powerlog.c    **** 				
 417:powerlog.c    **** 				break;
 418:powerlog.c    **** 				
 419:powerlog.c    **** 			case READ_PULSES : 
 420:powerlog.c    **** 				
 421:powerlog.c    **** 				temp = pulse;
 422:powerlog.c    **** 				pulse = 0;
 423:powerlog.c    **** 				
 424:powerlog.c    **** 				txMsg.size = 2;
 425:powerlog.c    **** 				txData[0] = (uint8_t) (temp >> 8);		// msb
 426:powerlog.c    **** 				txData[1] = (uint8_t) (temp & 0xFF);	// lsb
 427:powerlog.c    **** 				
 428:powerlog.c    **** 				break;
 429:powerlog.c    **** 				
 430:powerlog.c    **** 			case READ_VOLTAGE :
 620               	"__vector_15:F(0,15)",36,0,0,__vector_15
 621               	.global	__vector_15
 623               	__vector_15:
 625 022e 0FB6      	.LM48:
 626 0230 F894      	.LFBB8:
 627 0232 DEBF      		push __zero_reg__
 628 0234 0FBE      		push r0
 629 0236 CDBF      		in r0,__SREG__
 630 0238 CF91      		push r0
 631 023a DF91      		clr __zero_reg__
 632 023c 0895      		push r18
 633               		push r19
 634               		push r20
 635               		push r21
 636               		push r22
 637 0000 5469 6D65 		push r23
 637      7220 6F76 
 637      6572 666C 
 637      6F77 206E 
 637      756D 6265 
 638               		push r24
 639               		push r25
 640               		push r26
 641               		push r27
 642               		push r30
 643               		push r31
 644               	/* prologue: Signal */
 645               	/* frame size = 0 */
 647 0240 0F92      	.LM49:
 648 0242 0FB6      	/* #APP */
 649 0244 0F92      	 ;  285 "powerlog.c" 1
 650 0246 1124      		cli
 651 0248 2F93      	 ;  0 "" 2
 653 024c 4F93      	.LM50:
 654 024e 5F93      	/* #NOAPP */
 655 0250 6F93      		lds r24,timer_of
 656 0252 7F93      		subi r24,lo8(-(1))
 657 0254 8F93      		sts timer_of,r24
 659 0258 AF93      	.LM51:
 660 025a BF93      		sts (132)+1,__zero_reg__
 661 025c EF93      		sts 132,__zero_reg__
 663               	.LM52:
 664               		lds r18,timer_of
 665               		rcall .
 666               		rcall .
 667               		in r30,__SP_L__
 668               		in r31,__SP_H__
 669 0260 F894      		adiw r30,1
 670               		ldi r24,lo8(.LC0)
 671               		ldi r25,hi8(.LC0)
 672               		std Z+1,r25
 673               		st Z,r24
 674 0262 8091 0000 		std Z+2,r18
 675 0266 8F5F      		std Z+3,__zero_reg__
 676 0268 8093 0000 		call printf
 678               	.LM53:
 679 026c 1092 8500 	/* #APP */
 680 0270 1092 8400 	 ;  291 "powerlog.c" 1
 681               		sei
 682               	 ;  0 "" 2
 683 0274 2091 0000 	/* #NOAPP */
 684 0278 00D0      		pop __tmp_reg__
 685 027a 00D0      		pop __tmp_reg__
 686 027c EDB7      		pop __tmp_reg__
 687 027e FEB7      		pop __tmp_reg__
 688 0280 3196      	/* epilogue start */
 690 0284 90E0      	.LM54:
 691 0286 9183      		pop r31
 692 0288 8083      		pop r30
 693 028a 2283      		pop r27
 694 028c 1382      		pop r26
 695 028e 0E94 0000 		pop r25
 696               		pop r24
 697               		pop r23
 698               		pop r22
 699               		pop r21
 700 0292 7894      		pop r20
 701               		pop r19
 702               		pop r18
 703 0294 0F90      		pop r0
 704 0296 0F90      		out __SREG__,r0
 705 0298 0F90      		pop r0
 706 029a 0F90      		pop __zero_reg__
 707               		reti
 709               	.Lscope8:
 711 029e EF91      	.global	ioinit
 713 02a2 AF91      	ioinit:
 715 02a6 8F91      	.LM55:
 716 02a8 7F91      	.LFBB9:
 717 02aa 6F91      	/* prologue: function */
 718 02ac 5F91      	/* frame size = 0 */
 720 02b0 3F91      	.LM56:
 721 02b2 2F91      		ldi r24,lo8(127)
 722 02b4 0F90      		out 33-32,r24
 724 02b8 0F90      	.LM57:
 725 02ba 1F90      		ldi r24,lo8(8)
 726 02bc 1895      		out 34-32,r24
 728               	.LM58:
 729               		ldi r25,lo8(-96)
 730               		out 36-32,r25
 732               	.LM59:
 733               		out 37-32,__zero_reg__
 735               	.LM60:
 736               		out 39-32,__zero_reg__
 738               	.LM61:
 739               		out 40-32,__zero_reg__
 741 02c0 81B9      	.LM62:
 742               		ldi r24,lo8(98)
 743               		out 42-32,r24
 745 02c4 82B9      	.LM63:
 746               		out 43-32,__zero_reg__
 748 02c6 90EA      	.LM64:
 749 02c8 94B9      		ldi r30,lo8(61)
 750               		ldi r31,hi8(61)
 751               		st Z,__zero_reg__
 753               	.LM65:
 754               		sts 105,r25
 756               	.LM66:
 757               		ldi r24,lo8(7)
 758 02ce 18B8      		out 60-32,r24
 760               	.LM67:
 761 02d0 82E6      		ldi r24,lo8(4)
 762 02d2 8AB9      		st Z,r24
 764               	.LM68:
 765 02d4 1BB8      		sts 115,__zero_reg__
 767               	.LM69:
 768 02d6 EDE3      		sts 109,__zero_reg__
 770 02da 1082      	.LM70:
 771               		sts 108,__zero_reg__
 773 02dc 9093 6900 	.LM71:
 774               		sts 107,__zero_reg__
 776 02e0 87E0      	.LM72:
 777 02e2 8CBB      		sts 104,__zero_reg__
 779               	.LM73:
 780 02e4 84E0      		sts 128,__zero_reg__
 782               	.LM74:
 783               		ldi r24,lo8(5)
 784 02e8 1092 7300 		sts 129,r24
 786               	.LM75:
 787 02ec 1092 6D00 		sts (136)+1,__zero_reg__
 788               		sts 136,__zero_reg__
 790 02f0 1092 6C00 	.LM76:
 791               		sts 100,__zero_reg__
 793 02f4 1092 6B00 	.LM77:
 794               		ldi r24,lo8(mystdout)
 795               		ldi r25,hi8(mystdout)
 796 02f8 1092 6800 		sts (__iob+2)+1,r25
 797               		sts __iob+2,r24
 799 02fc 1092 8000 	.LM78:
 800               		ldi r24,lo8(12)
 801               		ldi r25,hi8(12)
 802 0300 85E0      		call uart_init
 804               	.LM79:
 805               		call adc_init
 807 030a 1092 8800 	.LM80:
 808               	/* #APP */
 809               	 ;  255 "powerlog.c" 1
 810 030e 1092 6400 		sei
 811               	 ;  0 "" 2
 813 0312 80E0      	.LM81:
 814 0314 90E0      	/* #NOAPP */
 815 0316 9093 0000 		ldi r24,lo8(-1)
 816 031a 8093 0000 	/* epilogue start */
 817               		ret
 819 031e 8CE0      	.Lscope9:
 820 0320 90E0      		.data
 821 0322 0E94 0000 	.LC1:
 822               		.string	"Startup Completed, version 1.1\n\r"
 823               	.LC2:
 824 0326 0E94 0000 		.string	"0123456789:;<=>? "
 825               	.LC3:
 826               		.string	"Puls nr %i: %u W, v: %u mV\n"
 827               		.text
 829 032a 7894      	.global	main
 831               	main:
 833               	.LM82:
 834 032c 8FEF      	.LFBB10:
 835               		push r5
 836 032e 0895      		push r6
 837               		push r7
 838               		push r8
 839               		push r9
 840               		push r10
 841 001b 5374 6172 		push r11
 841      7475 7020 
 841      436F 6D70 
 841      6C65 7465 
 841      642C 2076 
 842               		push r12
 843 003c 3031 3233 		push r13
 843      3435 3637 
 843      3839 3A3B 
 843      3C3D 3E3F 
 843      2000 
 844               		push r14
 845 004e 5075 6C73 		push r15
 845      206E 7220 
 845      2569 3A20 
 845      2575 2057 
 845      2C20 763A 
 846               		push r16
 847               		push r17
 848               		push r28
 849               		push r29
 850               	/* prologue: function */
 431:powerlog.c    **** 
 432:powerlog.c    **** 			
 433:powerlog.c    **** 				
 434:powerlog.c    **** 				txMsg.size = 1;
 435:powerlog.c    **** 				txData[0] = voltage;
 436:powerlog.c    **** 				
 437:powerlog.c    **** 				break;
 438:powerlog.c    **** 			
 439:powerlog.c    **** 			default : 
 440:powerlog.c    **** 
 441:powerlog.c    **** 				return 0;
 442:powerlog.c    **** 				
 443:powerlog.c    **** 				break;
 444:powerlog.c    **** 		}
 445:powerlog.c    **** 
 446:powerlog.c    **** 		sendMsg(txMsg);
 447:powerlog.c    **** 	*/
 448:powerlog.c    **** 		return 1;
 851               	.LFBB10
 852               	.LM86:
 853               		call init_SPI
 855 0332 6F92      	.LM87:
 856 0334 7F92      		ldi r24,lo8(100)
 857 0336 8F92      		ldi r25,hi8(100)
 858 0338 9F92      		call delay_us
 860 033c BF92      	.LM88:
 861 033e CF92      		ldi r24,lo8(7)
 862 0340 DF92      		ldi r22,lo8(-128)
 863 0342 EF92      		call write_RFM
 865 0346 0F93      	.LM89:
 866 0348 1F93      		ldi r24,lo8(10000)
 867 034a CF93      		ldi r25,hi8(10000)
 868 034c DF93      		call delay_us
 870               	.LM90:
 449:powerlog.c    **** 
 450:powerlog.c    **** 	//}
 871               	i r31,hi8(34)
 872               		ld r24,Z
 873 034e 1092 0000 		ori r24,lo8(8)
 451:powerlog.c    **** 
 452:powerlog.c    **** 
 453:powerlog.c    **** }
 874               	 Z,r24
 876 0352 8FEF      	.LM91:
 877 0354 8093 0000 		rcall .
 454:powerlog.c    **** 
 455:powerlog.c    **** 
 456:powerlog.c    **** 
 457:powerlog.c    **** 
 458:powerlog.c    **** 
 459:powerlog.c    **** /* ****************************************************************
 460:powerlog.c    **** *
 461:powerlog.c    **** * Name			: main
 462:powerlog.c    **** *
 463:powerlog.c    **** * Function		: main routine
 464:powerlog.c    **** *
 465:powerlog.c    **** * Parameters	: void
 878               	 r24,lo8(.LC1)
 879               		ldi r25,hi8(.LC1)
 880 0358 0E94 0000 		in r30,__SP_L__
 466:powerlog.c    **** 
 881               	 r31,__SP_H__
 882               		std Z+2,r25
 883 035c 0E94 0000 		std Z+1,r24
 467:powerlog.c    **** 
 468:powerlog.c    **** *
 884               	ll printf
 886 0360 84E6      	.LM92:
 887 0362 90E0      		pop __tmp_reg__
 888 0364 0E94 0000 		pop __tmp_reg__
 469:powerlog.c    **** 
 889               	r24,lo8(0)
 890               		call read_RFM
 892 036a 60E8      	.LM93:
 893 036c 0E94 0000 		ldi r24,lo8(1)
 470:powerlog.c    **** 
 471:powerlog.c    **** * Returns		: int 0
 894               	 read_RFM
 896 0370 80E1      	.LM94:
 897 0372 97E2      		ldi r24,lo8(5)
 898 0374 0E94 0000 		call read_RFM
 472:powerlog.c    **** 
 473:powerlog.c    **** *
 899               	bn	68,0,480,.LM95-.LFBB10
 900               	.LM95:
 901 0378 E2E2      		ldi r24,lo8(6)
 902 037a F0E0      		call read_RFM
 904 037e 8860      	.LM96:
 905 0380 8083      		ldi r24,lo8(7)
 474:powerlog.c    **** 
 475:powerlog.c    **** ***************************************************************** */
 906               	ead_RFM
 908 0382 00D0      	.LM97:
 909 0384 80E0      		ldi r24,lo8(8)
 910 0386 90E0      		call read_RFM
 912 038a FEB7      	.LM98:
 913 038c 9283      		call init_RFM22
 915 0390 0E94 0000 	.LM99:
 476:powerlog.c    **** 
 477:powerlog.c    **** 
 916               	x_mode
 918 0394 0F90      	.LM100:
 919 0396 0F90      		ldi r26,lo8(txData)
 920 0398 80E0      		ldi r27,hi8(txData)
 921 039a 0E94 0000 		ldi r30,lo8(.LC2)
 478:powerlog.c    **** 
 922               	31,hi8(.LC2)
 923               		ldi r24,lo8(18)
 924 039e 81E0      	.L46:
 925 03a0 0E94 0000 		ld r0,Z+
 479:powerlog.c    **** 
 926               	X+,r0
 927               		subi r24,lo8(-(-1))
 928 03a4 85E0      		brne .L46
 929 03a6 0E94 0000 		ldi r28,lo8(0)
 480:powerlog.c    **** 
 930               	all to_tx_mode
 932 03aa 86E0      	.LM100:
 933 03ac 0E94 0000 		ldi r26,lo8(txData)
 481:powerlog.c    **** 
 934               	 r27,hi8(txData)
 935               		ldi r30,lo8(.LC2)
 936 03b0 87E0      		ldi r31,hi8(.LC2)
 937 03b2 0E94 0000 		ldi r24,lo8(18)
 482:powerlog.c    **** 
 938               	:
 939               		ld r0,Z+
 940 03b6 88E0      		st X+,r0
 941 03b8 0E94 0000 		subi r24,lo8(-(-1))
 483:powerlog.c    **** 
 484:powerlog.c    **** int main(void)
 942               	0,485,.LM99-.LFBB10
 943               	.LM99:
 944 03bc 0E94 0000 		call to_tx_mode
 485:powerlog.c    **** 
 945               	tabn	68,0,487,.LM100-.LFBB10
 946               	.LM100:
 947 03c0 0E94 0000 		ldi r26,lo8(txData)
 486:powerlog.c    **** 
 487:powerlog.c    **** {
 948               	i r27,hi8(txData)
 949               		ldi r30,lo8(.LC2)
 950 03c4 A0E0      		ldi r31,hi8(.LC2)
 951 03c6 B0E0      		ldi r24,lo8(18)
 952 03c8 E0E0      	.L46:
 953 03ca F0E0      		ld r0,Z+
 954 03cc 82E1      		st X+,r0
 955               		subi r24,lo8(-(-1))
 956 03ce 0190      		brne .L46
 957 03d0 0D92      		ldi r28,lo8(0)
 958 03d2 8150      		ldi r29,hi8(0)
 960 03d6 C0E0      	.LM101:
 961 03d8 D0E0      		mov __tmp_reg__,r31
 488:powerlog.c    **** 
 489:powerlog.c    **** 	char temp;
 490:powerlog.c    **** 	msgComplete = 0;
 491:powerlog.c    **** 	
 492:powerlog.c    **** 	uint16_t lastPulse = 0;
 493:powerlog.c    **** 	pos = -1;
 494:powerlog.c    **** 	
 495:powerlog.c    **** 	// External Oscillator frequency = 8 MHz
 496:powerlog.c    **** 	// set system clock frequency
 497:powerlog.c    **** 	//CLKPR = 1<<CLKPCE;
 498:powerlog.c    **** 	//CLKPR = 3; // set division factor to 8
 499:powerlog.c    **** 	
 500:powerlog.c    **** 	// Clk_sys set to 1 MHz
 501:powerlog.c    **** 	
 502:powerlog.c    **** 
 503:powerlog.c    **** 
 504:powerlog.c    **** 	
 505:powerlog.c    **** 	ioinit();			// init peripherals and GPIO pin directions and pullups
 506:powerlog.c    **** 	init_SPI();
 507:powerlog.c    **** 	
 508:powerlog.c    **** 	delay_us(100);
 509:powerlog.c    **** 	write_RFM(OMFC1, 0x80);	// issue sw reset
 510:powerlog.c    **** 	
 511:powerlog.c    **** 	delay_us(10000);		// wait for devices to startup
 512:powerlog.c    **** 
 513:powerlog.c    **** 	sbi(CSPORT,CS);
 514:powerlog.c    **** 	
 515:powerlog.c    **** 	printf("Startup Completed, version 1.1\n\r");
 516:powerlog.c    **** 
 517:powerlog.c    **** 	temp = read_RFM(DTYPE);
 518:powerlog.c    **** 	temp = read_RFM(DVERS);
 519:powerlog.c    **** 	temp = read_RFM(INTEN1);
 962               	2)
 963               		mov r5,r31
 964 03da 0F2E      		mov r31,__tmp_reg__
 966 03de 5F2E      	.LM102:
 967 03e0 F02D      		mov __tmp_reg__,r31
 520:powerlog.c    **** 
 521:powerlog.c    **** 	temp = read_RFM(INTEN2);
 522:powerlog.c    **** 	temp = read_RFM(OMFC1);
 968               	
 969               		brne .L46
 970 03e2 0F2E      		ldi r28,lo8(0)
 971 03e4 F0E0      		ldi r29,hi8(0)
 973 03e8 F0E0      	.LM101:
 974 03ea 7F2E      		mov __tmp_reg__,r31
 975 03ec F02D      		ldi r31,lo8(42)
 523:powerlog.c    **** 
 524:powerlog.c    **** 	temp = read_RFM(OMFC2);
 976               	di r30,lo8(.LC2)
 977               		ldi r31,hi8(.LC2)
 978 03ee 00E0      		ldi r24,lo8(18)
 979 03f0 10E0      	.L46:
 525:powerlog.c    **** 
 980               	r0,Z+
 981               		st X+,r0
 982 03f2 4801      		subi r24,lo8(-(-1))
 983 03f4 0894      		brne .L46
 984 03f6 811C      		ldi r28,lo8(0)
 985 03f8 911C      		ldi r29,hi8(0)
 526:powerlog.c    **** 
 986               	stabn	68,0,487,.LM100-.LFBB10
 987               	.LM100:
 988 03fa AA24      		ldi r26,lo8(txData)
 989 03fc BB24      		ldi r27,hi8(txData)
 990 03fe 6894      		ldi r30,lo8(.LC2)
 991 0400 A1F8      		ldi r31,hi8(.LC2)
 992 0402 A00E      		ldi r24,lo8(18)
 993 0404 B11E      	.L46:
 527:powerlog.c    **** 
 994               	+
 995               		st X+,r0
 996 0406 0F2E      		subi r24,lo8(-(-1))
 997 0408 F3E0      		brne .L46
 998 040a CF2E      		ldi r28,lo8(0)
 999 040c DD24      		ldi r29,hi8(0)
 1001 0410 C00E      	.LM101:
 1002 0412 D11E      		mov __tmp_reg__,r31
 528:powerlog.c    **** 
 1003               	r27,hi8(txData)
 1004               		ldi r30,lo8(.LC2)
 1005 0414 EE24      		ldi r31,hi8(.LC2)
 1006 0416 FF24      		ldi r24,lo8(18)
 1007 0418 6894      	.L46:
 1008 041a E2F8      		ld r0,Z+
 1009 041c E00E      		st X+,r0
 1010 041e F11E      		subi r24,lo8(-(-1))
 1011               		brne .L46
 1012               		ldi r28,lo8(0)
 1013               		ldi r29,hi8(0)
 1015 0424 9091 0000 	.LM101:
 1016 0428 8C17      		mov __tmp_reg__,r31
 1017 042a 9D07      		ldi r31,lo8(42)
 1018 042c 01F4      		mov r5,r31
 1019 042e 00C0      		mov r31,__tmp_reg__
 1021 0434 9091 0000 	.LM102:
 1022 0438 885E      		mov __tmp_reg__,r31
 1023 043a 9340      		ldi r31,lo8(.LC3)
 1024 043c 00F4      		mov r6,r31
 1025 043e 00C0      		ldi r31,hi8(.LC3)
 1026               		mov r7,r31
 1027               		mov r31,__tmp_reg__
 1029 0444 D091 0000 	.LM103:
 1030               		ldi r16,lo8(txData)
 1031               		ldi r17,hi8(txData)
 1033 044c 1092 0000 	.LM104:
 1034               		movw r8,r16
 1035               		sec
 1036 0450 0E94 0000 		adc r8,__zero_reg__
 1037 0454 859D      		adc r9,__zero_reg__
 1039 0458 1124      	.LM105:
 1040 045a 8093 0000 		clr r10
 1041               		clr r11
 1042               		set
 1043 045e 8091 0000 		bld r10,1
 1044 0462 9091 0000 		add r10,r16
 1045 0466 2091 0000 		adc r11,r17
 1047 046e 4091 0000 	.LM106:
 1048 0472 6DB7      		mov __tmp_reg__,r31
 1049 0474 7EB7      		ldi r31,lo8(3)
 1050 0476 6850      		mov r12,r31
 1051 0478 7040      		clr r13
 1052 047a 0FB6      		mov r31,__tmp_reg__
 1053 047c F894      		add r12,r16
 1054 047e 7EBF      		adc r13,r17
 1056 0482 6DBF      	.LM107:
 1057 0484 EDB7      		clr r14
 1058 0486 FEB7      		clr r15
 1059 0488 3196      		set
 1060 048a 7182      		bld r14,2
 1061 048c 6082      		add r14,r16
 1062 048e 9383      		adc r15,r17
 1063 0490 8283      	.L48:
 1065 0494 2483      	.LM108:
 1066 0496 4683      		lds r24,pulse
 1067 0498 1782      		lds r25,(pulse)+1
 1068 049a 0E94 0000 		cp r24,r28
 1069               		cpc r25,r29
 1070               		brne .+2
 1071 049e 8091 0000 		rjmp .L47
 1072 04a2 9091 0000 		lds r24,accPulseTime
 1073 04a6 F801      		lds r25,(accPulseTime)+1
 1074 04a8 9083      		subi r24,lo8(1000)
 1075               		sbci r25,hi8(1000)
 1076               		brsh .+2
 1077 04aa 8091 0000 		rjmp .L47
 1079 04b2 F401      	.LM109:
 1080 04b4 8083      		lds r28,pulse
 1081               		lds r29,(pulse)+1
 1083 04b6 8091 0000 	.LM110:
 1084 04ba 9091 0000 		sts (accPulseTime)+1,__zero_reg__
 1085 04be F501      		sts accPulseTime,__zero_reg__
 1087               	.LM111:
 1088               		call read_adc
 1089 04c2 8091 0000 		mul r24,r5
 1090 04c6 9091 0000 		movw r24,r0
 1091 04ca F601      		clr r1
 1092 04cc 8083      		sts voltage,r24
 1094               	.LM112:
 1095 04ce 8091 0000 		lds r24,pulse
 1096 04d2 F701      		lds r25,(pulse)+1
 1097 04d4 8083      		lds r18,power
 529:powerlog.c    **** 
 530:powerlog.c    **** 	
 1098               	i r23,hi8(-(-8))
 1099               		in __tmp_reg__,__SREG__
 1100 04d6 6DB7      		cli
 1101 04d8 7EB7      		out __SP_H__,r23
 1102 04da 685F      		out __SREG__,__tmp_reg__
 1103 04dc 7F4F      		out __SP_L__,r22
 1104 04de 0FB6      		in r30,__SP_L__
 1105 04e0 F894      		in r31,__SP_H__
 1106 04e2 7EBF      		adiw r30,1
 1107 04e4 0FBE      		std Z+1,r7
 1108 04e6 6DBF      		st Z,r6
 1109 04e8 85E0      		std Z+3,r25
 1110 04ea 90E0      		std Z+2,r24
 1111 04ec B801      		std Z+5,r19
 1112 04ee 0E94 0000 		std Z+4,r18
 1113               		std Z+6,r20
 531:powerlog.c    **** 
 532:powerlog.c    **** 	init_RFM22();	// Initialize all RFM22 registers
 533:powerlog.c    **** 	to_tx_mode();	// Send test packet	'0123456789:;<=>?"
 534:powerlog.c    **** 	
 535:powerlog.c    **** 	sprintf(txData, "0123456789:;<=>? ");
 1114               	_L__
 1115               		in r31,__SP_H__
 1116 04f2 84E6      		adiw r30,1
 1117 04f4 90E0      		std Z+1,r7
 1118 04f6 0E94 0000 		st Z,r6
 1119 04fa 00C0      		std Z+3,r25
 1120               		std Z+2,r24
 1121               		std Z+5,r19
 1122               		std Z+4,r18
 1123               		std Z+6,r20
 1124               		std Z+7,__zero_reg__
 1125               		call printf
 1127               	.LM113:
 1128               		lds r24,pulse
 1129               		lds r25,(pulse)+1
 1130               		movw r30,r16
 1131 0000 0000      		st Z,r25
 1133               	.LM114:
 1134               		lds r24,pulse
 1135               		lds r25,(pulse)+1
 1136               		movw r30,r8
 1137 0002 0000      		st Z,r24
 1139               	.LM115:
 1140               		lds r24,power
 1141               		lds r25,(power)+1
 1142               		movw r30,r10
 1143 0004 0000      		st Z,r25
 1145               	.LM116:
 1146               		lds r24,power
 1147               		lds r25,(power)+1
 1148               		movw r30,r12
 1149 0006 00        		st Z,r24
 1151               	.LM117:
 1152               		lds r24,voltage
 1153               		movw r30,r14
 1154               		st Z,r24
 1156               	.LM118:
 1157               		in r22,__SP_L__
 1158               		in r23,__SP_H__
 1159               		subi r22,lo8(-(8))
 1160 006a 0000 00   		sbci r23,hi8(-(8))
 1161 006d 02        		in __tmp_reg__,__SREG__
 1162 006e 0000 0000 		cli
 1163 0072 0000      		out __SP_H__,r23
 1164 0074 0000      		out __SREG__,__tmp_reg__
 1165 0076 0000      		out __SP_L__,r22
 1166               		ldi r24,lo8(5)
 1167               		ldi r25,hi8(5)
 1168               		movw r22,r16
 1169               		call sendMsg
 1170               	.L47:
 1172               	.LM119:
 1173               		ldi r24,lo8(100)
 1174               		ldi r25,hi8(100)
 1175               		call delay_ms
 1176               		rjmp .L48
 1181               	.Lscope10:
 1182               	.global	pulse
 1183               	.global	pulse
 1184               		.section .bss
DEFINED SYMBOLS
                            *ABS*:00000000 powerlog.c
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:2      *ABS*:0000003f __SREG__
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:3      *ABS*:0000003e __SP_H__
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:4      *ABS*:0000003d __SP_L__
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:5      *ABS*:00000034 __CCP__
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:7      *ABS*:00000001 __zero_reg__
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:106    .text:00000000 delay_us
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:341    .text:00000100 delay_ms
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:381    .text:00000122 __vector_3
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:1142   .bss:00000004 accPulseTime
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:1136   .bss:00000002 power
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:1130   .bss:00000000 pulse
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:495    .text:000001ce __vector_2
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:531    .text:000001e6 __vector_1
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:567    .text:000001fe __vector_7
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:604    .text:00000216 parseMsg
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:642    .text:0000023e __vector_15
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:1148   .bss:00000006 timer_of
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:732    .text:000002be ioinit
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:1159   .data:0000006a mystdout
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:850    .text:00000330 main
                            *COM*:00000001 msgComplete
                            *COM*:00000001 pos
                            *COM*:00000011 txData
C:\Users\joakim\AppData\Local\Temp/ccGliJ3A.s:1154   .bss:00000007 voltage
                            *COM*:0000000a rxCommand
                            *COM*:00000007 rxMsg

UNDEFINED SYMBOLS
__floatunsisf
__mulsf3
__ltsf2
__gtsf2
__divsf3
__fixunssfsi
__divmodsi4
printf
__iob
uart_init
adc_init
init_SPI
write_RFM
read_RFM
init_RFM22
to_tx_mode
read_adc
sendMsg
uart_putchar
__do_copy_data
__do_clear_bss
